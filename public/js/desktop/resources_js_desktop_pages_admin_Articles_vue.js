"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_desktop_pages_admin_Articles_vue"],{

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   popperGenerator: () => (/* binding */ popperGenerator)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ \"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ \"./node_modules/@popperjs/core/lib/utils/orderModifiers.js\");\n/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debounce.js */ \"./node_modules/@popperjs/core/lib/utils/debounce.js\");\n/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ \"./node_modules/@popperjs/core/lib/utils/mergeByName.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\n\n\n\n\n\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(reference.contextElement) : [],\n          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(popper), state.options.strategy === 'fixed'),\n          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDTjtBQUNRO0FBQ0o7QUFDTjtBQUNaO0FBQ007QUFDTTtBQUNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxxQkFBcUIsbUVBQVMsY0FBYywyRUFBaUIseUNBQXlDLDJFQUFpQjtBQUN2SCxrQkFBa0IsMkVBQWlCO0FBQ25DLFdBQVc7QUFDWDs7QUFFQSwrQkFBK0Isb0VBQWMsQ0FBQyxpRUFBVyx5REFBeUQ7O0FBRWxIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxxQkFBcUIsMEVBQWdCLFlBQVkseUVBQWU7QUFDaEUsa0JBQWtCLHVFQUFhO0FBQy9CLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7O0FBRWxEO0FBQ0Esc0VBQXNFO0FBQ3RFLFNBQVM7O0FBRVQsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsY0FBYyw4REFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzPzUwOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/createPopper.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contains)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUNoQztBQUNmLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUIsNERBQVk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxRQUFRO0FBQ1IsTUFBTTs7O0FBR047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzP2EyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/contains.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getBoundingClientRect)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDbEI7QUFDRjtBQUNjO0FBQ3RDO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDZEQUFhO0FBQ25DLHVDQUF1QyxxREFBSztBQUM1Qyx3Q0FBd0MscURBQUs7QUFDN0M7O0FBRUEsYUFBYSx5REFBUyxZQUFZLHlEQUFTO0FBQzNDOztBQUVBLDBCQUEwQixnRUFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzP2ZjYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcbiAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XG4gIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getClippingRect)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\");\n/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\");\n/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ \"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ \"./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ \"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(element).position) >= 0;\n  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(element) : element;\n\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);\n    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ1k7QUFDQTtBQUNJO0FBQ0o7QUFDTTtBQUNKO0FBQ007QUFDSTtBQUNoQjtBQUNWO0FBQ007QUFDaUI7QUFDaEI7O0FBRTVDO0FBQ0EsYUFBYSxxRUFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsK0NBQVEsR0FBRyxzRUFBZ0IsQ0FBQywrREFBZSx1QkFBdUIseURBQVMsMEVBQTBFLHNFQUFnQixDQUFDLCtEQUFlLENBQUMsa0VBQWtCO0FBQ3BPLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3QixpRUFBaUIsQ0FBQyw2REFBYTtBQUN2RCx3REFBd0QsZ0VBQWdCO0FBQ3hFLDRDQUE0Qyw2REFBYSxZQUFZLGdFQUFlOztBQUVwRixPQUFPLHlEQUFTO0FBQ2hCO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxXQUFXLHlEQUFTLG9CQUFvQix5REFBUSxvQ0FBb0MsNERBQVc7QUFDL0YsR0FBRztBQUNILEVBQUU7QUFDRjs7O0FBR2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFHO0FBQ3JCLG9CQUFvQixvREFBRztBQUN2QixxQkFBcUIsb0RBQUc7QUFDeEIsbUJBQW1CLG9EQUFHO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcz82ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getCompositeRect)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;\n  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(offsetParent);\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(documentElement)) {\n      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(offsetParent);\n    }\n\n    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErRDtBQUNoQjtBQUNKO0FBQ0s7QUFDVztBQUNGO0FBQ1I7QUFDUjs7QUFFekM7QUFDQTtBQUNBLGVBQWUscURBQUs7QUFDcEIsZUFBZSxxREFBSztBQUNwQjtBQUNBLEVBQUU7QUFDRjs7O0FBR2U7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDZEQUFhO0FBQzdDLDZCQUE2Qiw2REFBYTtBQUMxQyx3QkFBd0Isa0VBQWtCO0FBQzFDLGFBQWEscUVBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDJEQUFXO0FBQ25CLElBQUksOERBQWM7QUFDbEIsZUFBZSw2REFBYTtBQUM1Qjs7QUFFQSxRQUFRLDZEQUFhO0FBQ3JCLGdCQUFnQixxRUFBcUI7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsbUVBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzPzZlM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getComputedStyle)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getComputedStyle(element) {\n  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element).getComputedStyle(element);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ3hCO0FBQ2YsU0FBUyx5REFBUztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDlmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDocumentElement)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDN0I7QUFDZjtBQUNBLFdBQVcseURBQVM7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz8zYThjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDocumentRect)\n/* harmony export */ });\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element);\n  var y = -winScroll.scrollTop;\n\n  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(body || html).direction === 'rtl') {\n    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlEO0FBQ0o7QUFDTTtBQUNSO0FBQ1osQ0FBQztBQUN4Qzs7QUFFZTtBQUNmOztBQUVBLGFBQWEsa0VBQWtCO0FBQy9CLGtCQUFrQiwrREFBZTtBQUNqQztBQUNBLGNBQWMsbURBQUc7QUFDakIsZUFBZSxtREFBRztBQUNsQixrQ0FBa0MsbUVBQW1CO0FBQ3JEOztBQUVBLE1BQU0sZ0VBQWdCO0FBQ3RCLFNBQVMsbURBQUc7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcz9iZTA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getHTMLElementScroll)\n/* harmony export */ });\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/NTUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getLayoutRect)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStELENBQUM7QUFDaEU7O0FBRWU7QUFDZixtQkFBbUIscUVBQXFCLFdBQVc7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcz8wYzRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getNodeName)\n/* harmony export */ });\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/NzdjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getNodeScroll)\n/* harmony export */ });\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\");\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {\n    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node);\n  } else {\n    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1EO0FBQ1o7QUFDUztBQUNhO0FBQzlDO0FBQ2YsZUFBZSx5REFBUyxXQUFXLDZEQUFhO0FBQ2hELFdBQVcsK0RBQWU7QUFDMUIsSUFBSTtBQUNKLFdBQVcsb0VBQW9CO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzPzI4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOffsetParent)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ \"./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837\n  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n\n  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element);\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(currentNode)) < 0) {\n    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUM7QUFDSTtBQUNVO0FBQ1M7QUFDYjtBQUNGO0FBQ0M7O0FBRWhEO0FBQ0EsT0FBTyw2REFBYTtBQUNwQixFQUFFLGdFQUFnQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBLGtDQUFrQywrREFBVztBQUM3Qyw2QkFBNkIsK0RBQVc7O0FBRXhDLGNBQWMsNkRBQWE7QUFDM0I7QUFDQSxxQkFBcUIsZ0VBQWdCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkRBQWE7O0FBRWpDLE1BQU0sNERBQVk7QUFDbEI7QUFDQTs7QUFFQSxTQUFTLDZEQUFhLDBDQUEwQywyREFBVztBQUMzRSxjQUFjLGdFQUFnQixlQUFlO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdlO0FBQ2YsZUFBZSx5REFBUztBQUN4Qjs7QUFFQSx5QkFBeUIsOERBQWMsa0JBQWtCLGdFQUFnQjtBQUN6RTtBQUNBOztBQUVBLHVCQUF1QiwyREFBVyw2QkFBNkIsMkRBQVcsNkJBQTZCLGdFQUFnQjtBQUN2SDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/M2MwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getParentNode)\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\nfunction getParentNode(element) {\n  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element) // fallback\n\n  );\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDYztBQUNWO0FBQ2hDO0FBQ2YsTUFBTSwyREFBVztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFZO0FBQ2hCO0FBQ0EsSUFBSSxrRUFBa0I7O0FBRXRCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzPzVjYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getScrollParent)\n/* harmony export */ });\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node)) {\n    return node;\n  }\n\n  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDRTtBQUNOO0FBQ0s7QUFDakM7QUFDZiw0Q0FBNEMsMkRBQVc7QUFDdkQ7QUFDQTtBQUNBOztBQUVBLE1BQU0sNkRBQWEsVUFBVSw4REFBYztBQUMzQztBQUNBOztBQUVBLHlCQUF5Qiw2REFBYTtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz8xNzI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getViewportRect)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getViewportRect(element, strategy) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element),\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUM7QUFDa0I7QUFDRTtBQUNOO0FBQ3RDO0FBQ2YsWUFBWSx5REFBUztBQUNyQixhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBZ0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBbUI7QUFDOUI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzPzljYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindow)\n/* harmony export */ });\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/NjE5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindowScroll)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getWindowScroll(node) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDeEI7QUFDZixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzPzkyNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindowScrollBarX)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).scrollLeft;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0Q7QUFDTjtBQUNOO0FBQ3BDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFxQixDQUFDLGtFQUFrQixrQkFBa0IsK0RBQWU7QUFDbEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzP2UzZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\n\nfunction isElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUM7O0FBRXZDO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5REFBUztBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcz9hOTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isLayoutViewport)\n/* harmony export */ });\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ \"./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc0xheW91dFZpZXdwb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ2pDO0FBQ2YsZ0RBQWdELCtEQUFXO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcz8xMGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isScrollParent)\n/* harmony export */ });\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRDtBQUN0QztBQUNmO0FBQ0EsMEJBQTBCLGdFQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzQ2MDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isTableElement)\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) >= 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQztBQUM1QjtBQUNmLHVDQUF1QywyREFBVztBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzPzU2NDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ listScrollParents)\n/* harmony export */ });\n/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(target)));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNKO0FBQ1I7QUFDVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLCtEQUFlO0FBQ3BDO0FBQ0EsWUFBWSx5REFBUztBQUNyQiwrREFBK0QsOERBQWM7QUFDN0U7QUFDQTtBQUNBLHVDQUF1Qyw2REFBYTtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzP2Q2NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   afterMain: () => (/* binding */ afterMain),\n/* harmony export */   afterRead: () => (/* binding */ afterRead),\n/* harmony export */   afterWrite: () => (/* binding */ afterWrite),\n/* harmony export */   auto: () => (/* binding */ auto),\n/* harmony export */   basePlacements: () => (/* binding */ basePlacements),\n/* harmony export */   beforeMain: () => (/* binding */ beforeMain),\n/* harmony export */   beforeRead: () => (/* binding */ beforeRead),\n/* harmony export */   beforeWrite: () => (/* binding */ beforeWrite),\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   clippingParents: () => (/* binding */ clippingParents),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   main: () => (/* binding */ main),\n/* harmony export */   modifierPhases: () => (/* binding */ modifierPhases),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   popper: () => (/* binding */ popper),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   reference: () => (/* binding */ reference),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   top: () => (/* binding */ top),\n/* harmony export */   variationPlacements: () => (/* binding */ variationPlacements),\n/* harmony export */   viewport: () => (/* binding */ viewport),\n/* harmony export */   write: () => (/* binding */ write)\n/* harmony export */ });\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBLENBQUMsT0FBTzs7QUFFRDtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/MzU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/enums.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Q7QUFDSyxDQUFDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDLFNBQVMsdUVBQWEsY0FBYyxxRUFBVztBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUksR0FBRzs7QUFFZCxXQUFXLHVFQUFhLGNBQWMscUVBQVc7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0YsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/ZjJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/contains.js */ \"./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ \"./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ \"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ \"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(state.placement);\n  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(basePlacement);\n  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(arrowElement);\n  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;\n  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ0Y7QUFDVjtBQUNjO0FBQ2M7QUFDaEM7QUFDb0I7QUFDTjtBQUNhLENBQUM7O0FBRXhFO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsR0FBRztBQUNILFNBQVMsd0VBQWtCLHlDQUF5QyxxRUFBZSxVQUFVLHFEQUFjO0FBQzNHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBZ0I7QUFDdEMsYUFBYSw4RUFBd0I7QUFDckMsb0JBQW9CLDJDQUFJLEVBQUUsNENBQUs7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVFQUFhO0FBQy9CLCtCQUErQiwwQ0FBRyxHQUFHLDJDQUFJO0FBQ3pDLCtCQUErQiw2Q0FBTSxHQUFHLDRDQUFLO0FBQzdDO0FBQ0E7QUFDQSwwQkFBMEIseUVBQWU7QUFDekM7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTSxvQkFBb0I7O0FBRXpDO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxrRUFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzPzdlZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/arrow.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   mapToStyles: () => (/* binding */ mapToStyles)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,\n    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;\n  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper)) {\n      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(popper);\n\n      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {\n      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {\n      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.placement),\n    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDRTtBQUNaO0FBQ2tCO0FBQ0o7QUFDSjtBQUNSO0FBQ1gsQ0FBQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHFEQUFLO0FBQ1osT0FBTyxxREFBSztBQUNaO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFJO0FBQ2xCLGNBQWMsMENBQUc7QUFDakI7O0FBRUE7QUFDQSx1QkFBdUIseUVBQWU7QUFDdEM7QUFDQTs7QUFFQSx5QkFBeUIsbUVBQVM7QUFDbEMscUJBQXFCLDRFQUFrQjs7QUFFdkMsVUFBVSwwRUFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEsc0JBQXNCLDBDQUFHLG1CQUFtQiwyQ0FBSSxrQkFBa0IsNENBQUssbUJBQW1CLDBDQUFHO0FBQzdGLGNBQWMsNkNBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkNBQUksbUJBQW1CLDBDQUFHLGtCQUFrQiw2Q0FBTSxtQkFBbUIsMENBQUc7QUFDOUYsY0FBYyw0Q0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1FQUFTO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsb0NBQW9DO0FBQy9EOztBQUVBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNFQUFnQjtBQUMvQixlQUFlLGtFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsbURBQW1EO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0YsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanM/M2Y5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwgZ2V0V2luZG93KHBvcHBlcikpIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRCxDQUFDOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/OTFjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {\n    return [];\n  }\n\n  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(placement);\n  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n\n    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;\n    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(mainVariationSide);\n    }\n\n    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ1I7QUFDMEI7QUFDOUI7QUFDWTtBQUNBO0FBQ2hCLENBQUM7O0FBRXJEO0FBQ0EsTUFBTSxzRUFBZ0IsZ0JBQWdCLDJDQUFJO0FBQzFDO0FBQ0E7O0FBRUEsMEJBQTBCLDBFQUFvQjtBQUM5QyxVQUFVLG1GQUE2QixnQ0FBZ0MsbUZBQTZCO0FBQ3BHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBZ0I7QUFDdEM7QUFDQSxpR0FBaUcsMEVBQW9CO0FBQ3JIO0FBQ0Esc0JBQXNCLHNFQUFnQixnQkFBZ0IsMkNBQUksR0FBRywwRUFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUEseUJBQXlCLHNFQUFnQjs7QUFFekMsMkJBQTJCLGtFQUFZLGdCQUFnQiw0Q0FBSztBQUM1RCxzQkFBc0IsMENBQUcsRUFBRSw2Q0FBTTtBQUNqQztBQUNBLG1CQUFtQixvRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDREQUE0RCw0Q0FBSyxHQUFHLDJDQUFJLHNCQUFzQiw2Q0FBTSxHQUFHLDBDQUFHOztBQUUxRztBQUNBLDBCQUEwQiwwRUFBb0I7QUFDOUM7O0FBRUEsMkJBQTJCLDBFQUFvQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzPzVjY2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/flip.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDtBQUNDOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsMENBQUcsRUFBRSw0Q0FBSyxFQUFFLDZDQUFNLEVBQUUsMkNBQUk7QUFDbEM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9FQUFjO0FBQ3hDO0FBQ0EsR0FBRztBQUNILDBCQUEwQixvRUFBYztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzPzM2ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/hide.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   arrow: () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   computeStyles: () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   eventListeners: () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   flip: () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   hide: () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   offset: () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   popperOffsets: () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   preventOverflow: () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ \"./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ \"./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ \"./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ \"./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ \"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDWjtBQUNnQjtBQUNFO0FBQ3BCO0FBQ0E7QUFDSTtBQUNjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanM/NGY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5U3R5bGVzIH0gZnJvbSBcIi4vYXBwbHlTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyb3cgfSBmcm9tIFwiLi9hcnJvdy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wdXRlU3R5bGVzIH0gZnJvbSBcIi4vY29tcHV0ZVN0eWxlcy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldmVudExpc3RlbmVycyB9IGZyb20gXCIuL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZsaXAgfSBmcm9tIFwiLi9mbGlwLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhpZGUgfSBmcm9tIFwiLi9oaWRlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9mZnNldCB9IGZyb20gXCIuL29mZnNldC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwb3BwZXJPZmZzZXRzIH0gZnJvbSBcIi4vcG9wcGVyT2Zmc2V0cy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcmV2ZW50T3ZlcmZsb3cgfSBmcm9tIFwiLi9wcmV2ZW50T3ZlcmZsb3cuanNcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/index.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   distanceAndSkiddingToXY: () => (/* binding */ distanceAndSkiddingToXY)\n/* harmony export */ });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RDtBQUNELENBQUM7O0FBRXJEO0FBQ1Asc0JBQXNCLHNFQUFnQjtBQUN0Qyx3QkFBd0IsMkNBQUksRUFBRSwwQ0FBRzs7QUFFakMsbUVBQW1FO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsMkNBQUksRUFBRSw0Q0FBSztBQUNyQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQVU7QUFDdkI7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/ODgyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/offset.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvRUFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz9mZGE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ \"./node_modules/@popperjs/core/lib/utils/getAltAxis.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ \"./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ \"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.placement);\n  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(basePlacement);\n  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;\n    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;\n\n    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ0Y7QUFDZ0I7QUFDNUI7QUFDWTtBQUNGO0FBQ0k7QUFDTjtBQUNKO0FBQ1k7QUFDRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHNFQUFnQjtBQUN0QyxrQkFBa0Isa0VBQVk7QUFDOUI7QUFDQSxpQkFBaUIsOEVBQXdCO0FBQ3pDLGdCQUFnQixnRUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsMENBQUcsR0FBRywyQ0FBSTtBQUNoRCxxQ0FBcUMsNkNBQU0sR0FBRyw0Q0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUFLO0FBQ3BDLCtCQUErQiw0Q0FBSywyQ0FBMkM7QUFDL0U7O0FBRUE7QUFDQSw2Q0FBNkMsdUVBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EseUhBQXlILHdFQUFrQjtBQUMzSTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0RBQU07QUFDekI7QUFDQTtBQUNBLG9EQUFvRCx5RUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBTSxVQUFVLG9EQUFPLHlDQUF5QyxvREFBTztBQUNqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsMENBQUcsR0FBRywyQ0FBSTs7QUFFakQsc0NBQXNDLDZDQUFNLEdBQUcsNENBQUs7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QiwwQ0FBRyxFQUFFLDJDQUFJOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsZ0VBQWMsb0NBQW9DLHdEQUFNOztBQUU1RztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2ZlMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDVDtBQUNGO0FBQ0E7QUFDSjtBQUNyRCx3QkFBd0Isb0VBQWMsRUFBRSxtRUFBYSxFQUFFLG1FQUFhLEVBQUUsaUVBQVc7QUFDakYsZ0NBQWdDLGlFQUFlO0FBQy9DO0FBQ0EsQ0FBQyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcz9mODM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/popper-lite.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),\n/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),\n/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),\n/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),\n/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),\n/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),\n/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),\n/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator),\n/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),\n/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ \"./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ \"./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ \"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ \"./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ \"./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ \"./node_modules/@popperjs/core/lib/popper-lite.js\");\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ \"./node_modules/@popperjs/core/lib/modifiers/index.js\");\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDVDtBQUNGO0FBQ0E7QUFDSjtBQUNWO0FBQ0o7QUFDc0I7QUFDcEI7QUFDRjtBQUN2Qyx3QkFBd0Isb0VBQWMsRUFBRSxtRUFBYSxFQUFFLG1FQUFhLEVBQUUsaUVBQVcsRUFBRSw0REFBTSxFQUFFLDBEQUFJLEVBQUUscUVBQWUsRUFBRSwyREFBSyxFQUFFLDBEQUFJO0FBQzdILGdDQUFnQyxpRUFBZTtBQUMvQztBQUNBLENBQUMsR0FBRzs7QUFFdUUsQ0FBQzs7QUFFUixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/YWY1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/popper.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ computeAutoPlacement)\n/* harmony export */ });\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;\n  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement);\n  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {\n    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) === variation;\n  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZDO0FBQ2tEO0FBQzlDO0FBQ0k7QUFDdEM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaURBQWE7QUFDOUUsa0JBQWtCLDREQUFZO0FBQzlCLGdEQUFnRCwwREFBbUIsR0FBRywwREFBbUI7QUFDekYsV0FBVyw0REFBWTtBQUN2QixHQUFHLElBQUkscURBQWM7QUFDckI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EscUJBQXFCLDhEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLGdFQUFnQjtBQUN2QjtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzP2U5MjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ computeOffsets)\n/* harmony export */ });\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) : null;\n  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBQ1I7QUFDd0I7QUFDRjtBQUNwRDtBQUNmO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBZ0I7QUFDbEQsOEJBQThCLDREQUFZO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsMENBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNkNBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNENBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsMkNBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsd0VBQXdCOztBQUV6RDtBQUNBOztBQUVBO0FBQ0EsV0FBVyw0Q0FBSztBQUNoQjtBQUNBOztBQUVBLFdBQVcsMENBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz9lNTYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ debounce)\n/* harmony export */ });\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzPzI2MjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/debounce.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ detectOverflow)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ \"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ \"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ \"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));\n  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.elements.reference);\n  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDTTtBQUNNO0FBQ3pCO0FBQ0k7QUFDMEQ7QUFDeEQ7QUFDRTtBQUNOLENBQUM7O0FBRXJDO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzREFBZTtBQUMvRDtBQUNBLHdEQUF3RCwrQ0FBUTtBQUNoRTtBQUNBLDBEQUEwRCw2Q0FBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBa0IseUNBQXlDLCtEQUFlLFVBQVUscURBQWM7QUFDeEgsc0NBQXNDLDZDQUFNLEdBQUcsZ0RBQVMsR0FBRyw2Q0FBTTtBQUNqRTtBQUNBO0FBQ0EsMkJBQTJCLHlFQUFlLENBQUMsbUVBQVMsZ0RBQWdELDRFQUFrQjtBQUN0SCw0QkFBNEIsK0VBQXFCO0FBQ2pELHNCQUFzQiw4REFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0VBQWdCLGlCQUFpQjtBQUMxRCw2Q0FBNkMsNkNBQU0sMkNBQTJDO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0MseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNENBQUssRUFBRSw2Q0FBTTtBQUNuQyxrQkFBa0IsMENBQUcsRUFBRSw2Q0FBTTtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz8xNjE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ expandToHashMap)\n/* harmony export */ });\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzlmODAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getAltAxis)\n/* harmony export */ });\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcz8zMmIyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getAltAxis.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getBasePlacement)\n/* harmony export */ });\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFtQztBQUNwQjtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/ZGU5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getFreshSideObject)\n/* harmony export */ });\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzPzdlNjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getMainAxisFromPlacement)\n/* harmony export */ });\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanM/MWUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOppositePlacement)\n/* harmony export */ });\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzP2U1ODQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOppositeVariationPlacement)\n/* harmony export */ });\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanM/M2VlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getVariation)\n/* harmony export */ });\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/NjA5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getVariation.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   round: () => (/* binding */ round)\n/* harmony export */ });\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzPzJhZjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/math.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergeByName)\n/* harmony export */ });\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUksR0FBRzs7QUFFVjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz85NDgwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/mergeByName.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergePaddingObject)\n/* harmony export */ });\n/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ \"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), paddingObject);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RDtBQUMxQztBQUNmLHlCQUF5QixFQUFFLGtFQUFrQjtBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzPzU3NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ orderModifiers)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDLENBQUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWU7QUFDZjtBQUNBLDJDQUEyQzs7QUFFM0MsU0FBUyxxREFBYztBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanM/NGYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rectToClientRect)\n/* harmony export */ });\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2YseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzMyNDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getUAString)\n/* harmony export */ });\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VzZXJBZ2VudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdXNlckFnZW50LmpzPzM4ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/userAgent.js\n");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   within: () => (/* binding */ within),\n/* harmony export */   withinMaxClamp: () => (/* binding */ withinMaxClamp)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\nfunction within(min, value, max) {\n  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDcEQ7QUFDUCxTQUFTLDZDQUFPLE1BQU0sNkNBQU87QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzPzM3YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/within.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _tiptap_vue_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/vue-2 */ \"./node_modules/@tiptap/vue-2/dist/index.js\");\n/* harmony import */ var _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/starter-kit */ \"./node_modules/@tiptap/starter-kit/dist/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  components: {\n    EditorContent: _tiptap_vue_2__WEBPACK_IMPORTED_MODULE_1__.EditorContent\n  },\n  data: function data() {\n    return {\n      editor: null,\n      content: ''\n    };\n  },\n  mounted: function mounted() {\n    this.editor = new _tiptap_vue_2__WEBPACK_IMPORTED_MODULE_1__.Editor({\n      content: '<p>I’m running tiptap with Vue.js. 🎉</p>',\n      extensions: [_tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_0__[\"default\"]]\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.editor.destroy();\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL2Rlc2t0b3AvcGFnZXMvYWRtaW4vQXJ0aWNsZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJiIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFZQTtBQUNBO0FBQ0E7RUFDQUcsVUFBQTtJQUNBRixhQUFBLEVBQUFBLHdEQUFBQTtFQUNBO0VBRUFHLElBQUEsV0FBQUEsS0FBQTtJQUNBO01BQ0FDLE1BQUE7TUFDQUMsT0FBQTtJQUNBO0VBQ0E7RUFFQUMsT0FBQSxXQUFBQSxRQUFBO0lBQ0EsS0FBQUYsTUFBQSxPQUFBTCxpREFBQTtNQUNBTSxPQUFBO01BQ0FFLFVBQUEsR0FDQU4sMkRBQUE7SUFFQTtFQUNBO0VBRUFPLGFBQUEsV0FBQUEsY0FBQTtJQUNBLEtBQUFKLE1BQUEsQ0FBQUssT0FBQTtFQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2pzL2Rlc2t0b3AvcGFnZXMvYWRtaW4vQXJ0aWNsZXMudnVlPzg1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIganVzdGlmeS1jb250ZW50LWNlbnRlciBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyIHByb21vY29kZXNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNiBjb2wtMTJcIj5cbiAgICAgICAgICAgICAgICA8ZWRpdG9yLWNvbnRlbnQgOmVkaXRvcj1cImVkaXRvclwiIHYtbW9kZWw9XCJjb250ZW50XCIvPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblxuICAgIGltcG9ydCB7IEVkaXRvciwgRWRpdG9yQ29udGVudCB9IGZyb20gJ0B0aXB0YXAvdnVlLTInXG4gICAgaW1wb3J0IFN0YXJ0ZXJLaXQgZnJvbSAnQHRpcHRhcC9zdGFydGVyLWtpdCdcbiAgICBleHBvcnQgZGVmYXVsdCB7XG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICAgIEVkaXRvckNvbnRlbnQsXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6JydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSBuZXcgRWRpdG9yKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnPHA+SeKAmW0gcnVubmluZyB0aXB0YXAgd2l0aCBWdWUuanMuIPCfjok8L3A+JyxcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIFN0YXJ0ZXJLaXQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmRlc3Ryb3koKVxuICAgICAgICB9LFxuICAgIH1cbjwvc2NyaXB0PlxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG5cbjwvc3R5bGU+XG4iXSwibmFtZXMiOlsiRWRpdG9yIiwiRWRpdG9yQ29udGVudCIsIlN0YXJ0ZXJLaXQiLCJjb21wb25lbnRzIiwiZGF0YSIsImVkaXRvciIsImNvbnRlbnQiLCJtb3VudGVkIiwiZXh0ZW5zaW9ucyIsImJlZm9yZURlc3Ryb3kiLCJkZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e&":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e& ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   staticRenderFns: () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n    _c = _vm._self._c;\n  return _c(\"div\", {\n    staticClass: \"container justify-content-center d-flex align-items-center promocodes\"\n  }, [_c(\"div\", {\n    staticClass: \"row justify-content-center d-flex align-items-center\"\n  }, [_c(\"div\", {\n    staticClass: \"col-sm-6 col-12\"\n  }, [_c(\"editor-content\", {\n    attrs: {\n      editor: _vm.editor\n    },\n    model: {\n      value: _vm.content,\n      callback: function callback($$v) {\n        _vm.content = $$v;\n      },\n      expression: \"content\"\n    }\n  })], 1)])]);\n};\nvar staticRenderFns = [];\nrender._withStripped = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvZGVza3RvcC9wYWdlcy9hZG1pbi9BcnRpY2xlcy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Y2NkZDdlNGUmIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsTUFBTSxHQUFHLFNBQVNBLE1BQU1BLENBQUEsRUFBRztFQUM3QixJQUFJQyxHQUFHLEdBQUcsSUFBSTtJQUNaQyxFQUFFLEdBQUdELEdBQUcsQ0FBQ0UsS0FBSyxDQUFDRCxFQUFFO0VBQ25CLE9BQU9BLEVBQUUsQ0FDUCxLQUFLLEVBQ0w7SUFDRUUsV0FBVyxFQUNUO0VBQ0osQ0FBQyxFQUNELENBQ0VGLEVBQUUsQ0FDQSxLQUFLLEVBQ0w7SUFBRUUsV0FBVyxFQUFFO0VBQXVELENBQUMsRUFDdkUsQ0FDRUYsRUFBRSxDQUNBLEtBQUssRUFDTDtJQUFFRSxXQUFXLEVBQUU7RUFBa0IsQ0FBQyxFQUNsQyxDQUNFRixFQUFFLENBQUMsZ0JBQWdCLEVBQUU7SUFDbkJHLEtBQUssRUFBRTtNQUFFQyxNQUFNLEVBQUVMLEdBQUcsQ0FBQ0s7SUFBTyxDQUFDO0lBQzdCQyxLQUFLLEVBQUU7TUFDTEMsS0FBSyxFQUFFUCxHQUFHLENBQUNRLE9BQU87TUFDbEJDLFFBQVEsRUFBRSxTQUFBQSxTQUFVQyxHQUFHLEVBQUU7UUFDdkJWLEdBQUcsQ0FBQ1EsT0FBTyxHQUFHRSxHQUFHO01BQ25CLENBQUM7TUFDREMsVUFBVSxFQUFFO0lBQ2Q7RUFDRixDQUFDLENBQUMsQ0FDSCxFQUNELENBQ0YsQ0FBQyxDQUVMLENBQUMsQ0FFTCxDQUFDO0FBQ0gsQ0FBQztBQUNELElBQUlDLGVBQWUsR0FBRyxFQUFFO0FBQ3hCYixNQUFNLENBQUNjLGFBQWEsR0FBRyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2Rlc2t0b3AvcGFnZXMvYWRtaW4vQXJ0aWNsZXMudnVlPzIzYmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgdmFyIF92bSA9IHRoaXMsXG4gICAgX2MgPSBfdm0uX3NlbGYuX2NcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgIFwiY29udGFpbmVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBwcm9tb2NvZGVzXCIsXG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJyb3cganVzdGlmeS1jb250ZW50LWNlbnRlciBkLWZsZXggYWxpZ24taXRlbXMtY2VudGVyXCIgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiY29sLXNtLTYgY29sLTEyXCIgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJlZGl0b3ItY29udGVudFwiLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgZWRpdG9yOiBfdm0uZWRpdG9yIH0sXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uY29udGVudCxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoJCR2KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5jb250ZW50ID0gJCR2XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbInJlbmRlciIsIl92bSIsIl9jIiwiX3NlbGYiLCJzdGF0aWNDbGFzcyIsImF0dHJzIiwiZWRpdG9yIiwibW9kZWwiLCJ2YWx1ZSIsImNvbnRlbnQiLCJjYWxsYmFjayIsIiQkdiIsImV4cHJlc3Npb24iLCJzdGF0aWNSZW5kZXJGbnMiLCJfd2l0aFN0cmlwcGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e&\n");

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateFill: () => (/* binding */ animateFill),\n/* harmony export */   createSingleton: () => (/* binding */ createSingleton),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   delegate: () => (/* binding */ delegate),\n/* harmony export */   followCursor: () => (/* binding */ followCursor),\n/* harmony export */   hideAll: () => (/* binding */ hideAll),\n/* harmony export */   inlinePositioning: () => (/* binding */ inlinePositioning),\n/* harmony export */   roundArrow: () => (/* binding */ ROUND_ARROW),\n/* harmony export */   sticky: () => (/* binding */ sticky)\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/popper.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/\n\n\nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n  passive: true,\n  capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n  return document.body;\n};\n\nfunction hasOwnProperty(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n  if (Array.isArray(value)) {\n    var v = value[index];\n    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n  }\n\n  return value;\n}\nfunction isType(value, type) {\n  var str = {}.toString.call(value);\n  return str.indexOf('[object') === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n  return typeof value === 'function' ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  var timeout;\n  return function (arg) {\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      fn(arg);\n    }, ms);\n  };\n}\nfunction removeProperties(obj, keys) {\n  var clone = Object.assign({}, obj);\n  keys.forEach(function (key) {\n    delete clone[key];\n  });\n  return clone;\n}\nfunction splitBySpaces(value) {\n  return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n  return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\nfunction unique(arr) {\n  return arr.filter(function (item, index) {\n    return arr.indexOf(item) === index;\n  });\n}\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\nfunction arrayFrom(value) {\n  return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (obj[key] !== undefined) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction div() {\n  return document.createElement('div');\n}\nfunction isElement(value) {\n  return ['Element', 'Fragment'].some(function (type) {\n    return isType(value, type);\n  });\n}\nfunction isNodeList(value) {\n  return isType(value, 'NodeList');\n}\nfunction isMouseEvent(value) {\n  return isType(value, 'MouseEvent');\n}\nfunction isReferenceElement(value) {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n  if (isElement(value)) {\n    return [value];\n  }\n\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n  els.forEach(function (el) {\n    if (el) {\n      el.style.transitionDuration = value + \"ms\";\n    }\n  });\n}\nfunction setVisibilityState(els, state) {\n  els.forEach(function (el) {\n    if (el) {\n      el.setAttribute('data-state', state);\n    }\n  });\n}\nfunction getOwnerDocument(elementOrElements) {\n  var _element$ownerDocumen;\n\n  var _normalizeToArray = normalizeToArray(elementOrElements),\n      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n\n\n  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n  var clientX = event.clientX,\n      clientY = event.clientY;\n  return popperTreeData.every(function (_ref) {\n    var popperRect = _ref.popperRect,\n        popperState = _ref.popperState,\n        props = _ref.props;\n    var interactiveBorder = props.interactiveBorder;\n    var basePlacement = getBasePlacement(popperState.placement);\n    var offsetData = popperState.modifiersData.offset;\n\n    if (!offsetData) {\n      return true;\n    }\n\n    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;\n    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;\n    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;\n    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;\n    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n  var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n  // `webkitTransitionEnd`...\n\n  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n    box[method](event, listener);\n  });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */\n\nfunction actualContains(parent, child) {\n  var target = child;\n\n  while (target) {\n    var _target$getRootNode;\n\n    if (parent.contains(target)) {\n      return true;\n    }\n\n    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n  }\n\n  return false;\n}\n\nvar currentInput = {\n  isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\n\nfunction onDocumentTouchStart() {\n  if (currentInput.isTouch) {\n    return;\n  }\n\n  currentInput.isTouch = true;\n\n  if (window.performance) {\n    document.addEventListener('mousemove', onDocumentMouseMove);\n  }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\n\nfunction onDocumentMouseMove() {\n  var now = performance.now();\n\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n    document.removeEventListener('mousemove', onDocumentMouseMove);\n  }\n\n  lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\n\nfunction onWindowBlur() {\n  var activeElement = document.activeElement;\n\n  if (isReferenceElement(activeElement)) {\n    var instance = activeElement._tippy;\n\n    if (activeElement.blur && !instance.state.isVisible) {\n      activeElement.blur();\n    }\n  }\n}\nfunction bindGlobalEventListeners() {\n  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);\n  window.addEventListener('blur', onWindowBlur);\n}\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\nvar isIE11 = isBrowser ? // @ts-ignore\n!!window.msCrypto : false;\n\nfunction createMemoryLeakWarning(method) {\n  var txt = method === 'destroy' ? 'n already-' : ' ';\n  return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", 'indicates a potential memory leak.'].join(' ');\n}\nfunction clean(value) {\n  var spacesAndTabs = /[ \\t]{2,}/g;\n  var lineStartWithSpaces = /^[ \\t]*/gm;\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n}\n\nfunction getDevMessage(message) {\n  return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development-only message. It will be removed in production.\\n  \");\n}\n\nfunction getFormattedMessage(message) {\n  return [getDevMessage(message), // title\n  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message\n  'line-height: 1.5', // footer\n  'color: #a6a095;'];\n} // Assume warnings and errors never have the same message\n\nvar visitedMessages;\n\nif (true) {\n  resetVisitedMessages();\n}\n\nfunction resetVisitedMessages() {\n  visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console;\n\n    visitedMessages.add(message);\n\n    (_console = console).warn.apply(_console, getFormattedMessage(message));\n  }\n}\nfunction errorWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console2;\n\n    visitedMessages.add(message);\n\n    (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n  }\n}\nfunction validateTargets(targets) {\n  var didPassFalsyValue = !targets;\n  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;\n  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));\n  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));\n}\n\nvar pluginProps = {\n  animateFill: false,\n  followCursor: false,\n  inlinePositioning: false,\n  sticky: false\n};\nvar renderProps = {\n  allowHTML: false,\n  animation: 'fade',\n  arrow: true,\n  content: '',\n  inertia: false,\n  maxWidth: 350,\n  role: 'tooltip',\n  theme: '',\n  zIndex: 9999\n};\nvar defaultProps = Object.assign({\n  appendTo: TIPPY_DEFAULT_APPEND_TO,\n  aria: {\n    content: 'auto',\n    expanded: 'auto'\n  },\n  delay: 0,\n  duration: [300, 250],\n  getReferenceClientRect: null,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  moveTransition: '',\n  offset: [0, 10],\n  onAfterUpdate: function onAfterUpdate() {},\n  onBeforeUpdate: function onBeforeUpdate() {},\n  onCreate: function onCreate() {},\n  onDestroy: function onDestroy() {},\n  onHidden: function onHidden() {},\n  onHide: function onHide() {},\n  onMount: function onMount() {},\n  onShow: function onShow() {},\n  onShown: function onShown() {},\n  onTrigger: function onTrigger() {},\n  onUntrigger: function onUntrigger() {},\n  onClickOutside: function onClickOutside() {},\n  placement: 'top',\n  plugins: [],\n  popperOptions: {},\n  render: null,\n  showOnCreate: false,\n  touch: true,\n  trigger: 'mouseenter focus',\n  triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n  /* istanbul ignore else */\n  if (true) {\n    validateProps(partialProps, []);\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (key) {\n    defaultProps[key] = partialProps[key];\n  });\n};\nfunction getExtendedPassedProps(passedProps) {\n  var plugins = passedProps.plugins || [];\n  var pluginProps = plugins.reduce(function (acc, plugin) {\n    var name = plugin.name,\n        defaultValue = plugin.defaultValue;\n\n    if (name) {\n      var _name;\n\n      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n    }\n\n    return acc;\n  }, {});\n  return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n    plugins: plugins\n  }))) : defaultKeys;\n  var props = propKeys.reduce(function (acc, key) {\n    var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || '').trim();\n\n    if (!valueAsString) {\n      return acc;\n    }\n\n    if (key === 'content') {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e) {\n        acc[key] = valueAsString;\n      }\n    }\n\n    return acc;\n  }, {});\n  return props;\n}\nfunction evaluateProps(reference, props) {\n  var out = Object.assign({}, props, {\n    content: invokeWithArgsOrReturn(props.content, [reference])\n  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n  out.aria = Object.assign({}, defaultProps.aria, out.aria);\n  out.aria = {\n    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,\n    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content\n  };\n  return out;\n}\nfunction validateProps(partialProps, plugins) {\n  if (partialProps === void 0) {\n    partialProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (prop) {\n    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n\n    if (didPassUnknownProp) {\n      didPassUnknownProp = plugins.filter(function (plugin) {\n        return plugin.name === prop;\n      }).length === 0;\n    }\n\n    warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", 'a plugin, forgot to pass it in an array as props.plugins.', '\\n\\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));\n  });\n}\n\nvar innerHTML = function innerHTML() {\n  return 'innerHTML';\n};\n\nfunction dangerouslySetInnerHTML(element, html) {\n  element[innerHTML()] = html;\n}\n\nfunction createArrowElement(value) {\n  var arrow = div();\n\n  if (value === true) {\n    arrow.className = ARROW_CLASS;\n  } else {\n    arrow.className = SVG_ARROW_CLASS;\n\n    if (isElement(value)) {\n      arrow.appendChild(value);\n    } else {\n      dangerouslySetInnerHTML(arrow, value);\n    }\n  }\n\n  return arrow;\n}\n\nfunction setContent(content, props) {\n  if (isElement(props.content)) {\n    dangerouslySetInnerHTML(content, '');\n    content.appendChild(props.content);\n  } else if (typeof props.content !== 'function') {\n    if (props.allowHTML) {\n      dangerouslySetInnerHTML(content, props.content);\n    } else {\n      content.textContent = props.content;\n    }\n  }\n}\nfunction getChildren(popper) {\n  var box = popper.firstElementChild;\n  var boxChildren = arrayFrom(box.children);\n  return {\n    box: box,\n    content: boxChildren.find(function (node) {\n      return node.classList.contains(CONTENT_CLASS);\n    }),\n    arrow: boxChildren.find(function (node) {\n      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n    }),\n    backdrop: boxChildren.find(function (node) {\n      return node.classList.contains(BACKDROP_CLASS);\n    })\n  };\n}\nfunction render(instance) {\n  var popper = div();\n  var box = div();\n  box.className = BOX_CLASS;\n  box.setAttribute('data-state', 'hidden');\n  box.setAttribute('tabindex', '-1');\n  var content = div();\n  content.className = CONTENT_CLASS;\n  content.setAttribute('data-state', 'hidden');\n  setContent(content, instance.props);\n  popper.appendChild(box);\n  box.appendChild(content);\n  onUpdate(instance.props, instance.props);\n\n  function onUpdate(prevProps, nextProps) {\n    var _getChildren = getChildren(popper),\n        box = _getChildren.box,\n        content = _getChildren.content,\n        arrow = _getChildren.arrow;\n\n    if (nextProps.theme) {\n      box.setAttribute('data-theme', nextProps.theme);\n    } else {\n      box.removeAttribute('data-theme');\n    }\n\n    if (typeof nextProps.animation === 'string') {\n      box.setAttribute('data-animation', nextProps.animation);\n    } else {\n      box.removeAttribute('data-animation');\n    }\n\n    if (nextProps.inertia) {\n      box.setAttribute('data-inertia', '');\n    } else {\n      box.removeAttribute('data-inertia');\n    }\n\n    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n\n    if (nextProps.role) {\n      box.setAttribute('role', nextProps.role);\n    } else {\n      box.removeAttribute('role');\n    }\n\n    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n      setContent(content, instance.props);\n    }\n\n    if (nextProps.arrow) {\n      if (!arrow) {\n        box.appendChild(createArrowElement(nextProps.arrow));\n      } else if (prevProps.arrow !== nextProps.arrow) {\n        box.removeChild(arrow);\n        box.appendChild(createArrowElement(nextProps.arrow));\n      }\n    } else if (arrow) {\n      box.removeChild(arrow);\n    }\n  }\n\n  return {\n    popper: popper,\n    onUpdate: onUpdate\n  };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\n\nrender.$$tippy = true;\n\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\n\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n  // 🔒 Private members\n  // ===========================================================================\n\n  var showTimeout;\n  var hideTimeout;\n  var scheduleHideAnimationFrame;\n  var isVisibleFromClick = false;\n  var didHideDueToDocumentMouseDown = false;\n  var didTouchMove = false;\n  var ignoreOnFirstUpdate = false;\n  var lastTriggerEvent;\n  var currentTransitionEndListener;\n  var onFirstUpdate;\n  var listeners = [];\n  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n  var currentTarget; // ===========================================================================\n  // 🔑 Public members\n  // ===========================================================================\n\n  var id = idCounter++;\n  var popperInstance = null;\n  var plugins = unique(props.plugins);\n  var state = {\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false\n  };\n  var instance = {\n    // properties\n    id: id,\n    reference: reference,\n    popper: div(),\n    popperInstance: popperInstance,\n    props: props,\n    state: state,\n    plugins: plugins,\n    // methods\n    clearDelayTimeouts: clearDelayTimeouts,\n    setProps: setProps,\n    setContent: setContent,\n    show: show,\n    hide: hide,\n    hideWithInteractivity: hideWithInteractivity,\n    enable: enable,\n    disable: disable,\n    unmount: unmount,\n    destroy: destroy\n  }; // TODO: Investigate why this early return causes a TDZ error in the tests —\n  // it doesn't seem to happen in the browser\n\n  /* istanbul ignore if */\n\n  if (!props.render) {\n    if (true) {\n      errorWhen(true, 'render() function has not been supplied.');\n    }\n\n    return instance;\n  } // ===========================================================================\n  // Initial mutations\n  // ===========================================================================\n\n\n  var _props$render = props.render(instance),\n      popper = _props$render.popper,\n      onUpdate = _props$render.onUpdate;\n\n  popper.setAttribute('data-tippy-root', '');\n  popper.id = \"tippy-\" + instance.id;\n  instance.popper = popper;\n  reference._tippy = instance;\n  popper._tippy = instance;\n  var pluginsHooks = plugins.map(function (plugin) {\n    return plugin.fn(instance);\n  });\n  var hasAriaExpanded = reference.hasAttribute('aria-expanded');\n  addListeners();\n  handleAriaExpandedAttribute();\n  handleStyles();\n  invokeHook('onCreate', [instance]);\n\n  if (props.showOnCreate) {\n    scheduleShow();\n  } // Prevent a tippy with a delay from hiding if the cursor left then returned\n  // before it started hiding\n\n\n  popper.addEventListener('mouseenter', function () {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n  popper.addEventListener('mouseleave', function () {\n    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {\n      getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    }\n  });\n  return instance; // ===========================================================================\n  // 🔒 Private methods\n  // ===========================================================================\n\n  function getNormalizedTouchSettings() {\n    var touch = instance.props.touch;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n\n  function getIsCustomTouchBehavior() {\n    return getNormalizedTouchSettings()[0] === 'hold';\n  }\n\n  function getIsDefaultRenderFn() {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n  }\n\n  function getCurrentTarget() {\n    return currentTarget || reference;\n  }\n\n  function getDocument() {\n    var parent = getCurrentTarget().parentNode;\n    return parent ? getOwnerDocument(parent) : document;\n  }\n\n  function getDefaultTemplateChildren() {\n    return getChildren(popper);\n  }\n\n  function getDelay(isShow) {\n    // For touch or keyboard input, force `0` delay for UX reasons\n    // Also if the instance is mounted but not visible (transitioning out),\n    // ignore delay\n    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {\n      return 0;\n    }\n\n    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n  }\n\n  function handleStyles(fromHide) {\n    if (fromHide === void 0) {\n      fromHide = false;\n    }\n\n    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';\n    popper.style.zIndex = \"\" + instance.props.zIndex;\n  }\n\n  function invokeHook(hook, args, shouldInvokePropsHook) {\n    if (shouldInvokePropsHook === void 0) {\n      shouldInvokePropsHook = true;\n    }\n\n    pluginsHooks.forEach(function (pluginHooks) {\n      if (pluginHooks[hook]) {\n        pluginHooks[hook].apply(pluginHooks, args);\n      }\n    });\n\n    if (shouldInvokePropsHook) {\n      var _instance$props;\n\n      (_instance$props = instance.props)[hook].apply(_instance$props, args);\n    }\n  }\n\n  function handleAriaContentAttribute() {\n    var aria = instance.props.aria;\n\n    if (!aria.content) {\n      return;\n    }\n\n    var attr = \"aria-\" + aria.content;\n    var id = popper.id;\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      var currentValue = node.getAttribute(attr);\n\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n      } else {\n        var nextValue = currentValue && currentValue.replace(id, '').trim();\n\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n\n  function handleAriaExpandedAttribute() {\n    if (hasAriaExpanded || !instance.props.aria.expanded) {\n      return;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      if (instance.props.interactive) {\n        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');\n      } else {\n        node.removeAttribute('aria-expanded');\n      }\n    });\n  }\n\n  function cleanupInteractiveMouseListeners() {\n    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {\n      return listener !== debouncedOnMouseMove;\n    });\n  }\n\n  function onDocumentPress(event) {\n    // Moved finger to scroll instead of an intentional tap outside\n    if (currentInput.isTouch) {\n      if (didTouchMove || event.type === 'mousedown') {\n        return;\n      }\n    }\n\n    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n\n    if (instance.props.interactive && actualContains(popper, actualTarget)) {\n      return;\n    } // Clicked on the event listeners target\n\n\n    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {\n      return actualContains(el, actualTarget);\n    })) {\n      if (currentInput.isTouch) {\n        return;\n      }\n\n      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {\n        return;\n      }\n    } else {\n      invokeHook('onClickOutside', [instance, event]);\n    }\n\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n      // currentTarget. This lets a tippy with `focus` trigger know that it\n      // should not show\n\n      didHideDueToDocumentMouseDown = true;\n      setTimeout(function () {\n        didHideDueToDocumentMouseDown = false;\n      }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n      // before it shows, and hide()'s early bail-out behavior can prevent it\n      // from being cleaned up\n\n      if (!instance.state.isMounted) {\n        removeDocumentPress();\n      }\n    }\n  }\n\n  function onTouchMove() {\n    didTouchMove = true;\n  }\n\n  function onTouchStart() {\n    didTouchMove = false;\n  }\n\n  function addDocumentPress() {\n    var doc = getDocument();\n    doc.addEventListener('mousedown', onDocumentPress, true);\n    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function removeDocumentPress() {\n    var doc = getDocument();\n    doc.removeEventListener('mousedown', onDocumentPress, true);\n    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function onTransitionedOut(duration, callback) {\n    onTransitionEnd(duration, function () {\n      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n        callback();\n      }\n    });\n  }\n\n  function onTransitionedIn(duration, callback) {\n    onTransitionEnd(duration, callback);\n  }\n\n  function onTransitionEnd(duration, callback) {\n    var box = getDefaultTemplateChildren().box;\n\n    function listener(event) {\n      if (event.target === box) {\n        updateTransitionEndListener(box, 'remove', listener);\n        callback();\n      }\n    } // Make callback synchronous if duration is 0\n    // `transitionend` won't fire otherwise\n\n\n    if (duration === 0) {\n      return callback();\n    }\n\n    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);\n    updateTransitionEndListener(box, 'add', listener);\n    currentTransitionEndListener = listener;\n  }\n\n  function on(eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({\n        node: node,\n        eventType: eventType,\n        handler: handler,\n        options: options\n      });\n    });\n  }\n\n  function addListeners() {\n    if (getIsCustomTouchBehavior()) {\n      on('touchstart', onTrigger, {\n        passive: true\n      });\n      on('touchend', onMouseLeave, {\n        passive: true\n      });\n    }\n\n    splitBySpaces(instance.props.trigger).forEach(function (eventType) {\n      if (eventType === 'manual') {\n        return;\n      }\n\n      on(eventType, onTrigger);\n\n      switch (eventType) {\n        case 'mouseenter':\n          on('mouseleave', onMouseLeave);\n          break;\n\n        case 'focus':\n          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);\n          break;\n\n        case 'focusin':\n          on('focusout', onBlurOrFocusOut);\n          break;\n      }\n    });\n  }\n\n  function removeListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function onTrigger(event) {\n    var _lastTriggerEvent;\n\n    var shouldScheduleClickHide = false;\n\n    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n      return;\n    }\n\n    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget;\n    handleAriaExpandedAttribute();\n\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      // If scrolling, `mouseenter` events can be fired if the cursor lands\n      // over a new target, but `mousemove` events don't get fired. This\n      // causes interactive tooltips to get stuck open until the cursor is\n      // moved\n      mouseMoveListeners.forEach(function (listener) {\n        return listener(event);\n      });\n    } // Toggle show/hide when clicking click-triggered tooltips\n\n\n    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n      shouldScheduleClickHide = true;\n    } else {\n      scheduleShow(event);\n    }\n\n    if (event.type === 'click') {\n      isVisibleFromClick = !shouldScheduleClickHide;\n    }\n\n    if (shouldScheduleClickHide && !wasFocused) {\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseMove(event) {\n    var target = event.target;\n    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n\n    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {\n      return;\n    }\n\n    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {\n      var _instance$popperInsta;\n\n      var instance = popper._tippy;\n      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n\n      if (state) {\n        return {\n          popperRect: popper.getBoundingClientRect(),\n          popperState: state,\n          props: props\n        };\n      }\n\n      return null;\n    }).filter(Boolean);\n\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseLeave(event) {\n    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;\n\n    if (shouldBail) {\n      return;\n    }\n\n    if (instance.props.interactive) {\n      instance.hideWithInteractivity(event);\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function onBlurOrFocusOut(event) {\n    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {\n      return;\n    } // If focus was moved to within the popper\n\n\n    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function isEventListenerStopped(event) {\n    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;\n  }\n\n  function createPopperInstance() {\n    destroyPopperInstance();\n    var _instance$props2 = instance.props,\n        popperOptions = _instance$props2.popperOptions,\n        placement = _instance$props2.placement,\n        offset = _instance$props2.offset,\n        getReferenceClientRect = _instance$props2.getReferenceClientRect,\n        moveTransition = _instance$props2.moveTransition;\n    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n    var computedReference = getReferenceClientRect ? {\n      getBoundingClientRect: getReferenceClientRect,\n      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n    } : reference;\n    var tippyModifier = {\n      name: '$$tippy',\n      enabled: true,\n      phase: 'beforeWrite',\n      requires: ['computeStyles'],\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (getIsDefaultRenderFn()) {\n          var _getDefaultTemplateCh = getDefaultTemplateChildren(),\n              box = _getDefaultTemplateCh.box;\n\n          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {\n            if (attr === 'placement') {\n              box.setAttribute('data-placement', state.placement);\n            } else {\n              if (state.attributes.popper[\"data-popper-\" + attr]) {\n                box.setAttribute(\"data-\" + attr, '');\n              } else {\n                box.removeAttribute(\"data-\" + attr);\n              }\n            }\n          });\n          state.attributes.popper = {};\n        }\n      }\n    };\n    var modifiers = [{\n      name: 'offset',\n      options: {\n        offset: offset\n      }\n    }, {\n      name: 'preventOverflow',\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5\n        }\n      }\n    }, {\n      name: 'flip',\n      options: {\n        padding: 5\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: !moveTransition\n      }\n    }, tippyModifier];\n\n    if (getIsDefaultRenderFn() && arrow) {\n      modifiers.push({\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 3\n        }\n      });\n    }\n\n    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n    instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {\n      placement: placement,\n      onFirstUpdate: onFirstUpdate,\n      modifiers: modifiers\n    }));\n  }\n\n  function destroyPopperInstance() {\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n      instance.popperInstance = null;\n    }\n  }\n\n  function mount() {\n    var appendTo = instance.props.appendTo;\n    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n    // it's directly after the reference element so the elements inside the\n    // tippy can be tabbed to\n    // If there are clipping issues, the user can specify a different appendTo\n    // and ensure focus management is handled correctly manually\n\n    var node = getCurrentTarget();\n\n    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    } // The popper element needs to exist on the DOM before its position can be\n    // updated as Popper needs to read its dimensions\n\n\n    if (!parentNode.contains(popper)) {\n      parentNode.appendChild(popper);\n    }\n\n    instance.state.isMounted = true;\n    createPopperInstance();\n    /* istanbul ignore else */\n\n    if (true) {\n      // Accessibility check\n      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\\n\\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\\n\\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\\n\\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));\n    }\n  }\n\n  function getNestedPopperTree() {\n    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));\n  }\n\n  function scheduleShow(event) {\n    instance.clearDelayTimeouts();\n\n    if (event) {\n      invokeHook('onTrigger', [instance, event]);\n    }\n\n    addDocumentPress();\n    var delay = getDelay(true);\n\n    var _getNormalizedTouchSe = getNormalizedTouchSettings(),\n        touchValue = _getNormalizedTouchSe[0],\n        touchDelay = _getNormalizedTouchSe[1];\n\n    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {\n      delay = touchDelay;\n    }\n\n    if (delay) {\n      showTimeout = setTimeout(function () {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n\n  function scheduleHide(event) {\n    instance.clearDelayTimeouts();\n    invokeHook('onUntrigger', [instance, event]);\n\n    if (!instance.state.isVisible) {\n      removeDocumentPress();\n      return;\n    } // For interactive tippies, scheduleHide is added to a document.body handler\n    // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n    // events when trigger contains mouseenter and click, and the tip is\n    // currently shown as a result of a click.\n\n\n    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {\n      return;\n    }\n\n    var delay = getDelay(false);\n\n    if (delay) {\n      hideTimeout = setTimeout(function () {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      // Fixes a `transitionend` problem when it fires 1 frame too\n      // late sometimes, we don't want hide() to be called.\n      scheduleHideAnimationFrame = requestAnimationFrame(function () {\n        instance.hide();\n      });\n    }\n  } // ===========================================================================\n  // 🔑 Public methods\n  // ===========================================================================\n\n\n  function enable() {\n    instance.state.isEnabled = true;\n  }\n\n  function disable() {\n    // Disabling the instance should also hide it\n    // https://github.com/atomiks/tippy.js-react/issues/106\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n\n  function clearDelayTimeouts() {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n\n  function setProps(partialProps) {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    invokeHook('onBeforeUpdate', [instance, partialProps]);\n    removeListeners();\n    var prevProps = instance.props;\n    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n      ignoreAttributes: true\n    }));\n    instance.props = nextProps;\n    addListeners();\n\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n    } // Ensure stale aria-expanded attributes are removed\n\n\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {\n        node.removeAttribute('aria-expanded');\n      });\n    } else if (nextProps.triggerTarget) {\n      reference.removeAttribute('aria-expanded');\n    }\n\n    handleAriaExpandedAttribute();\n    handleStyles();\n\n    if (onUpdate) {\n      onUpdate(prevProps, nextProps);\n    }\n\n    if (instance.popperInstance) {\n      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n      // and the nested ones get re-rendered first.\n      // https://github.com/atomiks/tippyjs-react/issues/177\n      // TODO: find a cleaner / more efficient solution(!)\n\n      getNestedPopperTree().forEach(function (nestedPopper) {\n        // React (and other UI libs likely) requires a rAF wrapper as it flushes\n        // its work in one\n        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n      });\n    }\n\n    invokeHook('onAfterUpdate', [instance, partialProps]);\n  }\n\n  function setContent(content) {\n    instance.setProps({\n      content: content\n    });\n  }\n\n  function show() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));\n    } // Early bail-out\n\n\n    var isAlreadyVisible = instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n\n    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n      return;\n    } // Normalize `disabled` behavior across browsers.\n    // Firefox allows events on disabled elements, but Chrome doesn't.\n    // Using a wrapper element (i.e. <span>) is recommended.\n\n\n    if (getCurrentTarget().hasAttribute('disabled')) {\n      return;\n    }\n\n    invokeHook('onShow', [instance], false);\n\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = true;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'visible';\n    }\n\n    handleStyles();\n    addDocumentPress();\n\n    if (!instance.state.isMounted) {\n      popper.style.transition = 'none';\n    } // If flipping to the opposite side after hiding at least once, the\n    // animation will use the wrong placement without resetting the duration\n\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh2.box,\n          content = _getDefaultTemplateCh2.content;\n\n      setTransitionDuration([box, content], 0);\n    }\n\n    onFirstUpdate = function onFirstUpdate() {\n      var _instance$popperInsta2;\n\n      if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n        return;\n      }\n\n      ignoreOnFirstUpdate = true; // reflow\n\n      void popper.offsetHeight;\n      popper.style.transition = instance.props.moveTransition;\n\n      if (getIsDefaultRenderFn() && instance.props.animation) {\n        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),\n            _box = _getDefaultTemplateCh3.box,\n            _content = _getDefaultTemplateCh3.content;\n\n        setTransitionDuration([_box, _content], duration);\n        setVisibilityState([_box, _content], 'visible');\n      }\n\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n      // popper has been positioned for the first time\n\n      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n      invokeHook('onMount', [instance]);\n\n      if (instance.props.animation && getIsDefaultRenderFn()) {\n        onTransitionedIn(duration, function () {\n          instance.state.isShown = true;\n          invokeHook('onShown', [instance]);\n        });\n      }\n    };\n\n    mount();\n  }\n\n  function hide() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));\n    } // Early bail-out\n\n\n    var isAlreadyHidden = !instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n\n    invokeHook('onHide', [instance], false);\n\n    if (instance.props.onHide(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n    ignoreOnFirstUpdate = false;\n    isVisibleFromClick = false;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'hidden';\n    }\n\n    cleanupInteractiveMouseListeners();\n    removeDocumentPress();\n    handleStyles(true);\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh4.box,\n          content = _getDefaultTemplateCh4.content;\n\n      if (instance.props.animation) {\n        setTransitionDuration([box, content], duration);\n        setVisibilityState([box, content], 'hidden');\n      }\n    }\n\n    handleAriaContentAttribute();\n    handleAriaExpandedAttribute();\n\n    if (instance.props.animation) {\n      if (getIsDefaultRenderFn()) {\n        onTransitionedOut(duration, instance.unmount);\n      }\n    } else {\n      instance.unmount();\n    }\n  }\n\n  function hideWithInteractivity(event) {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));\n    }\n\n    getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n    debouncedOnMouseMove(event);\n  }\n\n  function unmount() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));\n    }\n\n    if (instance.state.isVisible) {\n      instance.hide();\n    }\n\n    if (!instance.state.isMounted) {\n      return;\n    }\n\n    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n    // tree by default. This seems mainly for interactive tippies, but we should\n    // find a workaround if possible\n\n    getNestedPopperTree().forEach(function (nestedPopper) {\n      nestedPopper._tippy.unmount();\n    });\n\n    if (popper.parentNode) {\n      popper.parentNode.removeChild(popper);\n    }\n\n    mountedInstances = mountedInstances.filter(function (i) {\n      return i !== instance;\n    });\n    instance.state.isMounted = false;\n    invokeHook('onHidden', [instance]);\n  }\n\n  function destroy() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    instance.clearDelayTimeouts();\n    instance.unmount();\n    removeListeners();\n    delete reference._tippy;\n    instance.state.isDestroyed = true;\n    invokeHook('onDestroy', [instance]);\n  }\n}\n\nfunction tippy(targets, optionalProps) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n  /* istanbul ignore else */\n\n  if (true) {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n\n  bindGlobalEventListeners();\n  var passedProps = Object.assign({}, optionalProps, {\n    plugins: plugins\n  });\n  var elements = getArrayOfElements(targets);\n  /* istanbul ignore else */\n\n  if (true) {\n    var isSingleContentElement = isElement(passedProps.content);\n    var isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\\n\\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\\n\\n', '1) content: element.innerHTML\\n', '2) content: () => element.cloneNode(true)'].join(' '));\n  }\n\n  var instances = elements.reduce(function (acc, reference) {\n    var instance = reference && createTippy(reference, passedProps);\n\n    if (instance) {\n      acc.push(instance);\n    }\n\n    return acc;\n  }, []);\n  return isElement(targets) ? instances[0] : instances;\n}\n\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      excludedReferenceOrInstance = _ref.exclude,\n      duration = _ref.duration;\n\n  mountedInstances.forEach(function (instance) {\n    var isExcluded = false;\n\n    if (excludedReferenceOrInstance) {\n      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n    }\n\n    if (!isExcluded) {\n      var originalDuration = instance.props.duration;\n      instance.setProps({\n        duration: duration\n      });\n      instance.hide();\n\n      if (!instance.state.isDestroyed) {\n        instance.setProps({\n          duration: originalDuration\n        });\n      }\n    }\n  });\n};\n\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\n\nvar applyStylesModifier = Object.assign({}, _popperjs_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n  effect: function effect(_ref) {\n    var state = _ref.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    } // intentionally return no cleanup function\n    // return () => { ... }\n\n  }\n});\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n  var _optionalProps$popper;\n\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  /* istanbul ignore else */\n  if (true) {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  var individualInstances = tippyInstances;\n  var references = [];\n  var triggerTargets = [];\n  var currentTarget;\n  var overrides = optionalProps.overrides;\n  var interceptSetPropsCleanups = [];\n  var shownOnCreate = false;\n\n  function setTriggerTargets() {\n    triggerTargets = individualInstances.map(function (instance) {\n      return normalizeToArray(instance.props.triggerTarget || instance.reference);\n    }).reduce(function (acc, item) {\n      return acc.concat(item);\n    }, []);\n  }\n\n  function setReferences() {\n    references = individualInstances.map(function (instance) {\n      return instance.reference;\n    });\n  }\n\n  function enableInstances(isEnabled) {\n    individualInstances.forEach(function (instance) {\n      if (isEnabled) {\n        instance.enable();\n      } else {\n        instance.disable();\n      }\n    });\n  }\n\n  function interceptSetProps(singleton) {\n    return individualInstances.map(function (instance) {\n      var originalSetProps = instance.setProps;\n\n      instance.setProps = function (props) {\n        originalSetProps(props);\n\n        if (instance.reference === currentTarget) {\n          singleton.setProps(props);\n        }\n      };\n\n      return function () {\n        instance.setProps = originalSetProps;\n      };\n    });\n  } // have to pass singleton, as it maybe undefined on first call\n\n\n  function prepareInstance(singleton, target) {\n    var index = triggerTargets.indexOf(target); // bail-out\n\n    if (target === currentTarget) {\n      return;\n    }\n\n    currentTarget = target;\n    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {\n      acc[prop] = individualInstances[index].props[prop];\n      return acc;\n    }, {});\n    singleton.setProps(Object.assign({}, overrideProps, {\n      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {\n        var _references$index;\n\n        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n      }\n    }));\n  }\n\n  enableInstances(false);\n  setReferences();\n  setTriggerTargets();\n  var plugin = {\n    fn: function fn() {\n      return {\n        onDestroy: function onDestroy() {\n          enableInstances(true);\n        },\n        onHidden: function onHidden() {\n          currentTarget = null;\n        },\n        onClickOutside: function onClickOutside(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            currentTarget = null;\n          }\n        },\n        onShow: function onShow(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            prepareInstance(instance, references[0]);\n          }\n        },\n        onTrigger: function onTrigger(instance, event) {\n          prepareInstance(instance, event.currentTarget);\n        }\n      };\n    }\n  };\n  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {\n    plugins: [plugin].concat(optionalProps.plugins || []),\n    triggerTarget: triggerTargets,\n    popperOptions: Object.assign({}, optionalProps.popperOptions, {\n      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])\n    })\n  }));\n  var originalShow = singleton.show;\n\n  singleton.show = function (target) {\n    originalShow(); // first time, showOnCreate or programmatic call with no params\n    // default to showing first instance\n\n    if (!currentTarget && target == null) {\n      return prepareInstance(singleton, references[0]);\n    } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n    // programmatic call with no params when already visible (do nothing again)\n\n\n    if (currentTarget && target == null) {\n      return;\n    } // target is index of instance\n\n\n    if (typeof target === 'number') {\n      return references[target] && prepareInstance(singleton, references[target]);\n    } // target is a child tippy instance\n\n\n    if (individualInstances.indexOf(target) >= 0) {\n      var ref = target.reference;\n      return prepareInstance(singleton, ref);\n    } // target is a ReferenceElement\n\n\n    if (references.indexOf(target) >= 0) {\n      return prepareInstance(singleton, target);\n    }\n  };\n\n  singleton.showNext = function () {\n    var first = references[0];\n\n    if (!currentTarget) {\n      return singleton.show(0);\n    }\n\n    var index = references.indexOf(currentTarget);\n    singleton.show(references[index + 1] || first);\n  };\n\n  singleton.showPrevious = function () {\n    var last = references[references.length - 1];\n\n    if (!currentTarget) {\n      return singleton.show(last);\n    }\n\n    var index = references.indexOf(currentTarget);\n    var target = references[index - 1] || last;\n    singleton.show(target);\n  };\n\n  var originalSetProps = singleton.setProps;\n\n  singleton.setProps = function (props) {\n    overrides = props.overrides || overrides;\n    originalSetProps(props);\n  };\n\n  singleton.setInstances = function (nextInstances) {\n    enableInstances(true);\n    interceptSetPropsCleanups.forEach(function (fn) {\n      return fn();\n    });\n    individualInstances = nextInstances;\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    singleton.setProps({\n      triggerTarget: triggerTargets\n    });\n  };\n\n  interceptSetPropsCleanups = interceptSetProps(singleton);\n  return singleton;\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props) {\n  /* istanbul ignore else */\n  if (true) {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  var listeners = [];\n  var childTippyInstances = [];\n  var disabled = false;\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n  var parentProps = Object.assign({}, nativeProps, {\n    trigger: 'manual',\n    touch: false\n  });\n  var childProps = Object.assign({\n    touch: defaultProps.touch\n  }, nativeProps, {\n    showOnCreate: true\n  });\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target || disabled) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore\n\n    if (targetNode._tippy) {\n      return;\n    }\n\n    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {\n      return;\n    }\n\n    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n    var originalEnable = instance.enable;\n    var originalDisable = instance.disable;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    instance.enable = function () {\n      originalEnable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.enable();\n      });\n      disabled = false;\n    };\n\n    instance.disable = function () {\n      originalDisable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.disable();\n      });\n      disabled = true;\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n      if (true) {\n        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');\n      }\n\n      return {};\n    }\n\n    var _getChildren = getChildren(instance.popper),\n        box = _getChildren.box,\n        content = _getChildren.content;\n\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          box.insertBefore(backdrop, box.firstElementChild);\n          box.setAttribute('data-animatefill', '');\n          box.style.overflow = 'hidden';\n          instance.setProps({\n            arrow: false,\n            animation: 'shift-away'\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = box.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar mouseCoords = {\n  clientX: 0,\n  clientY: 0\n};\nvar activeInstances = [];\n\nfunction storeMouseCoords(_ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  mouseCoords = {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction addMouseCoordsListener(doc) {\n  doc.addEventListener('mousemove', storeMouseCoords);\n}\n\nfunction removeMouseCoordsListener(doc) {\n  doc.removeEventListener('mousemove', storeMouseCoords);\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n    var isInternalUpdate = false;\n    var wasFocusEvent = false;\n    var isUnmounted = true;\n    var prevProps = instance.props;\n\n    function getIsInitialBehavior() {\n      return instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function unsetGetReferenceClientRect() {\n      isInternalUpdate = true;\n      instance.setProps({\n        getReferenceClientRect: null\n      });\n      isInternalUpdate = false;\n    }\n\n    function onMouseMove(event) {\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n      var followCursor = instance.props.followCursor;\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var rect = reference.getBoundingClientRect();\n      var relativeX = clientX - rect.left;\n      var relativeY = clientY - rect.top;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.setProps({\n          // @ts-ignore - unneeded DOMRect properties\n          getReferenceClientRect: function getReferenceClientRect() {\n            var rect = reference.getBoundingClientRect();\n            var x = clientX;\n            var y = clientY;\n\n            if (followCursor === 'initial') {\n              x = rect.left + relativeX;\n              y = rect.top + relativeY;\n            }\n\n            var top = followCursor === 'horizontal' ? rect.top : y;\n            var right = followCursor === 'vertical' ? rect.right : x;\n            var bottom = followCursor === 'horizontal' ? rect.bottom : y;\n            var left = followCursor === 'vertical' ? rect.left : x;\n            return {\n              width: right - left,\n              height: bottom - top,\n              top: top,\n              right: right,\n              bottom: bottom,\n              left: left\n            };\n          }\n        });\n      }\n    }\n\n    function create() {\n      if (instance.props.followCursor) {\n        activeInstances.push({\n          instance: instance,\n          doc: doc\n        });\n        addMouseCoordsListener(doc);\n      }\n    }\n\n    function destroy() {\n      activeInstances = activeInstances.filter(function (data) {\n        return data.instance !== instance;\n      });\n\n      if (activeInstances.filter(function (data) {\n        return data.doc === doc;\n      }).length === 0) {\n        removeMouseCoordsListener(doc);\n      }\n    }\n\n    return {\n      onCreate: create,\n      onDestroy: destroy,\n      onBeforeUpdate: function onBeforeUpdate() {\n        prevProps = instance.props;\n      },\n      onAfterUpdate: function onAfterUpdate(_, _ref2) {\n        var followCursor = _ref2.followCursor;\n\n        if (isInternalUpdate) {\n          return;\n        }\n\n        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n          destroy();\n\n          if (followCursor) {\n            create();\n\n            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n              addListener();\n            }\n          } else {\n            removeListener();\n            unsetGetReferenceClientRect();\n          }\n        }\n      },\n      onMount: function onMount() {\n        if (instance.props.followCursor && !wasFocusEvent) {\n          if (isUnmounted) {\n            onMouseMove(mouseCoords);\n            isUnmounted = false;\n          }\n\n          if (!getIsInitialBehavior()) {\n            addListener();\n          }\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n\n        wasFocusEvent = event.type === 'focus';\n      },\n      onHidden: function onHidden() {\n        if (instance.props.followCursor) {\n          unsetGetReferenceClientRect();\n          removeListener();\n          isUnmounted = true;\n        }\n      }\n    };\n  }\n};\n\nfunction getProps(props, modifier) {\n  var _props$popperOptions;\n\n  return {\n    popperOptions: Object.assign({}, props.popperOptions, {\n      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {\n        var name = _ref.name;\n        return name !== modifier.name;\n      }), [modifier])\n    })\n  };\n}\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function isEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    var placement;\n    var cursorRectIndex = -1;\n    var isInternalUpdate = false;\n    var triedPlacements = [];\n    var modifier = {\n      name: 'tippyInlinePositioning',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (isEnabled()) {\n          if (triedPlacements.indexOf(state.placement) !== -1) {\n            triedPlacements = [];\n          }\n\n          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n            triedPlacements.push(state.placement);\n            instance.setProps({\n              // @ts-ignore - unneeded DOMRect properties\n              getReferenceClientRect: function getReferenceClientRect() {\n                return _getReferenceClientRect(state.placement);\n              }\n            });\n          }\n\n          placement = state.placement;\n        }\n      }\n    };\n\n    function _getReferenceClientRect(placement) {\n      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n    }\n\n    function setInternalProps(partialProps) {\n      isInternalUpdate = true;\n      instance.setProps(partialProps);\n      isInternalUpdate = false;\n    }\n\n    function addModifier() {\n      if (!isInternalUpdate) {\n        setInternalProps(getProps(instance.props, modifier));\n      }\n    }\n\n    return {\n      onCreate: addModifier,\n      onAfterUpdate: addModifier,\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          var rects = arrayFrom(instance.reference.getClientRects());\n          var cursorRect = rects.find(function (rect) {\n            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n          });\n          var index = rects.indexOf(cursorRect);\n          cursorRectIndex = index > -1 ? index : cursorRectIndex;\n        }\n      },\n      onHidden: function onHidden() {\n        cursorRectIndex = -1;\n      }\n    };\n  }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  } // There are two rects and they are disjoined\n\n\n  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n    return clientRects[cursorRectIndex] || boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        if (instance.popperInstance) {\n          instance.popperInstance.update();\n        }\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\ntippy.setDefaultProps({\n  render: render\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tippy);\n\n//# sourceMappingURL=tippy.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQixrQkFBa0I7QUFDdkQ7QUFDQSxrQkFBa0I7QUFDbEIsRUFBRTs7QUFFRjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1AseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUcsOEJBQThCO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdFQUF3RTtBQUMxRTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLHVEQUF1RCw2RUFBNkU7QUFDcEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBc0Y7O0FBRXRGO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsOEJBQThCLDREQUFZLDRDQUE0QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsRUFBRSxzREFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0I7O0FBRXRCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxLQUFLLEVBQUM7QUFDMEc7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5lc20uanM/MWNiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4qIHRpcHB5LmpzIHY2LjMuN1xuKiAoYykgMjAxNy0yMDIxIGF0b21pa3NcbiogTUlUIExpY2Vuc2VcbiovXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIsIGFwcGx5U3R5bGVzIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuXG52YXIgUk9VTkRfQVJST1cgPSAnPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgNnMxLjc5Ni0uMDEzIDQuNjctMy42MTVDNS44NTEuOSA2LjkzLjAwNiA4IDBjMS4wNy0uMDA2IDIuMTQ4Ljg4NyAzLjM0MyAyLjM4NUMxNC4yMzMgNi4wMDUgMTYgNiAxNiA2SDB6XCI+PC9zdmc+JztcbnZhciBCT1hfQ0xBU1MgPSBcInRpcHB5LWJveFwiO1xudmFyIENPTlRFTlRfQ0xBU1MgPSBcInRpcHB5LWNvbnRlbnRcIjtcbnZhciBCQUNLRFJPUF9DTEFTUyA9IFwidGlwcHktYmFja2Ryb3BcIjtcbnZhciBBUlJPV19DTEFTUyA9IFwidGlwcHktYXJyb3dcIjtcbnZhciBTVkdfQVJST1dfQ0xBU1MgPSBcInRpcHB5LXN2Zy1hcnJvd1wiO1xudmFyIFRPVUNIX09QVElPTlMgPSB7XG4gIHBhc3NpdmU6IHRydWUsXG4gIGNhcHR1cmU6IHRydWVcbn07XG52YXIgVElQUFlfREVGQVVMVF9BUFBFTkRfVE8gPSBmdW5jdGlvbiBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgdiA9IHZhbHVlW2luZGV4XTtcbiAgICByZXR1cm4gdiA9PSBudWxsID8gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlW2luZGV4XSA6IGRlZmF1bHRWYWx1ZSA6IHY7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1R5cGUodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoJ1tvYmplY3QnKSA9PT0gMCAmJiBzdHIuaW5kZXhPZih0eXBlICsgXCJdXCIpID4gLTE7XG59XG5mdW5jdGlvbiBpbnZva2VXaXRoQXJnc09yUmV0dXJuKHZhbHVlLCBhcmdzKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgbXMpIHtcbiAgLy8gQXZvaWQgd3JhcHBpbmcgaW4gYHNldFRpbWVvdXRgIGlmIG1zIGlzIDAgYW55d2F5XG4gIGlmIChtcyA9PT0gMCkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmbihhcmcpO1xuICAgIH0sIG1zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXMob2JqLCBrZXlzKSB7XG4gIHZhciBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIGNsb25lW2tleV07XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3BhY2VzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwdXNoSWZVbmlxdWUoYXJyLCB2YWx1ZSkge1xuICBpZiAoYXJyLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cbmZ1bmN0aW9uIGFycmF5RnJvbSh2YWx1ZSkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2Nba2V5XSA9IG9ialtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZGl2KCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIFsnRWxlbWVudCcsICdGcmFnbWVudCddLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gaXNUeXBlKHZhbHVlLCB0eXBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOb2RlTGlzdCcpO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdNb3VzZUV2ZW50Jyk7XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZUVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl90aXBweSAmJiB2YWx1ZS5fdGlwcHkucmVmZXJlbmNlID09PSB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRBcnJheU9mRWxlbWVudHModmFsdWUpIHtcbiAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChpc05vZGVMaXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheUZyb20odmFsdWUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uRHVyYXRpb24oZWxzLCB2YWx1ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHZhbHVlICsgXCJtc1wiO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWaXNpYmlsaXR5U3RhdGUoZWxzLCBzdGF0ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50T3JFbGVtZW50cykge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBfbm9ybWFsaXplVG9BcnJheSA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudE9yRWxlbWVudHMpLFxuICAgICAgZWxlbWVudCA9IF9ub3JtYWxpemVUb0FycmF5WzBdOyAvLyBFbGVtZW50cyBjcmVhdGVkIHZpYSBhIDx0ZW1wbGF0ZT4gaGF2ZSBhbiBvd25lckRvY3VtZW50IHdpdGggbm8gcmVmZXJlbmNlIHRvIHRoZSBib2R5XG5cblxuICByZXR1cm4gZWxlbWVudCAhPSBudWxsICYmIChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpICE9IG51bGwgJiYgX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyKHBvcHBlclRyZWVEYXRhLCBldmVudCkge1xuICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgcmV0dXJuIHBvcHBlclRyZWVEYXRhLmV2ZXJ5KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHBvcHBlclJlY3QgPSBfcmVmLnBvcHBlclJlY3QsXG4gICAgICAgIHBvcHBlclN0YXRlID0gX3JlZi5wb3BwZXJTdGF0ZSxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgIHZhciBpbnRlcmFjdGl2ZUJvcmRlciA9IHByb3BzLmludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwb3BwZXJTdGF0ZS5wbGFjZW1lbnQpO1xuICAgIHZhciBvZmZzZXREYXRhID0gcG9wcGVyU3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG5cbiAgICBpZiAoIW9mZnNldERhdGEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciB0b3BEaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nID8gb2Zmc2V0RGF0YS50b3AueSA6IDA7XG4gICAgdmFyIGJvdHRvbURpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcgPyBvZmZzZXREYXRhLmJvdHRvbS55IDogMDtcbiAgICB2YXIgbGVmdERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IG9mZnNldERhdGEubGVmdC54IDogMDtcbiAgICB2YXIgcmlnaHREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IG9mZnNldERhdGEucmlnaHQueCA6IDA7XG4gICAgdmFyIGV4Y2VlZHNUb3AgPSBwb3BwZXJSZWN0LnRvcCAtIGNsaWVudFkgKyB0b3BEaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzQm90dG9tID0gY2xpZW50WSAtIHBvcHBlclJlY3QuYm90dG9tIC0gYm90dG9tRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc0xlZnQgPSBwb3BwZXJSZWN0LmxlZnQgLSBjbGllbnRYICsgbGVmdERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNSaWdodCA9IGNsaWVudFggLSBwb3BwZXJSZWN0LnJpZ2h0IC0gcmlnaHREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHJldHVybiBleGNlZWRzVG9wIHx8IGV4Y2VlZHNCb3R0b20gfHwgZXhjZWVkc0xlZnQgfHwgZXhjZWVkc1JpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsIGFjdGlvbiwgbGlzdGVuZXIpIHtcbiAgdmFyIG1ldGhvZCA9IGFjdGlvbiArIFwiRXZlbnRMaXN0ZW5lclwiOyAvLyBzb21lIGJyb3dzZXJzIGFwcGFyZW50bHkgc3VwcG9ydCBgdHJhbnNpdGlvbmAgKHVucHJlZml4ZWQpIGJ1dCBvbmx5IGZpcmVcbiAgLy8gYHdlYmtpdFRyYW5zaXRpb25FbmRgLi4uXG5cbiAgWyd0cmFuc2l0aW9uZW5kJywgJ3dlYmtpdFRyYW5zaXRpb25FbmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGJveFttZXRob2RdKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH0pO1xufVxuLyoqXG4gKiBDb21wYXJlZCB0byB4eHguY29udGFpbnMsIHRoaXMgZnVuY3Rpb24gd29ya3MgZm9yIGRvbSBzdHJ1Y3R1cmVzIHdpdGggc2hhZG93XG4gKiBkb21cbiAqL1xuXG5mdW5jdGlvbiBhY3R1YWxDb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciB0YXJnZXQgPSBjaGlsZDtcblxuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgdmFyIF90YXJnZXQkZ2V0Um9vdE5vZGU7XG5cbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5nZXRSb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogKF90YXJnZXQkZ2V0Um9vdE5vZGUgPSB0YXJnZXQuZ2V0Um9vdE5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkZ2V0Um9vdE5vZGUuaG9zdDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGN1cnJlbnRJbnB1dCA9IHtcbiAgaXNUb3VjaDogZmFsc2Vcbn07XG52YXIgbGFzdE1vdXNlTW92ZVRpbWUgPSAwO1xuLyoqXG4gKiBXaGVuIGEgYHRvdWNoc3RhcnRgIGV2ZW50IGlzIGZpcmVkLCBpdCdzIGFzc3VtZWQgdGhlIHVzZXIgaXMgdXNpbmcgdG91Y2hcbiAqIGlucHV0LiBXZSdsbCBiaW5kIGEgYG1vdXNlbW92ZWAgZXZlbnQgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBtb3VzZSBpbnB1dCBpblxuICogdGhlIGZ1dHVyZS4gVGhpcyB3YXksIHRoZSBgaXNUb3VjaGAgcHJvcGVydHkgaXMgZnVsbHkgZHluYW1pYyBhbmQgd2lsbCBoYW5kbGVcbiAqIGh5YnJpZCBkZXZpY2VzIHRoYXQgdXNlIGEgbWl4IG9mIHRvdWNoICsgbW91c2UgaW5wdXQuXG4gKi9cblxuZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoKSB7XG4gIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gdHJ1ZTtcblxuICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cbn1cbi8qKlxuICogV2hlbiB0d28gYG1vdXNlbW92ZWAgZXZlbnQgYXJlIGZpcmVkIGNvbnNlY3V0aXZlbHkgd2l0aGluIDIwbXMsIGl0J3MgYXNzdW1lZFxuICogdGhlIHVzZXIgaXMgdXNpbmcgbW91c2UgaW5wdXQgYWdhaW4uIGBtb3VzZW1vdmVgIGNhbiBmaXJlIG9uIHRvdWNoIGRldmljZXMgYXNcbiAqIHdlbGwsIGJ1dCB2ZXJ5IHJhcmVseSB0aGF0IHF1aWNrbHkuXG4gKi9cblxuZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlTW92ZSgpIHtcbiAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIGlmIChub3cgLSBsYXN0TW91c2VNb3ZlVGltZSA8IDIwKSB7XG4gICAgY3VycmVudElucHV0LmlzVG91Y2ggPSBmYWxzZTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxuXG4gIGxhc3RNb3VzZU1vdmVUaW1lID0gbm93O1xufVxuLyoqXG4gKiBXaGVuIGFuIGVsZW1lbnQgaXMgaW4gZm9jdXMgYW5kIGhhcyBhIHRpcHB5LCBsZWF2aW5nIHRoZSB0YWIvd2luZG93IGFuZFxuICogcmV0dXJuaW5nIGNhdXNlcyBpdCB0byBzaG93IGFnYWluLiBGb3IgbW91c2UgdXNlcnMgdGhpcyBpcyB1bmV4cGVjdGVkLCBidXRcbiAqIGZvciBrZXlib2FyZCB1c2UgaXQgbWFrZXMgc2Vuc2UuXG4gKiBUT0RPOiBmaW5kIGEgYmV0dGVyIHRlY2huaXF1ZSB0byBzb2x2ZSB0aGlzIHByb2JsZW1cbiAqL1xuXG5mdW5jdGlvbiBvbldpbmRvd0JsdXIoKSB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICBpZiAoaXNSZWZlcmVuY2VFbGVtZW50KGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlRWxlbWVudC5fdGlwcHk7XG5cbiAgICBpZiAoYWN0aXZlRWxlbWVudC5ibHVyICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb2N1bWVudFRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uV2luZG93Qmx1cik7XG59XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGlzSUUxMSA9IGlzQnJvd3NlciA/IC8vIEB0cy1pZ25vcmVcbiEhd2luZG93Lm1zQ3J5cHRvIDogZmFsc2U7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKG1ldGhvZCkge1xuICB2YXIgdHh0ID0gbWV0aG9kID09PSAnZGVzdHJveScgPyAnbiBhbHJlYWR5LScgOiAnICc7XG4gIHJldHVybiBbbWV0aG9kICsgXCIoKSB3YXMgY2FsbGVkIG9uIGFcIiArIHR4dCArIFwiZGVzdHJveWVkIGluc3RhbmNlLiBUaGlzIGlzIGEgbm8tb3AgYnV0XCIsICdpbmRpY2F0ZXMgYSBwb3RlbnRpYWwgbWVtb3J5IGxlYWsuJ10uam9pbignICcpO1xufVxuZnVuY3Rpb24gY2xlYW4odmFsdWUpIHtcbiAgdmFyIHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuICB2YXIgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGdldERldk1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gY2xlYW4oXCJcXG4gICVjdGlwcHkuanNcXG5cXG4gICVjXCIgKyBjbGVhbihtZXNzYWdlKSArIFwiXFxuXFxuICAlY1xcdUQ4M0RcXHVEQzc3XFx1MjAwRCBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQtb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbi5cXG4gIFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgLy8gdGl0bGVcbiAgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuM2VtOyBmb250LXdlaWdodDogYm9sZDsnLCAvLyBtZXNzYWdlXG4gICdsaW5lLWhlaWdodDogMS41JywgLy8gZm9vdGVyXG4gICdjb2xvcjogI2E2YTA5NTsnXTtcbn0gLy8gQXNzdW1lIHdhcm5pbmdzIGFuZCBlcnJvcnMgbmV2ZXIgaGF2ZSB0aGUgc2FtZSBtZXNzYWdlXG5cbnZhciB2aXNpdGVkTWVzc2FnZXM7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgcmVzZXRWaXNpdGVkTWVzc2FnZXMoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRWaXNpdGVkTWVzc2FnZXMoKSB7XG4gIHZpc2l0ZWRNZXNzYWdlcyA9IG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHdhcm5XaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcblxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcldoZW4oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2YXIgX2NvbnNvbGUyO1xuXG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcblxuICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZTIsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgZGlkUGFzc0ZhbHN5VmFsdWUgPSAhdGFyZ2V0cztcbiAgdmFyIGRpZFBhc3NQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgIXRhcmdldHMuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgZXJyb3JXaGVuKGRpZFBhc3NGYWxzeVZhbHVlLCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCcsICdgJyArIFN0cmluZyh0YXJnZXRzKSArICdgJywgJ2FzIGl0cyB0YXJnZXRzIChmaXJzdCkgYXJndW1lbnQuIFZhbGlkIHR5cGVzIGFyZTogU3RyaW5nLCBFbGVtZW50LCcsICdFbGVtZW50W10sIG9yIE5vZGVMaXN0LiddLmpvaW4oJyAnKSk7XG4gIGVycm9yV2hlbihkaWRQYXNzUGxhaW5PYmplY3QsIFsndGlwcHkoKSB3YXMgcGFzc2VkIGEgcGxhaW4gb2JqZWN0IHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQnLCAnZm9yIHZpcnR1YWwgcG9zaXRpb25pbmcuIFVzZSBwcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0IGluc3RlYWQuJ10uam9pbignICcpKTtcbn1cblxudmFyIHBsdWdpblByb3BzID0ge1xuICBhbmltYXRlRmlsbDogZmFsc2UsXG4gIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gIGlubGluZVBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgc3RpY2t5OiBmYWxzZVxufTtcbnZhciByZW5kZXJQcm9wcyA9IHtcbiAgYWxsb3dIVE1MOiBmYWxzZSxcbiAgYW5pbWF0aW9uOiAnZmFkZScsXG4gIGFycm93OiB0cnVlLFxuICBjb250ZW50OiAnJyxcbiAgaW5lcnRpYTogZmFsc2UsXG4gIG1heFdpZHRoOiAzNTAsXG4gIHJvbGU6ICd0b29sdGlwJyxcbiAgdGhlbWU6ICcnLFxuICB6SW5kZXg6IDk5OTlcbn07XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7XG4gIGFwcGVuZFRvOiBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyxcbiAgYXJpYToge1xuICAgIGNvbnRlbnQ6ICdhdXRvJyxcbiAgICBleHBhbmRlZDogJ2F1dG8nXG4gIH0sXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogWzMwMCwgMjUwXSxcbiAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIGludGVyYWN0aXZlQm9yZGVyOiAyLFxuICBpbnRlcmFjdGl2ZURlYm91bmNlOiAwLFxuICBtb3ZlVHJhbnNpdGlvbjogJycsXG4gIG9mZnNldDogWzAsIDEwXSxcbiAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZSgpIHt9LFxuICBvbkJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gb25CZWZvcmVVcGRhdGUoKSB7fSxcbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge30sXG4gIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHt9LFxuICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHt9LFxuICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge30sXG4gIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge30sXG4gIG9uU2hvd246IGZ1bmN0aW9uIG9uU2hvd24oKSB7fSxcbiAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoKSB7fSxcbiAgb25VbnRyaWdnZXI6IGZ1bmN0aW9uIG9uVW50cmlnZ2VyKCkge30sXG4gIG9uQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbiBvbkNsaWNrT3V0c2lkZSgpIHt9LFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwbHVnaW5zOiBbXSxcbiAgcG9wcGVyT3B0aW9uczoge30sXG4gIHJlbmRlcjogbnVsbCxcbiAgc2hvd09uQ3JlYXRlOiBmYWxzZSxcbiAgdG91Y2g6IHRydWUsXG4gIHRyaWdnZXI6ICdtb3VzZWVudGVyIGZvY3VzJyxcbiAgdHJpZ2dlclRhcmdldDogbnVsbFxufSwgcGx1Z2luUHJvcHMsIHJlbmRlclByb3BzKTtcbnZhciBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRQcm9wcyk7XG52YXIgc2V0RGVmYXVsdFByb3BzID0gZnVuY3Rpb24gc2V0RGVmYXVsdFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIFtdKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWZhdWx0UHJvcHNba2V5XSA9IHBhcnRpYWxQcm9wc1trZXldO1xuICB9KTtcbn07XG5mdW5jdGlvbiBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHBhc3NlZFByb3BzKSB7XG4gIHZhciBwbHVnaW5zID0gcGFzc2VkUHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgdmFyIHBsdWdpblByb3BzID0gcGx1Z2lucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGx1Z2luKSB7XG4gICAgdmFyIG5hbWUgPSBwbHVnaW4ubmFtZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcGx1Z2luLmRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgX25hbWU7XG5cbiAgICAgIGFjY1tuYW1lXSA9IHBhc3NlZFByb3BzW25hbWVdICE9PSB1bmRlZmluZWQgPyBwYXNzZWRQcm9wc1tuYW1lXSA6IChfbmFtZSA9IGRlZmF1bHRQcm9wc1tuYW1lXSkgIT0gbnVsbCA/IF9uYW1lIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhc3NlZFByb3BzLCBwbHVnaW5Qcm9wcyk7XG59XG5mdW5jdGlvbiBnZXREYXRhQXR0cmlidXRlUHJvcHMocmVmZXJlbmNlLCBwbHVnaW5zKSB7XG4gIHZhciBwcm9wS2V5cyA9IHBsdWdpbnMgPyBPYmplY3Qua2V5cyhnZXRFeHRlbmRlZFBhc3NlZFByb3BzKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywge1xuICAgIHBsdWdpbnM6IHBsdWdpbnNcbiAgfSkpKSA6IGRlZmF1bHRLZXlzO1xuICB2YXIgcHJvcHMgPSBwcm9wS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHZhbHVlQXNTdHJpbmcgPSAocmVmZXJlbmNlLmdldEF0dHJpYnV0ZShcImRhdGEtdGlwcHktXCIgKyBrZXkpIHx8ICcnKS50cmltKCk7XG5cbiAgICBpZiAoIXZhbHVlQXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjY1trZXldID0gSlNPTi5wYXJzZSh2YWx1ZUFzU3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIHByb3BzKSB7XG4gIHZhciBvdXQgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4ocHJvcHMuY29udGVudCwgW3JlZmVyZW5jZV0pXG4gIH0sIHByb3BzLmlnbm9yZUF0dHJpYnV0ZXMgPyB7fSA6IGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHByb3BzLnBsdWdpbnMpKTtcbiAgb3V0LmFyaWEgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMuYXJpYSwgb3V0LmFyaWEpO1xuICBvdXQuYXJpYSA9IHtcbiAgICBleHBhbmRlZDogb3V0LmFyaWEuZXhwYW5kZWQgPT09ICdhdXRvJyA/IHByb3BzLmludGVyYWN0aXZlIDogb3V0LmFyaWEuZXhwYW5kZWQsXG4gICAgY29udGVudDogb3V0LmFyaWEuY29udGVudCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgPyBudWxsIDogJ2Rlc2NyaWJlZGJ5JyA6IG91dC5hcmlhLmNvbnRlbnRcbiAgfTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBwbHVnaW5zKSB7XG4gIGlmIChwYXJ0aWFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHBhcnRpYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIG5vblBsdWdpblByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhkZWZhdWx0UHJvcHMsIE9iamVjdC5rZXlzKHBsdWdpblByb3BzKSk7XG4gICAgdmFyIGRpZFBhc3NVbmtub3duUHJvcCA9ICFoYXNPd25Qcm9wZXJ0eShub25QbHVnaW5Qcm9wcywgcHJvcCk7IC8vIENoZWNrIGlmIHRoZSBwcm9wIGV4aXN0cyBpbiBgcGx1Z2luc2BcblxuICAgIGlmIChkaWRQYXNzVW5rbm93blByb3ApIHtcbiAgICAgIGRpZFBhc3NVbmtub3duUHJvcCA9IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5uYW1lID09PSBwcm9wO1xuICAgICAgfSkubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIHdhcm5XaGVuKGRpZFBhc3NVbmtub3duUHJvcCwgW1wiYFwiICsgcHJvcCArIFwiYFwiLCBcImlzIG5vdCBhIHZhbGlkIHByb3AuIFlvdSBtYXkgaGF2ZSBzcGVsbGVkIGl0IGluY29ycmVjdGx5LCBvciBpZiBpdCdzXCIsICdhIHBsdWdpbiwgZm9yZ290IHRvIHBhc3MgaXQgaW4gYW4gYXJyYXkgYXMgcHJvcHMucGx1Z2lucy4nLCAnXFxuXFxuJywgJ0FsbCBwcm9wczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FsbC1wcm9wcy9cXG4nLCAnUGx1Z2luczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L3BsdWdpbnMvJ10uam9pbignICcpKTtcbiAgfSk7XG59XG5cbnZhciBpbm5lckhUTUwgPSBmdW5jdGlvbiBpbm5lckhUTUwoKSB7XG4gIHJldHVybiAnaW5uZXJIVE1MJztcbn07XG5cbmZ1bmN0aW9uIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGVsZW1lbnQsIGh0bWwpIHtcbiAgZWxlbWVudFtpbm5lckhUTUwoKV0gPSBodG1sO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJvd0VsZW1lbnQodmFsdWUpIHtcbiAgdmFyIGFycm93ID0gZGl2KCk7XG5cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gQVJST1dfQ0xBU1M7XG4gIH0gZWxzZSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gU1ZHX0FSUk9XX0NMQVNTO1xuXG4gICAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgIGFycm93LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoYXJyb3csIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyb3c7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCwgcHJvcHMpIHtcbiAgaWYgKGlzRWxlbWVudChwcm9wcy5jb250ZW50KSkge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGNvbnRlbnQsICcnKTtcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKHByb3BzLmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5jb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb3BzLmFsbG93SFRNTCkge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgcHJvcHMuY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQudGV4dENvbnRlbnQgPSBwcm9wcy5jb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4ocG9wcGVyKSB7XG4gIHZhciBib3ggPSBwb3BwZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIHZhciBib3hDaGlsZHJlbiA9IGFycmF5RnJvbShib3guY2hpbGRyZW4pO1xuICByZXR1cm4ge1xuICAgIGJveDogYm94LFxuICAgIGNvbnRlbnQ6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDT05URU5UX0NMQVNTKTtcbiAgICB9KSxcbiAgICBhcnJvdzogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEFSUk9XX0NMQVNTKSB8fCBub2RlLmNsYXNzTGlzdC5jb250YWlucyhTVkdfQVJST1dfQ0xBU1MpO1xuICAgIH0pLFxuICAgIGJhY2tkcm9wOiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQkFDS0RST1BfQ0xBU1MpO1xuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoaW5zdGFuY2UpIHtcbiAgdmFyIHBvcHBlciA9IGRpdigpO1xuICB2YXIgYm94ID0gZGl2KCk7XG4gIGJveC5jbGFzc05hbWUgPSBCT1hfQ0xBU1M7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIHZhciBjb250ZW50ID0gZGl2KCk7XG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTUztcbiAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG4gIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICBwb3BwZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgYm94LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICBvblVwZGF0ZShpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gIGZ1bmN0aW9uIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKHBvcHBlciksXG4gICAgICAgIGJveCA9IF9nZXRDaGlsZHJlbi5ib3gsXG4gICAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudCxcbiAgICAgICAgYXJyb3cgPSBfZ2V0Q2hpbGRyZW4uYXJyb3c7XG5cbiAgICBpZiAobmV4dFByb3BzLnRoZW1lKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgbmV4dFByb3BzLnRoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10aGVtZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV4dFByb3BzLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJywgbmV4dFByb3BzLmFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5pbmVydGlhKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScpO1xuICAgIH1cblxuICAgIGJveC5zdHlsZS5tYXhXaWR0aCA9IHR5cGVvZiBuZXh0UHJvcHMubWF4V2lkdGggPT09ICdudW1iZXInID8gbmV4dFByb3BzLm1heFdpZHRoICsgXCJweFwiIDogbmV4dFByb3BzLm1heFdpZHRoO1xuXG4gICAgaWYgKG5leHRQcm9wcy5yb2xlKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZQcm9wcy5jb250ZW50ICE9PSBuZXh0UHJvcHMuY29udGVudCB8fCBwcmV2UHJvcHMuYWxsb3dIVE1MICE9PSBuZXh0UHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmFycm93KSB7XG4gICAgICBpZiAoIWFycm93KSB7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hcnJvdyAhPT0gbmV4dFByb3BzLmFycm93KSB7XG4gICAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJvdykge1xuICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvcHBlcjogcG9wcGVyLFxuICAgIG9uVXBkYXRlOiBvblVwZGF0ZVxuICB9O1xufSAvLyBSdW50aW1lIGNoZWNrIHRvIGlkZW50aWZ5IGlmIHRoZSByZW5kZXIgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgb25lOyB0aGlzXG4vLyB3YXkgd2UgY2FuIGFwcGx5IGRlZmF1bHQgQ1NTIHRyYW5zaXRpb25zIGxvZ2ljIGFuZCBpdCBjYW4gYmUgdHJlZS1zaGFrZW4gYXdheVxuXG5yZW5kZXIuJCR0aXBweSA9IHRydWU7XG5cbnZhciBpZENvdW50ZXIgPSAxO1xudmFyIG1vdXNlTW92ZUxpc3RlbmVycyA9IFtdOyAvLyBVc2VkIGJ5IGBoaWRlQWxsKClgXG5cbnZhciBtb3VudGVkSW5zdGFuY2VzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKSB7XG4gIHZhciBwcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMocmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFzc2VkUHJvcHMpKSkpOyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIHNob3dUaW1lb3V0O1xuICB2YXIgaGlkZVRpbWVvdXQ7XG4gIHZhciBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZTtcbiAgdmFyIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuICB2YXIgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgdmFyIGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICB2YXIgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICB2YXIgbGFzdFRyaWdnZXJFdmVudDtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXI7XG4gIHZhciBvbkZpcnN0VXBkYXRlO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBwcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBpZCA9IGlkQ291bnRlcisrO1xuICB2YXIgcG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICB2YXIgcGx1Z2lucyA9IHVuaXF1ZShwcm9wcy5wbHVnaW5zKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIElzIHRoZSBpbnN0YW5jZSBjdXJyZW50bHkgZW5hYmxlZD9cbiAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBzaG93aW5nIGFuZCBub3QgdHJhbnNpdGlvbmluZyBvdXQ/XG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIGluc3RhbmNlIGJlZW4gZGVzdHJveWVkP1xuICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IG1vdW50ZWQgdG8gdGhlIERPTT9cbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgdGlwcHkgZmluaXNoZWQgdHJhbnNpdGlvbmluZyBpbj9cbiAgICBpc1Nob3duOiBmYWxzZVxuICB9O1xuICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgLy8gcHJvcGVydGllc1xuICAgIGlkOiBpZCxcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICBwb3BwZXI6IGRpdigpLFxuICAgIHBvcHBlckluc3RhbmNlOiBwb3BwZXJJbnN0YW5jZSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIHBsdWdpbnM6IHBsdWdpbnMsXG4gICAgLy8gbWV0aG9kc1xuICAgIGNsZWFyRGVsYXlUaW1lb3V0czogY2xlYXJEZWxheVRpbWVvdXRzLFxuICAgIHNldFByb3BzOiBzZXRQcm9wcyxcbiAgICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICAgIHNob3c6IHNob3csXG4gICAgaGlkZTogaGlkZSxcbiAgICBoaWRlV2l0aEludGVyYWN0aXZpdHk6IGhpZGVXaXRoSW50ZXJhY3Rpdml0eSxcbiAgICBlbmFibGU6IGVuYWJsZSxcbiAgICBkaXNhYmxlOiBkaXNhYmxlLFxuICAgIHVubW91bnQ6IHVubW91bnQsXG4gICAgZGVzdHJveTogZGVzdHJveVxuICB9OyAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhpcyBlYXJseSByZXR1cm4gY2F1c2VzIGEgVERaIGVycm9yIGluIHRoZSB0ZXN0cyDigJRcbiAgLy8gaXQgZG9lc24ndCBzZWVtIHRvIGhhcHBlbiBpbiB0aGUgYnJvd3NlclxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gIGlmICghcHJvcHMucmVuZGVyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZXJyb3JXaGVuKHRydWUsICdyZW5kZXIoKSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gc3VwcGxpZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbml0aWFsIG11dGF0aW9uc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIHZhciBfcHJvcHMkcmVuZGVyID0gcHJvcHMucmVuZGVyKGluc3RhbmNlKSxcbiAgICAgIHBvcHBlciA9IF9wcm9wcyRyZW5kZXIucG9wcGVyLFxuICAgICAgb25VcGRhdGUgPSBfcHJvcHMkcmVuZGVyLm9uVXBkYXRlO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktcm9vdCcsICcnKTtcbiAgcG9wcGVyLmlkID0gXCJ0aXBweS1cIiArIGluc3RhbmNlLmlkO1xuICBpbnN0YW5jZS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJlZmVyZW5jZS5fdGlwcHkgPSBpbnN0YW5jZTtcbiAgcG9wcGVyLl90aXBweSA9IGluc3RhbmNlO1xuICB2YXIgcGx1Z2luc0hvb2tzID0gcGx1Z2lucy5tYXAoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHJldHVybiBwbHVnaW4uZm4oaW5zdGFuY2UpO1xuICB9KTtcbiAgdmFyIGhhc0FyaWFFeHBhbmRlZCA9IHJlZmVyZW5jZS5oYXNBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgYWRkTGlzdGVuZXJzKCk7XG4gIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICBoYW5kbGVTdHlsZXMoKTtcbiAgaW52b2tlSG9vaygnb25DcmVhdGUnLCBbaW5zdGFuY2VdKTtcblxuICBpZiAocHJvcHMuc2hvd09uQ3JlYXRlKSB7XG4gICAgc2NoZWR1bGVTaG93KCk7XG4gIH0gLy8gUHJldmVudCBhIHRpcHB5IHdpdGggYSBkZWxheSBmcm9tIGhpZGluZyBpZiB0aGUgY3Vyc29yIGxlZnQgdGhlbiByZXR1cm5lZFxuICAvLyBiZWZvcmUgaXQgc3RhcnRlZCBoaWRpbmdcblxuXG4gIHBvcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIH1cbiAgfSk7XG4gIHBvcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwKSB7XG4gICAgICBnZXREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpIHtcbiAgICB2YXIgdG91Y2ggPSBpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0b3VjaCkgPyB0b3VjaCA6IFt0b3VjaCwgMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKClbMF0gPT09ICdob2xkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzRGVmYXVsdFJlbmRlckZuKCkge1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMkcmVuZGU7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICEhKChfaW5zdGFuY2UkcHJvcHMkcmVuZGUgPSBpbnN0YW5jZS5wcm9wcy5yZW5kZXIpICE9IG51bGwgJiYgX2luc3RhbmNlJHByb3BzJHJlbmRlLiQkdGlwcHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldCgpIHtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldCB8fCByZWZlcmVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0Q3VycmVudFRhcmdldCgpLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCA/IGdldE93bmVyRG9jdW1lbnQocGFyZW50KSA6IGRvY3VtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHBvcHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWxheShpc1Nob3cpIHtcbiAgICAvLyBGb3IgdG91Y2ggb3Iga2V5Ym9hcmQgaW5wdXQsIGZvcmNlIGAwYCBkZWxheSBmb3IgVVggcmVhc29uc1xuICAgIC8vIEFsc28gaWYgdGhlIGluc3RhbmNlIGlzIG1vdW50ZWQgYnV0IG5vdCB2aXNpYmxlICh0cmFuc2l0aW9uaW5nIG91dCksXG4gICAgLy8gaWdub3JlIGRlbGF5XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGN1cnJlbnRJbnB1dC5pc1RvdWNoIHx8IGxhc3RUcmlnZ2VyRXZlbnQgJiYgbGFzdFRyaWdnZXJFdmVudC50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZGVsYXksIGlzU2hvdyA/IDAgOiAxLCBkZWZhdWx0UHJvcHMuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3R5bGVzKGZyb21IaWRlKSB7XG4gICAgaWYgKGZyb21IaWRlID09PSB2b2lkIDApIHtcbiAgICAgIGZyb21IaWRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcG9wcGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiAhZnJvbUhpZGUgPyAnJyA6ICdub25lJztcbiAgICBwb3BwZXIuc3R5bGUuekluZGV4ID0gXCJcIiArIGluc3RhbmNlLnByb3BzLnpJbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUhvb2soaG9vaywgYXJncywgc2hvdWxkSW52b2tlUHJvcHNIb29rKSB7XG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vayA9PT0gdm9pZCAwKSB7XG4gICAgICBzaG91bGRJbnZva2VQcm9wc0hvb2sgPSB0cnVlO1xuICAgIH1cblxuICAgIHBsdWdpbnNIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5Ib29rcykge1xuICAgICAgaWYgKHBsdWdpbkhvb2tzW2hvb2tdKSB7XG4gICAgICAgIHBsdWdpbkhvb2tzW2hvb2tdLmFwcGx5KHBsdWdpbkhvb2tzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcHJvcHM7XG5cbiAgICAgIChfaW5zdGFuY2UkcHJvcHMgPSBpbnN0YW5jZS5wcm9wcylbaG9va10uYXBwbHkoX2luc3RhbmNlJHByb3BzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpIHtcbiAgICB2YXIgYXJpYSA9IGluc3RhbmNlLnByb3BzLmFyaWE7XG5cbiAgICBpZiAoIWFyaWEuY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdHRyID0gXCJhcmlhLVwiICsgYXJpYS5jb250ZW50O1xuICAgIHZhciBpZCA9IHBvcHBlci5pZDtcbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgY3VycmVudFZhbHVlID8gY3VycmVudFZhbHVlICsgXCIgXCIgKyBpZCA6IGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLnJlcGxhY2UoaWQsICcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIG5leHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpIHtcbiAgICBpZiAoaGFzQXJpYUV4cGFuZGVkIHx8ICFpbnN0YW5jZS5wcm9wcy5hcmlhLmV4cGFuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIG5vZGUgPT09IGdldEN1cnJlbnRUYXJnZXQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCkge1xuICAgIGdldERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIG1vdXNlTW92ZUxpc3RlbmVycyA9IG1vdXNlTW92ZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIgIT09IGRlYm91bmNlZE9uTW91c2VNb3ZlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Eb2N1bWVudFByZXNzKGV2ZW50KSB7XG4gICAgLy8gTW92ZWQgZmluZ2VyIHRvIHNjcm9sbCBpbnN0ZWFkIG9mIGFuIGludGVudGlvbmFsIHRhcCBvdXRzaWRlXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICBpZiAoZGlkVG91Y2hNb3ZlIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsVGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoICYmIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdIHx8IGV2ZW50LnRhcmdldDsgLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhY3R1YWxDb250YWlucyhwb3BwZXIsIGFjdHVhbFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENsaWNrZWQgb24gdGhlIGV2ZW50IGxpc3RlbmVycyB0YXJnZXRcblxuXG4gICAgaWYgKG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpLnNvbWUoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gYWN0dWFsQ29udGFpbnMoZWwsIGFjdHVhbFRhcmdldCk7XG4gICAgfSkpIHtcbiAgICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZva2VIb29rKCdvbkNsaWNrT3V0c2lkZScsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpOyAvLyBgbW91c2Vkb3duYCBldmVudCBpcyBmaXJlZCByaWdodCBiZWZvcmUgYGZvY3VzYCBpZiBwcmVzc2luZyB0aGVcbiAgICAgIC8vIGN1cnJlbnRUYXJnZXQuIFRoaXMgbGV0cyBhIHRpcHB5IHdpdGggYGZvY3VzYCB0cmlnZ2VyIGtub3cgdGhhdCBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBzaG93XG5cbiAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfSk7IC8vIFRoZSBsaXN0ZW5lciBnZXRzIGFkZGVkIGluIGBzY2hlZHVsZVNob3coKWAsIGJ1dCB0aGlzIG1heSBiZSBoaWRpbmcgaXRcbiAgICAgIC8vIGJlZm9yZSBpdCBzaG93cywgYW5kIGhpZGUoKSdzIGVhcmx5IGJhaWwtb3V0IGJlaGF2aW9yIGNhbiBwcmV2ZW50IGl0XG4gICAgICAvLyBmcm9tIGJlaW5nIGNsZWFuZWQgdXBcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgIGRpZFRvdWNoTW92ZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoKSB7XG4gICAgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGREb2N1bWVudFByZXNzKCkge1xuICAgIHZhciBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEb2N1bWVudFByZXNzKCkge1xuICAgIHZhciBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIHBvcHBlci5wYXJlbnROb2RlICYmIHBvcHBlci5wYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGJveCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCkuYm94O1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGJveCkge1xuICAgICAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgbGlzdGVuZXIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSBjYWxsYmFjayBzeW5jaHJvbm91cyBpZiBkdXJhdGlvbiBpcyAwXG4gICAgLy8gYHRyYW5zaXRpb25lbmRgIHdvbid0IGZpcmUgb3RoZXJ3aXNlXG5cblxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdhZGQnLCBsaXN0ZW5lcik7XG4gICAgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gb24oZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpKSB7XG4gICAgICBvbigndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9uKCd0b3VjaGVuZCcsIG9uTW91c2VMZWF2ZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzcGxpdEJ5U3BhY2VzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbihldmVudFR5cGUsIG9uVHJpZ2dlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIG9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgb24oaXNJRTExID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJywgb25CbHVyT3JGb2N1c091dCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICAgICAgb24oJ2ZvY3Vzb3V0Jywgb25CbHVyT3JGb2N1c091dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgdmFyIF9sYXN0VHJpZ2dlckV2ZW50O1xuXG4gICAgdmFyIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gZmFsc2U7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCB8fCBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fCBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXNGb2N1c2VkID0gKChfbGFzdFRyaWdnZXJFdmVudCA9IGxhc3RUcmlnZ2VyRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbGFzdFRyaWdnZXJFdmVudC50eXBlKSA9PT0gJ2ZvY3VzJztcbiAgICBsYXN0VHJpZ2dlckV2ZW50ID0gZXZlbnQ7XG4gICAgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAvLyBJZiBzY3JvbGxpbmcsIGBtb3VzZWVudGVyYCBldmVudHMgY2FuIGJlIGZpcmVkIGlmIHRoZSBjdXJzb3IgbGFuZHNcbiAgICAgIC8vIG92ZXIgYSBuZXcgdGFyZ2V0LCBidXQgYG1vdXNlbW92ZWAgZXZlbnRzIGRvbid0IGdldCBmaXJlZC4gVGhpc1xuICAgICAgLy8gY2F1c2VzIGludGVyYWN0aXZlIHRvb2x0aXBzIHRvIGdldCBzdHVjayBvcGVuIHVudGlsIHRoZSBjdXJzb3IgaXNcbiAgICAgIC8vIG1vdmVkXG4gICAgICBtb3VzZU1vdmVMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gVG9nZ2xlIHNob3cvaGlkZSB3aGVuIGNsaWNraW5nIGNsaWNrLXRyaWdnZXJlZCB0b29sdGlwc1xuXG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPCAwIHx8IGlzVmlzaWJsZUZyb21DbGljaykgJiYgaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgIT09IGZhbHNlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVNob3coZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSAhc2hvdWxkU2NoZWR1bGVDbGlja0hpZGU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlICYmICF3YXNGb2N1c2VkKSB7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIgPSBnZXRDdXJyZW50VGFyZ2V0KCkuY29udGFpbnModGFyZ2V0KSB8fCBwb3BwZXIuY29udGFpbnModGFyZ2V0KTtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyAmJiBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb3BwZXJUcmVlRGF0YSA9IGdldE5lc3RlZFBvcHBlclRyZWUoKS5jb25jYXQocG9wcGVyKS5tYXAoZnVuY3Rpb24gKHBvcHBlcikge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwb3BwZXJJbnN0YTtcblxuICAgICAgdmFyIGluc3RhbmNlID0gcG9wcGVyLl90aXBweTtcbiAgICAgIHZhciBzdGF0ZSA9IChfaW5zdGFuY2UkcG9wcGVySW5zdGEgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRwb3BwZXJJbnN0YS5zdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9wcGVyUmVjdDogcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIHBvcHBlclN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgaWYgKGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyKHBvcHBlclRyZWVEYXRhLCBldmVudCkpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgIHZhciBzaG91bGRCYWlsID0gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHwgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiYgaXNWaXNpYmxlRnJvbUNsaWNrO1xuXG4gICAgaWYgKHNob3VsZEJhaWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGVXaXRoSW50ZXJhY3Rpdml0eShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1ck9yRm9jdXNPdXQoZXZlbnQpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdmb2N1c2luJykgPCAwICYmIGV2ZW50LnRhcmdldCAhPT0gZ2V0Q3VycmVudFRhcmdldCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiBmb2N1cyB3YXMgbW92ZWQgdG8gd2l0aGluIHRoZSBwb3BwZXJcblxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHtcbiAgICByZXR1cm4gY3VycmVudElucHV0LmlzVG91Y2ggPyBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSAhPT0gZXZlbnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDAgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlckluc3RhbmNlKCkge1xuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpO1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMyID0gaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIHBvcHBlck9wdGlvbnMgPSBfaW5zdGFuY2UkcHJvcHMyLnBvcHBlck9wdGlvbnMsXG4gICAgICAgIHBsYWNlbWVudCA9IF9pbnN0YW5jZSRwcm9wczIucGxhY2VtZW50LFxuICAgICAgICBvZmZzZXQgPSBfaW5zdGFuY2UkcHJvcHMyLm9mZnNldCxcbiAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA9IF9pbnN0YW5jZSRwcm9wczIuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgICAgbW92ZVRyYW5zaXRpb24gPSBfaW5zdGFuY2UkcHJvcHMyLm1vdmVUcmFuc2l0aW9uO1xuICAgIHZhciBhcnJvdyA9IGdldElzRGVmYXVsdFJlbmRlckZuKCkgPyBnZXRDaGlsZHJlbihwb3BwZXIpLmFycm93IDogbnVsbDtcbiAgICB2YXIgY29tcHV0ZWRSZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VDbGllbnRSZWN0ID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgY29udGV4dEVsZW1lbnQ6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QuY29udGV4dEVsZW1lbnQgfHwgZ2V0Q3VycmVudFRhcmdldCgpXG4gICAgfSA6IHJlZmVyZW5jZTtcbiAgICB2YXIgdGlwcHlNb2RpZmllciA9IHtcbiAgICAgIG5hbWU6ICckJHRpcHB5JyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgICAgIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihfcmVmMikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcblxuICAgICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICAgIHZhciBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2ggPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgICAgICBib3ggPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2guYm94O1xuXG4gICAgICAgICAgWydwbGFjZW1lbnQnLCAncmVmZXJlbmNlLWhpZGRlbicsICdlc2NhcGVkJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdwbGFjZW1lbnQnKSB7XG4gICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jywgc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlcltcImRhdGEtcG9wcGVyLVwiICsgYXR0cl0pIHtcbiAgICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIGF0dHIsICcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3gucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1cIiArIGF0dHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG1vZGlmaWVycyA9IFt7XG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICBib3R0b206IDIsXG4gICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICByaWdodDogNVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiA1XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhZGFwdGl2ZTogIW1vdmVUcmFuc2l0aW9uXG4gICAgICB9XG4gICAgfSwgdGlwcHlNb2RpZmllcl07XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBhcnJvdykge1xuICAgICAgbW9kaWZpZXJzLnB1c2goe1xuICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZWxlbWVudDogYXJyb3csXG4gICAgICAgICAgcGFkZGluZzogM1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2RpZmllcnMucHVzaC5hcHBseShtb2RpZmllcnMsIChwb3BwZXJPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBwb3BwZXJPcHRpb25zLm1vZGlmaWVycykgfHwgW10pO1xuICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gY3JlYXRlUG9wcGVyKGNvbXB1dGVkUmVmZXJlbmNlLCBwb3BwZXIsIE9iamVjdC5hc3NpZ24oe30sIHBvcHBlck9wdGlvbnMsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgb25GaXJzdFVwZGF0ZTogb25GaXJzdFVwZGF0ZSxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVBvcHBlckluc3RhbmNlKCkge1xuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIHZhciBhcHBlbmRUbyA9IGluc3RhbmNlLnByb3BzLmFwcGVuZFRvO1xuICAgIHZhciBwYXJlbnROb2RlOyAvLyBCeSBkZWZhdWx0LCB3ZSdsbCBhcHBlbmQgdGhlIHBvcHBlciB0byB0aGUgdHJpZ2dlclRhcmdldHMncyBwYXJlbnROb2RlIHNvXG4gICAgLy8gaXQncyBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgc28gdGhlIGVsZW1lbnRzIGluc2lkZSB0aGVcbiAgICAvLyB0aXBweSBjYW4gYmUgdGFiYmVkIHRvXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNsaXBwaW5nIGlzc3VlcywgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYXBwZW5kVG9cbiAgICAvLyBhbmQgZW5zdXJlIGZvY3VzIG1hbmFnZW1lbnQgaXMgaGFuZGxlZCBjb3JyZWN0bHkgbWFudWFsbHlcblxuICAgIHZhciBub2RlID0gZ2V0Q3VycmVudFRhcmdldCgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyB8fCBhcHBlbmRUbyA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUgPSBpbnZva2VXaXRoQXJnc09yUmV0dXJuKGFwcGVuZFRvLCBbbm9kZV0pO1xuICAgIH0gLy8gVGhlIHBvcHBlciBlbGVtZW50IG5lZWRzIHRvIGV4aXN0IG9uIHRoZSBET00gYmVmb3JlIGl0cyBwb3NpdGlvbiBjYW4gYmVcbiAgICAvLyB1cGRhdGVkIGFzIFBvcHBlciBuZWVkcyB0byByZWFkIGl0cyBkaW1lbnNpb25zXG5cblxuICAgIGlmICghcGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpKSB7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHBvcHBlcik7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5IGNoZWNrXG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhcHBlbmRUbyA9PT0gZGVmYXVsdFByb3BzLmFwcGVuZFRvICYmIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICE9PSBwb3BwZXIsIFsnSW50ZXJhY3RpdmUgdGlwcHkgZWxlbWVudCBtYXkgbm90IGJlIGFjY2Vzc2libGUgdmlhIGtleWJvYXJkJywgJ25hdmlnYXRpb24gYmVjYXVzZSBpdCBpcyBub3QgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50JywgJ2luIHRoZSBET00gc291cmNlIG9yZGVyLicsICdcXG5cXG4nLCAnVXNpbmcgYSB3cmFwcGVyIDxkaXY+IG9yIDxzcGFuPiB0YWcgYXJvdW5kIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsICdzb2x2ZXMgdGhpcyBieSBjcmVhdGluZyBhIG5ldyBwYXJlbnROb2RlIGNvbnRleHQuJywgJ1xcblxcbicsICdTcGVjaWZ5aW5nIGBhcHBlbmRUbzogZG9jdW1lbnQuYm9keWAgc2lsZW5jZXMgdGhpcyB3YXJuaW5nLCBidXQgaXQnLCAnYXNzdW1lcyB5b3UgYXJlIHVzaW5nIGEgZm9jdXMgbWFuYWdlbWVudCBzb2x1dGlvbiB0byBoYW5kbGUnLCAna2V5Ym9hcmQgbmF2aWdhdGlvbi4nLCAnXFxuXFxuJywgJ1NlZTogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FjY2Vzc2liaWxpdHkvI2ludGVyYWN0aXZpdHknXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFBvcHBlclRyZWUoKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbShwb3BwZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGlwcHktcm9vdF0nKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVNob3coZXZlbnQpIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgaW52b2tlSG9vaygnb25UcmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50UHJlc3MoKTtcbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheSh0cnVlKTtcblxuICAgIHZhciBfZ2V0Tm9ybWFsaXplZFRvdWNoU2UgPSBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpLFxuICAgICAgICB0b3VjaFZhbHVlID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzBdLFxuICAgICAgICB0b3VjaERlbGF5ID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzFdO1xuXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmIHRvdWNoVmFsdWUgPT09ICdob2xkJyAmJiB0b3VjaERlbGF5KSB7XG4gICAgICBkZWxheSA9IHRvdWNoRGVsYXk7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBzaG93VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUhpZGUoZXZlbnQpIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnZva2VIb29rKCdvblVudHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgc2NoZWR1bGVIaWRlIGlzIGFkZGVkIHRvIGEgZG9jdW1lbnQuYm9keSBoYW5kbGVyXG4gICAgLy8gZnJvbSBvbk1vdXNlTGVhdmUgc28gbXVzdCBpbnRlcmNlcHQgc2NoZWR1bGVkIGhpZGVzIGZyb20gbW91c2Vtb3ZlL2xlYXZlXG4gICAgLy8gZXZlbnRzIHdoZW4gdHJpZ2dlciBjb250YWlucyBtb3VzZWVudGVyIGFuZCBjbGljaywgYW5kIHRoZSB0aXAgaXNcbiAgICAvLyBjdXJyZW50bHkgc2hvd24gYXMgYSByZXN1bHQgb2YgYSBjbGljay5cblxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDAgJiYgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiYgWydtb3VzZWxlYXZlJywgJ21vdXNlbW92ZSddLmluZGV4T2YoZXZlbnQudHlwZSkgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheShmYWxzZSk7XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRml4ZXMgYSBgdHJhbnNpdGlvbmVuZGAgcHJvYmxlbSB3aGVuIGl0IGZpcmVzIDEgZnJhbWUgdG9vXG4gICAgICAvLyBsYXRlIHNvbWV0aW1lcywgd2UgZG9uJ3Qgd2FudCBoaWRlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgLy8gRGlzYWJsaW5nIHRoZSBpbnN0YW5jZSBzaG91bGQgYWxzbyBoaWRlIGl0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHkuanMtcmVhY3QvaXNzdWVzLzEwNlxuICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lb3V0cygpIHtcbiAgICBjbGVhclRpbWVvdXQoc2hvd1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dChoaWRlVGltZW91dCk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcHMocGFydGlhbFByb3BzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3NldFByb3BzJykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQmVmb3JlVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB2YXIgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBPYmplY3QuYXNzaWduKHt9LCBwcmV2UHJvcHMsIHJlbW92ZVVuZGVmaW5lZFByb3BzKHBhcnRpYWxQcm9wcyksIHtcbiAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KSk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAocHJldlByb3BzLmludGVyYWN0aXZlRGVib3VuY2UgIT09IG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICAgIH0gLy8gRW5zdXJlIHN0YWxlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlcyBhcmUgcmVtb3ZlZFxuXG5cbiAgICBpZiAocHJldlByb3BzLnRyaWdnZXJUYXJnZXQgJiYgIW5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICBub3JtYWxpemVUb0FycmF5KHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICByZWZlcmVuY2UucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7IC8vIEZpeGVzIGFuIGlzc3VlIHdpdGggbmVzdGVkIHRpcHBpZXMgaWYgdGhleSBhcmUgYWxsIGdldHRpbmcgcmUtcmVuZGVyZWQsXG4gICAgICAvLyBhbmQgdGhlIG5lc3RlZCBvbmVzIGdldCByZS1yZW5kZXJlZCBmaXJzdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5anMtcmVhY3QvaXNzdWVzLzE3N1xuICAgICAgLy8gVE9ETzogZmluZCBhIGNsZWFuZXIgLyBtb3JlIGVmZmljaWVudCBzb2x1dGlvbighKVxuXG4gICAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkUG9wcGVyKSB7XG4gICAgICAgIC8vIFJlYWN0IChhbmQgb3RoZXIgVUkgbGlicyBsaWtlbHkpIHJlcXVpcmVzIGEgckFGIHdyYXBwZXIgYXMgaXQgZmx1c2hlc1xuICAgICAgICAvLyBpdHMgd29yayBpbiBvbmVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5lc3RlZFBvcHBlci5fdGlwcHkucG9wcGVySW5zdGFuY2UuZm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzaG93JykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeVZpc2libGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCA9IGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmICFpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICB2YXIgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbiwgMCwgZGVmYXVsdFByb3BzLmR1cmF0aW9uKTtcblxuICAgIGlmIChpc0FscmVhZHlWaXNpYmxlIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQgfHwgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE5vcm1hbGl6ZSBgZGlzYWJsZWRgIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAvLyBGaXJlZm94IGFsbG93cyBldmVudHMgb24gZGlzYWJsZWQgZWxlbWVudHMsIGJ1dCBDaHJvbWUgZG9lc24ndC5cbiAgICAvLyBVc2luZyBhIHdyYXBwZXIgZWxlbWVudCAoaS5lLiA8c3Bhbj4pIGlzIHJlY29tbWVuZGVkLlxuXG5cbiAgICBpZiAoZ2V0Q3VycmVudFRhcmdldCgpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uU2hvdycsIFtpbnN0YW5jZV0sIGZhbHNlKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vblNob3coaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IHRydWU7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgaGFuZGxlU3R5bGVzKCk7XG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIH0gLy8gSWYgZmxpcHBpbmcgdG8gdGhlIG9wcG9zaXRlIHNpZGUgYWZ0ZXIgaGlkaW5nIGF0IGxlYXN0IG9uY2UsIHRoZVxuICAgIC8vIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgd3JvbmcgcGxhY2VtZW50IHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBkdXJhdGlvblxuXG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDIgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDIuYm94LFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gyLmNvbnRlbnQ7XG5cbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgMCk7XG4gICAgfVxuXG4gICAgb25GaXJzdFVwZGF0ZSA9IGZ1bmN0aW9uIG9uRmlyc3RVcGRhdGUoKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHBvcHBlckluc3RhMjtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgfHwgaWdub3JlT25GaXJzdFVwZGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSB0cnVlOyAvLyByZWZsb3dcblxuICAgICAgdm9pZCBwb3BwZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSBpbnN0YW5jZS5wcm9wcy5tb3ZlVHJhbnNpdGlvbjtcblxuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkgJiYgaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gzID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICAgIF9ib3ggPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gzLmJveCxcbiAgICAgICAgICAgIF9jb250ZW50ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMy5jb250ZW50O1xuXG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbX2JveCwgX2NvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbX2JveCwgX2NvbnRlbnRdLCAndmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgICBwdXNoSWZVbmlxdWUobW91bnRlZEluc3RhbmNlcywgaW5zdGFuY2UpOyAvLyBjZXJ0YWluIG1vZGlmaWVycyAoZS5nLiBgbWF4U2l6ZWApIHJlcXVpcmUgYSBzZWNvbmQgdXBkYXRlIGFmdGVyIHRoZVxuICAgICAgLy8gcG9wcGVyIGhhcyBiZWVuIHBvc2l0aW9uZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG5cbiAgICAgIChfaW5zdGFuY2UkcG9wcGVySW5zdGEyID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkcG9wcGVySW5zdGEyLmZvcmNlVXBkYXRlKCk7XG4gICAgICBpbnZva2VIb29rKCdvbk1vdW50JywgW2luc3RhbmNlXSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24gJiYgZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW91bnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGUnKSk7XG4gICAgfSAvLyBFYXJseSBiYWlsLW91dFxuXG5cbiAgICB2YXIgaXNBbHJlYWR5SGlkZGVuID0gIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDEsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG5cbiAgICBpZiAoaXNBbHJlYWR5SGlkZGVuIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkhpZGUnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25IaWRlKGluc3RhbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gZmFsc2U7XG4gICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgaGFuZGxlU3R5bGVzKHRydWUpO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHZhciBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICBib3ggPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0LmJveCxcbiAgICAgICAgICBjb250ZW50ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoNC5jb250ZW50O1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JveCwgY29udGVudF0sICdoaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGluc3RhbmNlLnVubW91bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGVXaXRoSW50ZXJhY3Rpdml0eScpKTtcbiAgICB9XG5cbiAgICBnZXREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBwdXNoSWZVbmlxdWUobW91c2VNb3ZlTGlzdGVuZXJzLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgZGVib3VuY2VkT25Nb3VzZU1vdmUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygndW5tb3VudCcpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTsgLy8gSWYgYSBwb3BwZXIgaXMgbm90IGludGVyYWN0aXZlLCBpdCB3aWxsIGJlIGFwcGVuZGVkIG91dHNpZGUgdGhlIHBvcHBlclxuICAgIC8vIHRyZWUgYnkgZGVmYXVsdC4gVGhpcyBzZWVtcyBtYWlubHkgZm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIGJ1dCB3ZSBzaG91bGRcbiAgICAvLyBmaW5kIGEgd29ya2Fyb3VuZCBpZiBwb3NzaWJsZVxuXG4gICAgZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZFBvcHBlcikge1xuICAgICAgbmVzdGVkUG9wcGVyLl90aXBweS51bm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICBpZiAocG9wcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHBlcik7XG4gICAgfVxuXG4gICAgbW91bnRlZEluc3RhbmNlcyA9IG1vdW50ZWRJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaSAhPT0gaW5zdGFuY2U7XG4gICAgfSk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgaW52b2tlSG9vaygnb25IaWRkZW4nLCBbaW5zdGFuY2VdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2Rlc3Ryb3knKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW5zdGFuY2UudW5tb3VudCgpO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIGRlbGV0ZSByZWZlcmVuY2UuX3RpcHB5O1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpbnZva2VIb29rKCdvbkRlc3Ryb3knLCBbaW5zdGFuY2VdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aXBweSh0YXJnZXRzLCBvcHRpb25hbFByb3BzKSB7XG4gIGlmIChvcHRpb25hbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFByb3BzID0ge307XG4gIH1cblxuICB2YXIgcGx1Z2lucyA9IGRlZmF1bHRQcm9wcy5wbHVnaW5zLmNvbmNhdChvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgW10pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cyk7XG4gICAgdmFsaWRhdGVQcm9wcyhvcHRpb25hbFByb3BzLCBwbHVnaW5zKTtcbiAgfVxuXG4gIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpO1xuICB2YXIgcGFzc2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25hbFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KTtcbiAgdmFyIGVsZW1lbnRzID0gZ2V0QXJyYXlPZkVsZW1lbnRzKHRhcmdldHMpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgaXNTaW5nbGVDb250ZW50RWxlbWVudCA9IGlzRWxlbWVudChwYXNzZWRQcm9wcy5jb250ZW50KTtcbiAgICB2YXIgaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQgPSBlbGVtZW50cy5sZW5ndGggPiAxO1xuICAgIHdhcm5XaGVuKGlzU2luZ2xlQ29udGVudEVsZW1lbnQgJiYgaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQsIFsndGlwcHkoKSB3YXMgcGFzc2VkIGFuIEVsZW1lbnQgYXMgdGhlIGBjb250ZW50YCBwcm9wLCBidXQgbW9yZSB0aGFuJywgJ29uZSB0aXBweSBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSB0aGlzIGludm9jYXRpb24uIFRoaXMgbWVhbnMgdGhlJywgJ2NvbnRlbnQgZWxlbWVudCB3aWxsIG9ubHkgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgdGlwcHkgaW5zdGFuY2UuJywgJ1xcblxcbicsICdJbnN0ZWFkLCBwYXNzIHRoZSAuaW5uZXJIVE1MIG9mIHRoZSBlbGVtZW50LCBvciB1c2UgYSBmdW5jdGlvbiB0aGF0JywgJ3JldHVybnMgYSBjbG9uZWQgdmVyc2lvbiBvZiB0aGUgZWxlbWVudCBpbnN0ZWFkLicsICdcXG5cXG4nLCAnMSkgY29udGVudDogZWxlbWVudC5pbm5lckhUTUxcXG4nLCAnMikgY29udGVudDogKCkgPT4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSknXS5qb2luKCcgJykpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlcyA9IGVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCByZWZlcmVuY2UpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSByZWZlcmVuY2UgJiYgY3JlYXRlVGlwcHkocmVmZXJlbmNlLCBwYXNzZWRQcm9wcyk7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGFjYy5wdXNoKGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiBpc0VsZW1lbnQodGFyZ2V0cykgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG59XG5cbnRpcHB5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbnRpcHB5LnNldERlZmF1bHRQcm9wcyA9IHNldERlZmF1bHRQcm9wcztcbnRpcHB5LmN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dDtcbnZhciBoaWRlQWxsID0gZnVuY3Rpb24gaGlkZUFsbChfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlID0gX3JlZi5leGNsdWRlLFxuICAgICAgZHVyYXRpb24gPSBfcmVmLmR1cmF0aW9uO1xuXG4gIG1vdW50ZWRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgaXNFeGNsdWRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkge1xuICAgICAgaXNFeGNsdWRlZCA9IGlzUmVmZXJlbmNlRWxlbWVudChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UpID8gaW5zdGFuY2UucmVmZXJlbmNlID09PSBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgOiBpbnN0YW5jZS5wb3BwZXIgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZS5wb3BwZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpc0V4Y2x1ZGVkKSB7XG4gICAgICB2YXIgb3JpZ2luYWxEdXJhdGlvbiA9IGluc3RhbmNlLnByb3BzLmR1cmF0aW9uO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICAgIH0pO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICBkdXJhdGlvbjogb3JpZ2luYWxEdXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gZXZlcnkgdGltZSB0aGUgcG9wcGVyIGlzIGRlc3Ryb3llZCAoaS5lLiBhIG5ldyB0YXJnZXQpLCByZW1vdmluZyB0aGUgc3R5bGVzXG4vLyBhbmQgY2F1c2luZyB0cmFuc2l0aW9ucyB0byBicmVhayBmb3Igc2luZ2xldG9ucyB3aGVuIHRoZSBjb25zb2xlIGlzIG9wZW4sIGJ1dFxuLy8gbW9zdCBub3RhYmx5IGZvciBub24tdHJhbnNmb3JtIHN0eWxlcyBiZWluZyB1c2VkLCBgZ3B1QWNjZWxlcmF0aW9uOiBmYWxzZWAuXG5cbnZhciBhcHBseVN0eWxlc01vZGlmaWVyID0gT2JqZWN0LmFzc2lnbih7fSwgYXBwbHlTdHlsZXMsIHtcbiAgZWZmZWN0OiBmdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gICAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3BwZXI6IHtcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgIG1hcmdpbjogJzAnXG4gICAgICB9LFxuICAgICAgYXJyb3c6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH0sXG4gICAgICByZWZlcmVuY2U6IHt9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICAgIH0gLy8gaW50ZW50aW9uYWxseSByZXR1cm4gbm8gY2xlYW51cCBmdW5jdGlvblxuICAgIC8vIHJldHVybiAoKSA9PiB7IC4uLiB9XG5cbiAgfVxufSk7XG5cbnZhciBjcmVhdGVTaW5nbGV0b24gPSBmdW5jdGlvbiBjcmVhdGVTaW5nbGV0b24odGlwcHlJbnN0YW5jZXMsIG9wdGlvbmFsUHJvcHMpIHtcbiAgdmFyIF9vcHRpb25hbFByb3BzJHBvcHBlcjtcblxuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9yV2hlbighQXJyYXkuaXNBcnJheSh0aXBweUluc3RhbmNlcyksIFsnVGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTaW5nbGV0b24oKSBtdXN0IGJlIGFuIGFycmF5IG9mJywgJ3RpcHB5IGluc3RhbmNlcy4gVGhlIHBhc3NlZCB2YWx1ZSB3YXMnLCBTdHJpbmcodGlwcHlJbnN0YW5jZXMpXS5qb2luKCcgJykpO1xuICB9XG5cbiAgdmFyIGluZGl2aWR1YWxJbnN0YW5jZXMgPSB0aXBweUluc3RhbmNlcztcbiAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgdmFyIHRyaWdnZXJUYXJnZXRzID0gW107XG4gIHZhciBjdXJyZW50VGFyZ2V0O1xuICB2YXIgb3ZlcnJpZGVzID0gb3B0aW9uYWxQcm9wcy5vdmVycmlkZXM7XG4gIHZhciBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gW107XG4gIHZhciBzaG93bk9uQ3JlYXRlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0VHJpZ2dlclRhcmdldHMoKSB7XG4gICAgdHJpZ2dlclRhcmdldHMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgaW5zdGFuY2UucmVmZXJlbmNlKTtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoaXRlbSk7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UmVmZXJlbmNlcygpIHtcbiAgICByZWZlcmVuY2VzID0gaW5kaXZpZHVhbEluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5hYmxlSW5zdGFuY2VzKGlzRW5hYmxlZCkge1xuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b24pIHtcbiAgICByZXR1cm4gaW5kaXZpZHVhbEluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxTZXRQcm9wcyA9IGluc3RhbmNlLnNldFByb3BzO1xuXG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBvcmlnaW5hbFNldFByb3BzKHByb3BzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UucmVmZXJlbmNlID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgc2luZ2xldG9uLnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMgPSBvcmlnaW5hbFNldFByb3BzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSAvLyBoYXZlIHRvIHBhc3Mgc2luZ2xldG9uLCBhcyBpdCBtYXliZSB1bmRlZmluZWQgb24gZmlyc3QgY2FsbFxuXG5cbiAgZnVuY3Rpb24gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgdGFyZ2V0KSB7XG4gICAgdmFyIGluZGV4ID0gdHJpZ2dlclRhcmdldHMuaW5kZXhPZih0YXJnZXQpOyAvLyBiYWlsLW91dFxuXG4gICAgaWYgKHRhcmdldCA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdmFyIG92ZXJyaWRlUHJvcHMgPSAob3ZlcnJpZGVzIHx8IFtdKS5jb25jYXQoJ2NvbnRlbnQnKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgYWNjW3Byb3BdID0gaW5kaXZpZHVhbEluc3RhbmNlc1tpbmRleF0ucHJvcHNbcHJvcF07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBzaW5nbGV0b24uc2V0UHJvcHMoT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVQcm9wcywge1xuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogdHlwZW9mIG92ZXJyaWRlUHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyA/IG92ZXJyaWRlUHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWZlcmVuY2VzJGluZGV4O1xuXG4gICAgICAgIHJldHVybiAoX3JlZmVyZW5jZXMkaW5kZXggPSByZWZlcmVuY2VzW2luZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWZlcmVuY2VzJGluZGV4LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gIHNldFJlZmVyZW5jZXMoKTtcbiAgc2V0VHJpZ2dlclRhcmdldHMoKTtcbiAgdmFyIHBsdWdpbiA9IHtcbiAgICBmbjogZnVuY3Rpb24gZm4oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgICAgICBlbmFibGVJbnN0YW5jZXModHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGlja091dHNpZGU6IGZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnNob3dPbkNyZWF0ZSAmJiAhc2hvd25PbkNyZWF0ZSkge1xuICAgICAgICAgICAgc2hvd25PbkNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnNob3dPbkNyZWF0ZSAmJiAhc2hvd25PbkNyZWF0ZSkge1xuICAgICAgICAgICAgc2hvd25PbkNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIHJlZmVyZW5jZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoaW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgICAgICAgcHJlcGFyZUluc3RhbmNlKGluc3RhbmNlLCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHZhciBzaW5nbGV0b24gPSB0aXBweShkaXYoKSwgT2JqZWN0LmFzc2lnbih7fSwgcmVtb3ZlUHJvcGVydGllcyhvcHRpb25hbFByb3BzLCBbJ292ZXJyaWRlcyddKSwge1xuICAgIHBsdWdpbnM6IFtwbHVnaW5dLmNvbmNhdChvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgW10pLFxuICAgIHRyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzLFxuICAgIHBvcHBlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucywge1xuICAgICAgbW9kaWZpZXJzOiBbXS5jb25jYXQoKChfb3B0aW9uYWxQcm9wcyRwb3BwZXIgPSBvcHRpb25hbFByb3BzLnBvcHBlck9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9uYWxQcm9wcyRwb3BwZXIubW9kaWZpZXJzKSB8fCBbXSwgW2FwcGx5U3R5bGVzTW9kaWZpZXJdKVxuICAgIH0pXG4gIH0pKTtcbiAgdmFyIG9yaWdpbmFsU2hvdyA9IHNpbmdsZXRvbi5zaG93O1xuXG4gIHNpbmdsZXRvbi5zaG93ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIG9yaWdpbmFsU2hvdygpOyAvLyBmaXJzdCB0aW1lLCBzaG93T25DcmVhdGUgb3IgcHJvZ3JhbW1hdGljIGNhbGwgd2l0aCBubyBwYXJhbXNcbiAgICAvLyBkZWZhdWx0IHRvIHNob3dpbmcgZmlyc3QgaW5zdGFuY2VcblxuICAgIGlmICghY3VycmVudFRhcmdldCAmJiB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZmVyZW5jZXNbMF0pO1xuICAgIH0gLy8gdHJpZ2dlcmVkIGZyb20gZXZlbnQgKGRvIG5vdGhpbmcgYXMgcHJlcGFyZUluc3RhbmNlIGFscmVhZHkgY2FsbGVkIGJ5IG9uVHJpZ2dlcilcbiAgICAvLyBwcm9ncmFtbWF0aWMgY2FsbCB3aXRoIG5vIHBhcmFtcyB3aGVuIGFscmVhZHkgdmlzaWJsZSAoZG8gbm90aGluZyBhZ2FpbilcblxuXG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHRhcmdldCBpcyBpbmRleCBvZiBpbnN0YW5jZVxuXG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByZWZlcmVuY2VzW3RhcmdldF0gJiYgcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1t0YXJnZXRdKTtcbiAgICB9IC8vIHRhcmdldCBpcyBhIGNoaWxkIHRpcHB5IGluc3RhbmNlXG5cblxuICAgIGlmIChpbmRpdmlkdWFsSW5zdGFuY2VzLmluZGV4T2YodGFyZ2V0KSA+PSAwKSB7XG4gICAgICB2YXIgcmVmID0gdGFyZ2V0LnJlZmVyZW5jZTtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWYpO1xuICAgIH0gLy8gdGFyZ2V0IGlzIGEgUmVmZXJlbmNlRWxlbWVudFxuXG5cbiAgICBpZiAocmVmZXJlbmNlcy5pbmRleE9mKHRhcmdldCkgPj0gMCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHRhcmdldCk7XG4gICAgfVxuICB9O1xuXG4gIHNpbmdsZXRvbi5zaG93TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlyc3QgPSByZWZlcmVuY2VzWzBdO1xuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3coMCk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIHNpbmdsZXRvbi5zaG93KHJlZmVyZW5jZXNbaW5kZXggKyAxXSB8fCBmaXJzdCk7XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dQcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IHJlZmVyZW5jZXNbcmVmZXJlbmNlcy5sZW5ndGggLSAxXTtcblxuICAgIGlmICghY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbi5zaG93KGxhc3QpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHJlZmVyZW5jZXMuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0ID0gcmVmZXJlbmNlc1tpbmRleCAtIDFdIHx8IGxhc3Q7XG4gICAgc2luZ2xldG9uLnNob3codGFyZ2V0KTtcbiAgfTtcblxuICB2YXIgb3JpZ2luYWxTZXRQcm9wcyA9IHNpbmdsZXRvbi5zZXRQcm9wcztcblxuICBzaW5nbGV0b24uc2V0UHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBvdmVycmlkZXMgPSBwcm9wcy5vdmVycmlkZXMgfHwgb3ZlcnJpZGVzO1xuICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuICB9O1xuXG4gIHNpbmdsZXRvbi5zZXRJbnN0YW5jZXMgPSBmdW5jdGlvbiAobmV4dEluc3RhbmNlcykge1xuICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9KTtcbiAgICBpbmRpdmlkdWFsSW5zdGFuY2VzID0gbmV4dEluc3RhbmNlcztcbiAgICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICAgIHNldFJlZmVyZW5jZXMoKTtcbiAgICBzZXRUcmlnZ2VyVGFyZ2V0cygpO1xuICAgIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b24pO1xuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyh7XG4gICAgICB0cmlnZ2VyVGFyZ2V0OiB0cmlnZ2VyVGFyZ2V0c1xuICAgIH0pO1xuICB9O1xuXG4gIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b24pO1xuICByZXR1cm4gc2luZ2xldG9uO1xufTtcblxudmFyIEJVQkJMSU5HX0VWRU5UU19NQVAgPSB7XG4gIG1vdXNlb3ZlcjogJ21vdXNlZW50ZXInLFxuICBmb2N1c2luOiAnZm9jdXMnLFxuICBjbGljazogJ2NsaWNrJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRlbGVnYXRlIGluc3RhbmNlIHRoYXQgY29udHJvbHMgdGhlIGNyZWF0aW9uIG9mIHRpcHB5IGluc3RhbmNlc1xuICogZm9yIGNoaWxkIGVsZW1lbnRzIChgdGFyZ2V0YCBDU1Mgc2VsZWN0b3IpLlxuICovXG5cbmZ1bmN0aW9uIGRlbGVnYXRlKHRhcmdldHMsIHByb3BzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIShwcm9wcyAmJiBwcm9wcy50YXJnZXQpLCBbJ1lvdSBtdXN0IHNwZWNpdHkgYSBgdGFyZ2V0YCBwcm9wIGluZGljYXRpbmcgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nJywgJ3RoZSB0YXJnZXQgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVjZWl2ZSBhIHRpcHB5LiddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBjaGlsZFRpcHB5SW5zdGFuY2VzID0gW107XG4gIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICB2YXIgbmF0aXZlUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKHByb3BzLCBbJ3RhcmdldCddKTtcbiAgdmFyIHBhcmVudFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbmF0aXZlUHJvcHMsIHtcbiAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICB0b3VjaDogZmFsc2VcbiAgfSk7XG4gIHZhciBjaGlsZFByb3BzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdG91Y2g6IGRlZmF1bHRQcm9wcy50b3VjaFxuICB9LCBuYXRpdmVQcm9wcywge1xuICAgIHNob3dPbkNyZWF0ZTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJldHVyblZhbHVlID0gdGlwcHkodGFyZ2V0cywgcGFyZW50UHJvcHMpO1xuICB2YXIgbm9ybWFsaXplZFJldHVyblZhbHVlID0gbm9ybWFsaXplVG9BcnJheShyZXR1cm5WYWx1ZSk7XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQgfHwgZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KHRhcmdldCk7XG5cbiAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuXG5cbiAgICB2YXIgdHJpZ2dlciA9IHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXRyaWdnZXInKSB8fCBwcm9wcy50cmlnZ2VyIHx8IGRlZmF1bHRQcm9wcy50cmlnZ2VyOyAvLyBAdHMtaWdub3JlXG5cbiAgICBpZiAodGFyZ2V0Tm9kZS5fdGlwcHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIHR5cGVvZiBjaGlsZFByb3BzLnRvdWNoID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ3RvdWNoc3RhcnQnICYmIHRyaWdnZXIuaW5kZXhPZihCVUJCTElOR19FVkVOVFNfTUFQW2V2ZW50LnR5cGVdKSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB0aXBweSh0YXJnZXROb2RlLCBjaGlsZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IGNoaWxkVGlwcHlJbnN0YW5jZXMuY29uY2F0KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbihub2RlLCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICBvbihyZWZlcmVuY2UsICd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCBUT1VDSF9PUFRJT05TKTtcbiAgICBvbihyZWZlcmVuY2UsICdtb3VzZW92ZXInLCBvblRyaWdnZXIpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ2ZvY3VzaW4nLCBvblRyaWdnZXIpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ2NsaWNrJywgb25UcmlnZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICBldmVudFR5cGUgPSBfcmVmLmV2ZW50VHlwZSxcbiAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25zKGluc3RhbmNlKSB7XG4gICAgdmFyIG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgdmFyIG9yaWdpbmFsRW5hYmxlID0gaW5zdGFuY2UuZW5hYmxlO1xuICAgIHZhciBvcmlnaW5hbERpc2FibGUgPSBpbnN0YW5jZS5kaXNhYmxlO1xuXG4gICAgaW5zdGFuY2UuZGVzdHJveSA9IGZ1bmN0aW9uIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gW107XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGluc3RhbmNlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9yaWdpbmFsRW5hYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5lbmFibGUoKTtcbiAgICAgIH0pO1xuICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9yaWdpbmFsRGlzYWJsZSgpO1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZGlzYWJsZSgpO1xuICAgICAgfSk7XG4gICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKGluc3RhbmNlKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZS5mb3JFYWNoKGFwcGx5TXV0YXRpb25zKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG52YXIgYW5pbWF0ZUZpbGwgPSB7XG4gIG5hbWU6ICdhbmltYXRlRmlsbCcsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMkcmVuZGU7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCEoKF9pbnN0YW5jZSRwcm9wcyRyZW5kZSA9IGluc3RhbmNlLnByb3BzLnJlbmRlcikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcHJvcHMkcmVuZGUuJCR0aXBweSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3JXaGVuKGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsLCAnVGhlIGBhbmltYXRlRmlsbGAgcGx1Z2luIHJlcXVpcmVzIHRoZSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBfZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnN0YW5jZS5wb3BwZXIpLFxuICAgICAgICBib3ggPSBfZ2V0Q2hpbGRyZW4uYm94LFxuICAgICAgICBjb250ZW50ID0gX2dldENoaWxkcmVuLmNvbnRlbnQ7XG5cbiAgICB2YXIgYmFja2Ryb3AgPSBpbnN0YW5jZS5wcm9wcy5hbmltYXRlRmlsbCA/IGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBib3guaW5zZXJ0QmVmb3JlKGJhY2tkcm9wLCBib3guZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0ZWZpbGwnLCAnJyk7XG4gICAgICAgICAgYm94LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgYXJyb3c6IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiAnc2hpZnQtYXdheSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBib3guc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcih0cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgnbXMnLCAnJykpOyAvLyBUaGUgY29udGVudCBzaG91bGQgZmFkZSBpbiBhZnRlciB0aGUgYmFja2Ryb3AgaGFzIG1vc3RseSBmaWxsZWQgdGhlXG4gICAgICAgICAgLy8gdG9vbHRpcCBlbGVtZW50LiBgY2xpcC1wYXRoYCBpcyB0aGUgb3RoZXIgYWx0ZXJuYXRpdmUgYnV0IGlzIG5vdFxuICAgICAgICAgIC8vIHdlbGwtc3VwcG9ydGVkIGFuZCBpcyBidWdneSBvbiBzb21lIGRldmljZXMuXG5cbiAgICAgICAgICBjb250ZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IE1hdGgucm91bmQoZHVyYXRpb24gLyAxMCkgKyBcIm1zXCI7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAndmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZHJvcEVsZW1lbnQoKSB7XG4gIHZhciBiYWNrZHJvcCA9IGRpdigpO1xuICBiYWNrZHJvcC5jbGFzc05hbWUgPSBCQUNLRFJPUF9DTEFTUztcbiAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgcmV0dXJuIGJhY2tkcm9wO1xufVxuXG52YXIgbW91c2VDb29yZHMgPSB7XG4gIGNsaWVudFg6IDAsXG4gIGNsaWVudFk6IDBcbn07XG52YXIgYWN0aXZlSW5zdGFuY2VzID0gW107XG5cbmZ1bmN0aW9uIHN0b3JlTW91c2VDb29yZHMoX3JlZikge1xuICB2YXIgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG4gIG1vdXNlQ29vcmRzID0ge1xuICAgIGNsaWVudFg6IGNsaWVudFgsXG4gICAgY2xpZW50WTogY2xpZW50WVxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYykge1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKSB7XG4gIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdG9yZU1vdXNlQ29vcmRzKTtcbn1cblxudmFyIGZvbGxvd0N1cnNvciA9IHtcbiAgbmFtZTogJ2ZvbGxvd0N1cnNvcicsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgdmFyIGRvYyA9IGdldE93bmVyRG9jdW1lbnQoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIHZhciBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgdmFyIHdhc0ZvY3VzRXZlbnQgPSBmYWxzZTtcbiAgICB2YXIgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGZ1bmN0aW9uIGdldElzSW5pdGlhbEJlaGF2aW9yKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcigpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGlzIGludGVyYWN0aXZlLCBhdm9pZCB1cGRhdGluZyB0aGUgcG9zaXRpb24gdW5sZXNzIGl0J3NcbiAgICAgIC8vIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICB2YXIgaXNDdXJzb3JPdmVyUmVmZXJlbmNlID0gZXZlbnQudGFyZ2V0ID8gcmVmZXJlbmNlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgOiB0cnVlO1xuICAgICAgdmFyIGZvbGxvd0N1cnNvciA9IGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcjtcbiAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHZhciByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHJlbGF0aXZlWCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICB2YXIgcmVsYXRpdmVZID0gY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICBpZiAoaXNDdXJzb3JPdmVyUmVmZXJlbmNlIHx8ICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVubmVlZGVkIERPTVJlY3QgcHJvcGVydGllc1xuICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IGZ1bmN0aW9uIGdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB4ID0gY2xpZW50WDtcbiAgICAgICAgICAgIHZhciB5ID0gY2xpZW50WTtcblxuICAgICAgICAgICAgaWYgKGZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LmxlZnQgKyByZWxhdGl2ZVg7XG4gICAgICAgICAgICAgIHkgPSByZWN0LnRvcCArIHJlbGF0aXZlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvcCA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnID8gcmVjdC50b3AgOiB5O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5yaWdodCA6IHg7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LmJvdHRvbSA6IHk7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QubGVmdCA6IHg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcCxcbiAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgZG9jOiBkb2NcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgYWN0aXZlSW5zdGFuY2VzID0gYWN0aXZlSW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5pbnN0YW5jZSAhPT0gaW5zdGFuY2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuZG9jID09PSBkb2M7XG4gICAgICB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogY3JlYXRlLFxuICAgICAgb25EZXN0cm95OiBkZXN0cm95LFxuICAgICAgb25CZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIG9uQmVmb3JlVXBkYXRlKCkge1xuICAgICAgICBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIH0sXG4gICAgICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKF8sIF9yZWYyKSB7XG4gICAgICAgIHZhciBmb2xsb3dDdXJzb3IgPSBfcmVmMi5mb2xsb3dDdXJzb3I7XG5cbiAgICAgICAgaWYgKGlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9sbG93Q3Vyc29yICE9PSB1bmRlZmluZWQgJiYgcHJldlByb3BzLmZvbGxvd0N1cnNvciAhPT0gZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuXG4gICAgICAgICAgaWYgKGZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgY3JlYXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiYgIXdhc0ZvY3VzRXZlbnQgJiYgIWdldElzSW5pdGlhbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgJiYgIXdhc0ZvY3VzRXZlbnQpIHtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKG1vdXNlQ29vcmRzKTtcbiAgICAgICAgICAgIGlzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFnZXRJc0luaXRpYWxCZWhhdmlvcigpKSB7XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKF8sIGV2ZW50KSB7XG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgbW91c2VDb29yZHMgPSB7XG4gICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB3YXNGb2N1c0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKTtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgIGlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFByb3BzKHByb3BzLCBtb2RpZmllcikge1xuICB2YXIgX3Byb3BzJHBvcHBlck9wdGlvbnM7XG5cbiAgcmV0dXJuIHtcbiAgICBwb3BwZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wb3BwZXJPcHRpb25zLCB7XG4gICAgICBtb2RpZmllcnM6IFtdLmNvbmNhdCgoKChfcHJvcHMkcG9wcGVyT3B0aW9ucyA9IHByb3BzLnBvcHBlck9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBtb2RpZmllci5uYW1lO1xuICAgICAgfSksIFttb2RpZmllcl0pXG4gICAgfSlcbiAgfTtcbn1cblxudmFyIGlubGluZVBvc2l0aW9uaW5nID0ge1xuICBuYW1lOiAnaW5saW5lUG9zaXRpb25pbmcnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuXG4gICAgZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMuaW5saW5lUG9zaXRpb25pbmc7XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlbWVudDtcbiAgICB2YXIgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgdmFyIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB2YXIgdHJpZWRQbGFjZW1lbnRzID0gW107XG4gICAgdmFyIG1vZGlmaWVyID0ge1xuICAgICAgbmFtZTogJ3RpcHB5SW5saW5lUG9zaXRpb25pbmcnLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICBmbjogZnVuY3Rpb24gZm4oX3JlZjIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG5cbiAgICAgICAgaWYgKGlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgaWYgKHRyaWVkUGxhY2VtZW50cy5pbmRleE9mKHN0YXRlLnBsYWNlbWVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSBzdGF0ZS5wbGFjZW1lbnQgJiYgdHJpZWRQbGFjZW1lbnRzLmluZGV4T2Yoc3RhdGUucGxhY2VtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cy5wdXNoKHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB1bm5lZWRlZCBET01SZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFJlZmVyZW5jZUNsaWVudFJlY3Qoc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGxhY2VtZW50ID0gc3RhdGUucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9nZXRSZWZlcmVuY2VDbGllbnRSZWN0KHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCksIHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYXJyYXlGcm9tKHJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKSwgY3Vyc29yUmVjdEluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJbnRlcm5hbFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyhwYXJ0aWFsUHJvcHMpO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE1vZGlmaWVyKCkge1xuICAgICAgaWYgKCFpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgIHNldEludGVybmFsUHJvcHMoZ2V0UHJvcHMoaW5zdGFuY2UucHJvcHMsIG1vZGlmaWVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICB2YXIgcmVjdHMgPSBhcnJheUZyb20oaW5zdGFuY2UucmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgICAgIHZhciBjdXJzb3JSZWN0ID0gcmVjdHMuZmluZChmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QubGVmdCAtIDIgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ICsgMiA+PSBldmVudC5jbGllbnRYICYmIHJlY3QudG9wIC0gMiA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tICsgMiA+PSBldmVudC5jbGllbnRZO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbmRleCA9IHJlY3RzLmluZGV4T2YoY3Vyc29yUmVjdCk7XG4gICAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gaW5kZXggPiAtMSA/IGluZGV4IDogY3Vyc29yUmVjdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGN1cnJlbnRCYXNlUGxhY2VtZW50LCBib3VuZGluZ1JlY3QsIGNsaWVudFJlY3RzLCBjdXJzb3JSZWN0SW5kZXgpIHtcbiAgLy8gTm90IGFuIGlubGluZSBlbGVtZW50LCBvciBwbGFjZW1lbnQgaXMgbm90IHlldCBrbm93blxuICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoIDwgMiB8fCBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gIH0gLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkXG5cblxuICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGN1cnNvclJlY3RJbmRleCA+PSAwICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCkge1xuICAgIHJldHVybiBjbGllbnRSZWN0c1tjdXJzb3JSZWN0SW5kZXhdIHx8IGJvdW5kaW5nUmVjdDtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudEJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB7XG4gICAgICAgIHZhciBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgdmFyIGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc1RvcCA9IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAndG9wJztcbiAgICAgICAgdmFyIHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgIHZhciBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgIHZhciBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgIHZhciByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1pbkxlZnQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLmxlZnQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG1heFJpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgY2xpZW50UmVjdHMubWFwKGZ1bmN0aW9uIChyZWN0cykge1xuICAgICAgICAgIHJldHVybiByZWN0cy5yaWdodDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgdmFyIF9ib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgdmFyIF9sZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgdmFyIF9yaWdodCA9IG1heFJpZ2h0O1xuXG4gICAgICAgIHZhciBfd2lkdGggPSBfcmlnaHQgLSBfbGVmdDtcblxuICAgICAgICB2YXIgX2hlaWdodCA9IF9ib3R0b20gLSBfdG9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiBfdG9wLFxuICAgICAgICAgIGJvdHRvbTogX2JvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBfbGVmdCxcbiAgICAgICAgICByaWdodDogX3JpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBfd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICAgICAgfVxuICB9XG59XG5cbnZhciBzdGlja3kgPSB7XG4gIG5hbWU6ICdzdGlja3knLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBpbnN0YW5jZS5wb3BwZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPyBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5zdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UgOiByZWZlcmVuY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkQ2hlY2sodmFsdWUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHRydWUgfHwgaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlJlZlJlY3QgPSBudWxsO1xuICAgIHZhciBwcmV2UG9wUmVjdCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgIHZhciBjdXJyZW50UmVmUmVjdCA9IHNob3VsZENoZWNrKCdyZWZlcmVuY2UnKSA/IGdldFJlZmVyZW5jZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcbiAgICAgIHZhciBjdXJyZW50UG9wUmVjdCA9IHNob3VsZENoZWNrKCdwb3BwZXInKSA/IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG5cbiAgICAgIGlmIChjdXJyZW50UmVmUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UmVmUmVjdCwgY3VycmVudFJlZlJlY3QpIHx8IGN1cnJlbnRQb3BSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZQb3BSZWN0LCBjdXJyZW50UG9wUmVjdCkpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlJlZlJlY3QgPSBjdXJyZW50UmVmUmVjdDtcbiAgICAgIHByZXZQb3BSZWN0ID0gY3VycmVudFBvcFJlY3Q7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnN0aWNreSkge1xuICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVSZWN0c0RpZmZlcmVudChyZWN0QSwgcmVjdEIpIHtcbiAgaWYgKHJlY3RBICYmIHJlY3RCKSB7XG4gICAgcmV0dXJuIHJlY3RBLnRvcCAhPT0gcmVjdEIudG9wIHx8IHJlY3RBLnJpZ2h0ICE9PSByZWN0Qi5yaWdodCB8fCByZWN0QS5ib3R0b20gIT09IHJlY3RCLmJvdHRvbSB8fCByZWN0QS5sZWZ0ICE9PSByZWN0Qi5sZWZ0O1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnRpcHB5LnNldERlZmF1bHRQcm9wcyh7XG4gIHJlbmRlcjogcmVuZGVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdGlwcHk7XG5leHBvcnQgeyBhbmltYXRlRmlsbCwgY3JlYXRlU2luZ2xldG9uLCBkZWxlZ2F0ZSwgZm9sbG93Q3Vyc29yLCBoaWRlQWxsLCBpbmxpbmVQb3NpdGlvbmluZywgUk9VTkRfQVJST1cgYXMgcm91bmRBcnJvdywgc3RpY2t5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aXBweS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tippy.js/dist/tippy.esm.js\n");

/***/ }),

/***/ "./resources/js/desktop/pages/admin/Articles.vue":
/*!*******************************************************!*\
  !*** ./resources/js/desktop/pages/admin/Articles.vue ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Articles.vue?vue&type=template&id=ccdd7e4e& */ \"./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e&\");\n/* harmony import */ var _Articles_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Articles.vue?vue&type=script&lang=js& */ \"./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Articles_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/desktop/pages/admin/Articles.vue\"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvZGVza3RvcC9wYWdlcy9hZG1pbi9BcnRpY2xlcy52dWUiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RjtBQUMzQjtBQUNMOzs7QUFHdkQ7QUFDQSxDQUFtRztBQUNuRyxnQkFBZ0IsdUdBQVU7QUFDMUIsRUFBRSw4RUFBTTtBQUNSLEVBQUUsZ0ZBQU07QUFDUixFQUFFLHlGQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDQSxpRUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9kZXNrdG9wL3BhZ2VzL2FkbWluL0FydGljbGVzLnZ1ZT83YjYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQXJ0aWNsZXMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWNjZGQ3ZTRlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FydGljbGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXJ0aWNsZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJFOlxcXFxPcGVuU2VydmVyXFxcXE9TUGFuZWxcXFxcZG9tYWluc1xcXFx0cmF2ZWxcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnY2NkZDdlNGUnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnY2NkZDdlNGUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnY2NkZDdlNGUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FydGljbGVzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jY2RkN2U0ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCdjY2RkN2U0ZScsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicmVzb3VyY2VzL2pzL2Rlc2t0b3AvcGFnZXMvYWRtaW4vQXJ0aWNsZXMudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/desktop/pages/admin/Articles.vue\n");

/***/ }),

/***/ "./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&":
/*!********************************************************************************!*\
  !*** ./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js& ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Articles_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Articles.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&\");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Articles_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvZGVza3RvcC9wYWdlcy9hZG1pbi9BcnRpY2xlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtOLENBQUMsaUVBQWUsbU1BQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9kZXNrdG9wL3BhZ2VzL2FkbWluL0FydGljbGVzLnZ1ZT84NmFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcnRpY2xlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcnRpY2xlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/desktop/pages/admin/Articles.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e&":
/*!**************************************************************************************!*\
  !*** ./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e& ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   staticRenderFns: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Articles_vue_vue_type_template_id_ccdd7e4e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Articles.vue?vue&type=template&id=ccdd7e4e& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/desktop/pages/admin/Articles.vue?vue&type=template&id=ccdd7e4e&");


/***/ }),

/***/ "./node_modules/vue-ts-types/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNonPositive = exports.isNonNegative = exports.isPositive = exports.isNegative = exports.instanceOfProp = exports.oneOfTypesProp = exports.oneOfObjectKeysProp = exports.oneOfProp = exports.functionProp = exports.objectProp = exports.arrayProp = exports.anyProp = exports.vueComponentProp = exports.symbolProp = exports.integerProp = exports.numberProp = exports.booleanProp = exports.stringProp = void 0;\nvar string_1 = __webpack_require__(/*! ./prop-types/string */ \"./node_modules/vue-ts-types/dist/prop-types/string.js\");\nObject.defineProperty(exports, \"stringProp\", ({ enumerable: true, get: function () { return string_1.stringProp; } }));\nvar boolean_1 = __webpack_require__(/*! ./prop-types/boolean */ \"./node_modules/vue-ts-types/dist/prop-types/boolean.js\");\nObject.defineProperty(exports, \"booleanProp\", ({ enumerable: true, get: function () { return boolean_1.booleanProp; } }));\nvar number_1 = __webpack_require__(/*! ./prop-types/number */ \"./node_modules/vue-ts-types/dist/prop-types/number.js\");\nObject.defineProperty(exports, \"numberProp\", ({ enumerable: true, get: function () { return number_1.numberProp; } }));\nvar integer_1 = __webpack_require__(/*! ./prop-types/integer */ \"./node_modules/vue-ts-types/dist/prop-types/integer.js\");\nObject.defineProperty(exports, \"integerProp\", ({ enumerable: true, get: function () { return integer_1.integerProp; } }));\nvar symbol_1 = __webpack_require__(/*! ./prop-types/symbol */ \"./node_modules/vue-ts-types/dist/prop-types/symbol.js\");\nObject.defineProperty(exports, \"symbolProp\", ({ enumerable: true, get: function () { return symbol_1.symbolProp; } }));\nvar vueComponent_1 = __webpack_require__(/*! ./prop-types/vueComponent */ \"./node_modules/vue-ts-types/dist/prop-types/vueComponent.js\");\nObject.defineProperty(exports, \"vueComponentProp\", ({ enumerable: true, get: function () { return vueComponent_1.vueComponentProp; } }));\nvar any_1 = __webpack_require__(/*! ./prop-types/any */ \"./node_modules/vue-ts-types/dist/prop-types/any.js\");\nObject.defineProperty(exports, \"anyProp\", ({ enumerable: true, get: function () { return any_1.anyProp; } }));\nvar array_1 = __webpack_require__(/*! ./prop-types/array */ \"./node_modules/vue-ts-types/dist/prop-types/array.js\");\nObject.defineProperty(exports, \"arrayProp\", ({ enumerable: true, get: function () { return array_1.arrayProp; } }));\nvar object_1 = __webpack_require__(/*! ./prop-types/object */ \"./node_modules/vue-ts-types/dist/prop-types/object.js\");\nObject.defineProperty(exports, \"objectProp\", ({ enumerable: true, get: function () { return object_1.objectProp; } }));\nvar function_1 = __webpack_require__(/*! ./prop-types/function */ \"./node_modules/vue-ts-types/dist/prop-types/function.js\");\nObject.defineProperty(exports, \"functionProp\", ({ enumerable: true, get: function () { return function_1.functionProp; } }));\nvar oneOf_1 = __webpack_require__(/*! ./prop-types/oneOf */ \"./node_modules/vue-ts-types/dist/prop-types/oneOf.js\");\nObject.defineProperty(exports, \"oneOfProp\", ({ enumerable: true, get: function () { return oneOf_1.oneOfProp; } }));\nvar oneOfObjectKeys_1 = __webpack_require__(/*! ./prop-types/oneOfObjectKeys */ \"./node_modules/vue-ts-types/dist/prop-types/oneOfObjectKeys.js\");\nObject.defineProperty(exports, \"oneOfObjectKeysProp\", ({ enumerable: true, get: function () { return oneOfObjectKeys_1.oneOfObjectKeysProp; } }));\nvar oneOfTypes_1 = __webpack_require__(/*! ./prop-types/oneOfTypes */ \"./node_modules/vue-ts-types/dist/prop-types/oneOfTypes.js\");\nObject.defineProperty(exports, \"oneOfTypesProp\", ({ enumerable: true, get: function () { return oneOfTypes_1.oneOfTypesProp; } }));\nvar instanceOf_1 = __webpack_require__(/*! ./prop-types/instanceOf */ \"./node_modules/vue-ts-types/dist/prop-types/instanceOf.js\");\nObject.defineProperty(exports, \"instanceOfProp\", ({ enumerable: true, get: function () { return instanceOf_1.instanceOfProp; } }));\nvar isNegative_1 = __webpack_require__(/*! ./validators/isNegative */ \"./node_modules/vue-ts-types/dist/validators/isNegative.js\");\nObject.defineProperty(exports, \"isNegative\", ({ enumerable: true, get: function () { return isNegative_1.isNegative; } }));\nvar isPositive_1 = __webpack_require__(/*! ./validators/isPositive */ \"./node_modules/vue-ts-types/dist/validators/isPositive.js\");\nObject.defineProperty(exports, \"isPositive\", ({ enumerable: true, get: function () { return isPositive_1.isPositive; } }));\nvar isNonNegative_1 = __webpack_require__(/*! ./validators/isNonNegative */ \"./node_modules/vue-ts-types/dist/validators/isNonNegative.js\");\nObject.defineProperty(exports, \"isNonNegative\", ({ enumerable: true, get: function () { return isNonNegative_1.isNonNegative; } }));\nvar isNonPositive_1 = __webpack_require__(/*! ./validators/isNonPositive */ \"./node_modules/vue-ts-types/dist/validators/isNonPositive.js\");\nObject.defineProperty(exports, \"isNonPositive\", ({ enumerable: true, get: function () { return isNonPositive_1.isNonPositive; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQjtBQUNuWixlQUFlLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzVDLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDOUMsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILGVBQWUsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDNUMsOENBQTZDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3BILGdCQUFnQixtQkFBTyxDQUFDLG9GQUFzQjtBQUM5QywrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsZUFBZSxtQkFBTyxDQUFDLGtGQUFxQjtBQUM1Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgscUJBQXFCLG1CQUFPLENBQUMsOEZBQTJCO0FBQ3hELG9EQUFtRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN0SSxZQUFZLG1CQUFPLENBQUMsNEVBQWtCO0FBQ3RDLDJDQUEwQyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUMzRyxjQUFjLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQzFDLDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCxlQUFlLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzVDLDhDQUE2QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNwSCxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDaEQsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILGNBQWMsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDMUMsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILHdCQUF3QixtQkFBTyxDQUFDLG9HQUE4QjtBQUM5RCx1REFBc0QsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDL0ksbUJBQW1CLG1CQUFPLENBQUMsMEZBQXlCO0FBQ3BELGtEQUFpRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNoSSxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBeUI7QUFDcEQsa0RBQWlELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2hJLG1CQUFtQixtQkFBTyxDQUFDLDBGQUF5QjtBQUNwRCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXlCO0FBQ3BELDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBNEI7QUFDMUQsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2pJLHNCQUFzQixtQkFBTyxDQUFDLGdHQUE0QjtBQUMxRCxpREFBZ0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvaW5kZXguanM/MzZlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNOb25Qb3NpdGl2ZSA9IGV4cG9ydHMuaXNOb25OZWdhdGl2ZSA9IGV4cG9ydHMuaXNQb3NpdGl2ZSA9IGV4cG9ydHMuaXNOZWdhdGl2ZSA9IGV4cG9ydHMuaW5zdGFuY2VPZlByb3AgPSBleHBvcnRzLm9uZU9mVHlwZXNQcm9wID0gZXhwb3J0cy5vbmVPZk9iamVjdEtleXNQcm9wID0gZXhwb3J0cy5vbmVPZlByb3AgPSBleHBvcnRzLmZ1bmN0aW9uUHJvcCA9IGV4cG9ydHMub2JqZWN0UHJvcCA9IGV4cG9ydHMuYXJyYXlQcm9wID0gZXhwb3J0cy5hbnlQcm9wID0gZXhwb3J0cy52dWVDb21wb25lbnRQcm9wID0gZXhwb3J0cy5zeW1ib2xQcm9wID0gZXhwb3J0cy5pbnRlZ2VyUHJvcCA9IGV4cG9ydHMubnVtYmVyUHJvcCA9IGV4cG9ydHMuYm9vbGVhblByb3AgPSBleHBvcnRzLnN0cmluZ1Byb3AgPSB2b2lkIDA7XG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9wcm9wLXR5cGVzL3N0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ1Byb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ18xLnN0cmluZ1Byb3A7IH0gfSk7XG52YXIgYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9ib29sZWFuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYm9vbGVhblByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvb2xlYW5fMS5ib29sZWFuUHJvcDsgfSB9KTtcbnZhciBudW1iZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3AtdHlwZXMvbnVtYmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibnVtYmVyUHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyXzEubnVtYmVyUHJvcDsgfSB9KTtcbnZhciBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9wcm9wLXR5cGVzL2ludGVnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlZ2VyUHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcl8xLmludGVnZXJQcm9wOyB9IH0pO1xudmFyIHN5bWJvbF8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9zeW1ib2xcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzeW1ib2xQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xfMS5zeW1ib2xQcm9wOyB9IH0pO1xudmFyIHZ1ZUNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy92dWVDb21wb25lbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2dWVDb21wb25lbnRQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2dWVDb21wb25lbnRfMS52dWVDb21wb25lbnRQcm9wOyB9IH0pO1xudmFyIGFueV8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9hbnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhbnlQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbnlfMS5hbnlQcm9wOyB9IH0pO1xudmFyIGFycmF5XzEgPSByZXF1aXJlKFwiLi9wcm9wLXR5cGVzL2FycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcnJheV8xLmFycmF5UHJvcDsgfSB9KTtcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL3Byb3AtdHlwZXMvb2JqZWN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib2JqZWN0UHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqZWN0XzEub2JqZWN0UHJvcDsgfSB9KTtcbnZhciBmdW5jdGlvbl8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9mdW5jdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZ1bmN0aW9uUHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb25fMS5mdW5jdGlvblByb3A7IH0gfSk7XG52YXIgb25lT2ZfMSA9IHJlcXVpcmUoXCIuL3Byb3AtdHlwZXMvb25lT2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbmVPZlByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9uZU9mXzEub25lT2ZQcm9wOyB9IH0pO1xudmFyIG9uZU9mT2JqZWN0S2V5c18xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9vbmVPZk9iamVjdEtleXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbmVPZk9iamVjdEtleXNQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmVPZk9iamVjdEtleXNfMS5vbmVPZk9iamVjdEtleXNQcm9wOyB9IH0pO1xudmFyIG9uZU9mVHlwZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3AtdHlwZXMvb25lT2ZUeXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9uZU9mVHlwZXNQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmVPZlR5cGVzXzEub25lT2ZUeXBlc1Byb3A7IH0gfSk7XG52YXIgaW5zdGFuY2VPZl8xID0gcmVxdWlyZShcIi4vcHJvcC10eXBlcy9pbnN0YW5jZU9mXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5zdGFuY2VPZlByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlT2ZfMS5pbnN0YW5jZU9mUHJvcDsgfSB9KTtcbnZhciBpc05lZ2F0aXZlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTmVnYXRpdmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05lZ2F0aXZlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc05lZ2F0aXZlXzEuaXNOZWdhdGl2ZTsgfSB9KTtcbnZhciBpc1Bvc2l0aXZlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzUG9zaXRpdmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Bvc2l0aXZlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1Bvc2l0aXZlXzEuaXNQb3NpdGl2ZTsgfSB9KTtcbnZhciBpc05vbk5lZ2F0aXZlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTm9uTmVnYXRpdmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vbk5lZ2F0aXZlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc05vbk5lZ2F0aXZlXzEuaXNOb25OZWdhdGl2ZTsgfSB9KTtcbnZhciBpc05vblBvc2l0aXZlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTm9uUG9zaXRpdmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vblBvc2l0aXZlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc05vblBvc2l0aXZlXzEuaXNOb25Qb3NpdGl2ZTsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/index.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/any.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/any.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.anyProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any type. No built-in runtime validation is performed by default.\n *\n * Type parameter `T` can be used to restrict the type at compile time.\n *\n * @param validator - Optional function for runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst anyProp = (validator) => (0, util_1.propOptionsGenerator)(undefined, validator);\nexports.anyProp = anyProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS10cy10eXBlcy9kaXN0L3Byb3AtdHlwZXMvYW55LmpzP2Q3MjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFueVByb3AgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQWxsb3dzIGFueSB0eXBlLiBObyBidWlsdC1pbiBydW50aW1lIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkIGJ5IGRlZmF1bHQuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgYFRgIGNhbiBiZSB1c2VkIHRvIHJlc3RyaWN0IHRoZSB0eXBlIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gZm9yIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IGFueVByb3AgPSAodmFsaWRhdG9yKSA9PiAoMCwgdXRpbF8xLnByb3BPcHRpb25zR2VuZXJhdG9yKSh1bmRlZmluZWQsIHZhbGlkYXRvcik7XG5leHBvcnRzLmFueVByb3AgPSBhbnlQcm9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/any.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/array.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/array.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.arrayProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any array. No further runtime validation is performed by default.\n *\n * Type parameter `T` can be used to restrict the type of the array items at compile time.\n *\n *  @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst arrayProp = (validator) => (0, util_1.propOptionsGenerator)(Array, validator);\nexports.arrayProp = arrayProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZUFBZSxtQkFBTyxDQUFDLHlEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC9wcm9wLXR5cGVzL2FycmF5LmpzPzdiOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5UHJvcCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBbGxvd3MgYW55IGFycmF5LiBObyBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBUeXBlIHBhcmFtZXRlciBgVGAgY2FuIGJlIHVzZWQgdG8gcmVzdHJpY3QgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGl0ZW1zIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiAgQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IGFycmF5UHJvcCA9ICh2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKEFycmF5LCB2YWxpZGF0b3IpO1xuZXhwb3J0cy5hcnJheVByb3AgPSBhcnJheVByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/array.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/boolean.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/boolean.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.booleanProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any boolean (validated at runtime and compile time).\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst booleanProp = (validator) => (0, util_1.propOptionsGenerator)(Boolean, validator);\nexports.booleanProp = booleanProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixlQUFlLG1CQUFPLENBQUMseURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9ib29sZWFuLmpzP2Y5MjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2xlYW5Qcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIEFsbG93cyBhbnkgYm9vbGVhbiAodmFsaWRhdGVkIGF0IHJ1bnRpbWUgYW5kIGNvbXBpbGUgdGltZSkuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IGJvb2xlYW5Qcm9wID0gKHZhbGlkYXRvcikgPT4gKDAsIHV0aWxfMS5wcm9wT3B0aW9uc0dlbmVyYXRvcikoQm9vbGVhbiwgdmFsaWRhdG9yKTtcbmV4cG9ydHMuYm9vbGVhblByb3AgPSBib29sZWFuUHJvcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/boolean.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/function.js":
/*!***************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/function.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.functionProp = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\n/* eslint-disable @typescript-eslint/ban-types */\n/**\n * Allows any function. No further runtime validation is performed by default.\n *\n * Type parameter `T` can be used to restrict the type to a specific function signature at compile time.\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst functionProp = (validator) => ({\n    optional: {\n        type: Function,\n        required: false,\n        default: undefined,\n        validator: (0, validators_1.vuePropValidator)(validator),\n    },\n    nullable: {\n        type: Function,\n        required: false,\n        default: null,\n        validator: (0, validators_1.vuePropValidator)(validator),\n    },\n    required: {\n        type: Function,\n        required: true,\n        validator: (0, validators_1.vuePropValidator)(validator),\n    },\n});\nexports.functionProp = functionProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9mdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMsMkVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC9wcm9wLXR5cGVzL2Z1bmN0aW9uLmpzPzRhNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZ1bmN0aW9uUHJvcCA9IHZvaWQgMDtcbmNvbnN0IHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xuLyoqXG4gKiBBbGxvd3MgYW55IGZ1bmN0aW9uLiBObyBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBUeXBlIHBhcmFtZXRlciBgVGAgY2FuIGJlIHVzZWQgdG8gcmVzdHJpY3QgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBmdW5jdGlvbiBzaWduYXR1cmUgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBPcHRpb25hbCBmdW5jdGlvbiBmb3IgZnVydGhlciBydW50aW1lIHZhbGlkYXRpb247IHNob3VsZCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgdmFsaWQsIG9yIGFuIGVycm9yIHN0cmluZyBpZiBpbnZhbGlkLlxuICovXG5jb25zdCBmdW5jdGlvblByb3AgPSAodmFsaWRhdG9yKSA9PiAoe1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsaWRhdG9yOiAoMCwgdmFsaWRhdG9yc18xLnZ1ZVByb3BWYWxpZGF0b3IpKHZhbGlkYXRvciksXG4gICAgfSxcbiAgICBudWxsYWJsZToge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICB2YWxpZGF0b3I6ICgwLCB2YWxpZGF0b3JzXzEudnVlUHJvcFZhbGlkYXRvcikodmFsaWRhdG9yKSxcbiAgICB9LFxuICAgIHJlcXVpcmVkOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdG9yOiAoMCwgdmFsaWRhdG9yc18xLnZ1ZVByb3BWYWxpZGF0b3IpKHZhbGlkYXRvciksXG4gICAgfSxcbn0pO1xuZXhwb3J0cy5mdW5jdGlvblByb3AgPSBmdW5jdGlvblByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/function.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.instanceOfProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\nconst validators_1 = __webpack_require__(/*! ../validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\n/**\n * Allows instances of the given constructor (validated at runtime and compile time).\n *\n * Type parameter `T` can be used to adjust the inferred type at compile time.\n *\n * @param parent - The constructor to allow.\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst instanceOfProp = (parent, validator) => (0, util_1.propOptionsGenerator)(parent, validator, (0, validators_1.isInstanceOf)(parent));\nexports.instanceOfProp = instanceOfProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9pbnN0YW5jZU9mLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixlQUFlLG1CQUFPLENBQUMseURBQVM7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsMkVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9pbnN0YW5jZU9mLmpzPzhkNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluc3RhbmNlT2ZQcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogQWxsb3dzIGluc3RhbmNlcyBvZiB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgKHZhbGlkYXRlZCBhdCBydW50aW1lIGFuZCBjb21waWxlIHRpbWUpLlxuICpcbiAqIFR5cGUgcGFyYW1ldGVyIGBUYCBjYW4gYmUgdXNlZCB0byBhZGp1c3QgdGhlIGluZmVycmVkIHR5cGUgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgY29uc3RydWN0b3IgdG8gYWxsb3cuXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gZm9yIGZ1cnRoZXIgcnVudGltZSB2YWxpZGF0aW9uOyBzaG91bGQgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHZhbGlkLCBvciBhbiBlcnJvciBzdHJpbmcgaWYgaW52YWxpZC5cbiAqL1xuY29uc3QgaW5zdGFuY2VPZlByb3AgPSAocGFyZW50LCB2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKHBhcmVudCwgdmFsaWRhdG9yLCAoMCwgdmFsaWRhdG9yc18xLmlzSW5zdGFuY2VPZikocGFyZW50KSk7XG5leHBvcnRzLmluc3RhbmNlT2ZQcm9wID0gaW5zdGFuY2VPZlByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/instanceOf.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/integer.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/integer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.integerProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\nconst validators_1 = __webpack_require__(/*! ../validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\n/**\n * Allows any integer (validated at runtime).\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst integerProp = (validator) => (0, util_1.propOptionsGenerator)(Number, validator, validators_1.isInteger);\nexports.integerProp = integerProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9pbnRlZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixlQUFlLG1CQUFPLENBQUMseURBQVM7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsMkVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9pbnRlZ2VyLmpzPzEyYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludGVnZXJQcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogQWxsb3dzIGFueSBpbnRlZ2VyICh2YWxpZGF0ZWQgYXQgcnVudGltZSkuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IGludGVnZXJQcm9wID0gKHZhbGlkYXRvcikgPT4gKDAsIHV0aWxfMS5wcm9wT3B0aW9uc0dlbmVyYXRvcikoTnVtYmVyLCB2YWxpZGF0b3IsIHZhbGlkYXRvcnNfMS5pc0ludGVnZXIpO1xuZXhwb3J0cy5pbnRlZ2VyUHJvcCA9IGludGVnZXJQcm9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/integer.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/number.js":
/*!*************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.numberProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any number (validated at runtime and compile time).\n *\n * Type parameter `T` can be used to restrict the type at compile time with a union type.\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst numberProp = (validator) => (0, util_1.propOptionsGenerator)(Number, validator);\nexports.numberProp = numberProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9udW1iZXIuanM/MjA5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubnVtYmVyUHJvcCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBbGxvd3MgYW55IG51bWJlciAodmFsaWRhdGVkIGF0IHJ1bnRpbWUgYW5kIGNvbXBpbGUgdGltZSkuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgYFRgIGNhbiBiZSB1c2VkIHRvIHJlc3RyaWN0IHRoZSB0eXBlIGF0IGNvbXBpbGUgdGltZSB3aXRoIGEgdW5pb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gZm9yIGZ1cnRoZXIgcnVudGltZSB2YWxpZGF0aW9uOyBzaG91bGQgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHZhbGlkLCBvciBhbiBlcnJvciBzdHJpbmcgaWYgaW52YWxpZC5cbiAqL1xuY29uc3QgbnVtYmVyUHJvcCA9ICh2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKE51bWJlciwgdmFsaWRhdG9yKTtcbmV4cG9ydHMubnVtYmVyUHJvcCA9IG51bWJlclByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/number.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/object.js":
/*!*************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/object.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.objectProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any object. No further runtime validation is performed by default.\n *\n * Type parameter `T` can be used to restrict the type at compile time.\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst objectProp = (validator) => (0, util_1.propOptionsGenerator)(Object, validator);\nexports.objectProp = objectProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vYmplY3QuanM/YzY4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub2JqZWN0UHJvcCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBbGxvd3MgYW55IG9iamVjdC4gTm8gZnVydGhlciBydW50aW1lIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkIGJ5IGRlZmF1bHQuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgYFRgIGNhbiBiZSB1c2VkIHRvIHJlc3RyaWN0IHRoZSB0eXBlIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gZm9yIGZ1cnRoZXIgcnVudGltZSB2YWxpZGF0aW9uOyBzaG91bGQgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHZhbGlkLCBvciBhbiBlcnJvciBzdHJpbmcgaWYgaW52YWxpZC5cbiAqL1xuY29uc3Qgb2JqZWN0UHJvcCA9ICh2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKE9iamVjdCwgdmFsaWRhdG9yKTtcbmV4cG9ydHMub2JqZWN0UHJvcCA9IG9iamVjdFByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/object.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/oneOf.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/oneOf.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOfProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\nconst validators_1 = __webpack_require__(/*! ../validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\n// inspired by https://github.com/dwightjack/vue-types/blob/4.1.1/src/validators/oneof.ts\nconst getOneOfType = (values) => {\n    const allowedTypes = [...new Set(values.flatMap(value => {\n            var _a;\n            if (value === null || value === undefined) {\n                return [];\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            return (_a = value.constructor) !== null && _a !== void 0 ? _a : [];\n        }))];\n    if (allowedTypes.length === 0) {\n        return undefined;\n    }\n    if (allowedTypes.length === 1) {\n        return allowedTypes[0];\n    }\n    return allowedTypes;\n};\n/**\n * Allows any of the specified allowed values (validated at runtime and compile time).\n *\n * Type parameter `T` can be used to adjust the inferred type at compile time, this is usually not necessary.\n *\n * @param allowedValues - The allowed values.\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst oneOfProp = (allowedValues, validator) => (0, util_1.propOptionsGenerator)(getOneOfType(allowedValues), validator, (0, validators_1.isOneOf)(allowedValues));\nexports.oneOfProp = oneOfProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vbmVPZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZUFBZSxtQkFBTyxDQUFDLHlEQUFTO0FBQ2hDLHFCQUFxQixtQkFBTyxDQUFDLDJFQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vbmVPZi5qcz83YzM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vbmVPZlByb3AgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzXCIpO1xuLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2R3aWdodGphY2svdnVlLXR5cGVzL2Jsb2IvNC4xLjEvc3JjL3ZhbGlkYXRvcnMvb25lb2YudHNcbmNvbnN0IGdldE9uZU9mVHlwZSA9ICh2YWx1ZXMpID0+IHtcbiAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBbLi4ubmV3IFNldCh2YWx1ZXMuZmxhdE1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIH0pKV07XG4gICAgaWYgKGFsbG93ZWRUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFsbG93ZWRUeXBlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG93ZWRUeXBlcztcbn07XG4vKipcbiAqIEFsbG93cyBhbnkgb2YgdGhlIHNwZWNpZmllZCBhbGxvd2VkIHZhbHVlcyAodmFsaWRhdGVkIGF0IHJ1bnRpbWUgYW5kIGNvbXBpbGUgdGltZSkuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgYFRgIGNhbiBiZSB1c2VkIHRvIGFkanVzdCB0aGUgaW5mZXJyZWQgdHlwZSBhdCBjb21waWxlIHRpbWUsIHRoaXMgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSBhbGxvd2VkVmFsdWVzIC0gVGhlIGFsbG93ZWQgdmFsdWVzLlxuICogQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IG9uZU9mUHJvcCA9IChhbGxvd2VkVmFsdWVzLCB2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKGdldE9uZU9mVHlwZShhbGxvd2VkVmFsdWVzKSwgdmFsaWRhdG9yLCAoMCwgdmFsaWRhdG9yc18xLmlzT25lT2YpKGFsbG93ZWRWYWx1ZXMpKTtcbmV4cG9ydHMub25lT2ZQcm9wID0gb25lT2ZQcm9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/oneOf.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/oneOfObjectKeys.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/oneOfObjectKeys.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOfObjectKeysProp = void 0;\nconst oneOf_1 = __webpack_require__(/*! ./oneOf */ \"./node_modules/vue-ts-types/dist/prop-types/oneOf.js\");\n/**\n * Allows any of the keys of the specified object (validated at runtime and compile time).\n *\n * Type parameter `T` can be used to adjust the inferred type at compile time, this is usually not necessary.\n *\n * @param object - The object whose keys are allowed.\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst oneOfObjectKeysProp = (object, validator) => (0, oneOf_1.oneOfProp)(Object.keys(object), validator);\nexports.oneOfObjectKeysProp = oneOfObjectKeysProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vbmVPZk9iamVjdEtleXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLHFFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS10cy10eXBlcy9kaXN0L3Byb3AtdHlwZXMvb25lT2ZPYmplY3RLZXlzLmpzPzgxOTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZU9mT2JqZWN0S2V5c1Byb3AgPSB2b2lkIDA7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG4vKipcbiAqIEFsbG93cyBhbnkgb2YgdGhlIGtleXMgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QgKHZhbGlkYXRlZCBhdCBydW50aW1lIGFuZCBjb21waWxlIHRpbWUpLlxuICpcbiAqIFR5cGUgcGFyYW1ldGVyIGBUYCBjYW4gYmUgdXNlZCB0byBhZGp1c3QgdGhlIGluZmVycmVkIHR5cGUgYXQgY29tcGlsZSB0aW1lLCB0aGlzIGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBhbGxvd2VkLlxuICogQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IG9uZU9mT2JqZWN0S2V5c1Byb3AgPSAob2JqZWN0LCB2YWxpZGF0b3IpID0+ICgwLCBvbmVPZl8xLm9uZU9mUHJvcCkoT2JqZWN0LmtleXMob2JqZWN0KSwgdmFsaWRhdG9yKTtcbmV4cG9ydHMub25lT2ZPYmplY3RLZXlzUHJvcCA9IG9uZU9mT2JqZWN0S2V5c1Byb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/oneOfObjectKeys.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/oneOfTypes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/oneOfTypes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOfTypesProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any of the passed constructor types (validated at runtime).\n *\n * Type parameter `T` has to be used to adjust the type at compile time.\n *\n * @param type - A single constructor or an array of constructors to allow.\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst oneOfTypesProp = (type, validator) => (0, util_1.propOptionsGenerator)(type, validator);\nexports.oneOfTypesProp = oneOfTypesProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vbmVPZlR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixlQUFlLG1CQUFPLENBQUMseURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9vbmVPZlR5cGVzLmpzPzlhZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZU9mVHlwZXNQcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIEFsbG93cyBhbnkgb2YgdGhlIHBhc3NlZCBjb25zdHJ1Y3RvciB0eXBlcyAodmFsaWRhdGVkIGF0IHJ1bnRpbWUpLlxuICpcbiAqIFR5cGUgcGFyYW1ldGVyIGBUYCBoYXMgdG8gYmUgdXNlZCB0byBhZGp1c3QgdGhlIHR5cGUgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gQSBzaW5nbGUgY29uc3RydWN0b3Igb3IgYW4gYXJyYXkgb2YgY29uc3RydWN0b3JzIHRvIGFsbG93LlxuICogQHBhcmFtIHZhbGlkYXRvciAtIE9wdGlvbmFsIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJ1bnRpbWUgdmFsaWRhdGlvbjsgc2hvdWxkIHJldHVybiBgdW5kZWZpbmVkYCBpZiB2YWxpZCwgb3IgYW4gZXJyb3Igc3RyaW5nIGlmIGludmFsaWQuXG4gKi9cbmNvbnN0IG9uZU9mVHlwZXNQcm9wID0gKHR5cGUsIHZhbGlkYXRvcikgPT4gKDAsIHV0aWxfMS5wcm9wT3B0aW9uc0dlbmVyYXRvcikodHlwZSwgdmFsaWRhdG9yKTtcbmV4cG9ydHMub25lT2ZUeXBlc1Byb3AgPSBvbmVPZlR5cGVzUHJvcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/oneOfTypes.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/string.js":
/*!*************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/string.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any string. No further runtime validation is performed by default.\n *\n * Type parameter `T` can be used to restrict the type at compile time with a union type.\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst stringProp = (validator) => (0, util_1.propOptionsGenerator)(String, validator);\nexports.stringProp = stringProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9zdHJpbmcuanM/MjZiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBbGxvd3MgYW55IHN0cmluZy4gTm8gZnVydGhlciBydW50aW1lIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkIGJ5IGRlZmF1bHQuXG4gKlxuICogVHlwZSBwYXJhbWV0ZXIgYFRgIGNhbiBiZSB1c2VkIHRvIHJlc3RyaWN0IHRoZSB0eXBlIGF0IGNvbXBpbGUgdGltZSB3aXRoIGEgdW5pb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gZm9yIGZ1cnRoZXIgcnVudGltZSB2YWxpZGF0aW9uOyBzaG91bGQgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHZhbGlkLCBvciBhbiBlcnJvciBzdHJpbmcgaWYgaW52YWxpZC5cbiAqL1xuY29uc3Qgc3RyaW5nUHJvcCA9ICh2YWxpZGF0b3IpID0+ICgwLCB1dGlsXzEucHJvcE9wdGlvbnNHZW5lcmF0b3IpKFN0cmluZywgdmFsaWRhdG9yKTtcbmV4cG9ydHMuc3RyaW5nUHJvcCA9IHN0cmluZ1Byb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/string.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/symbol.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.symbolProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\nconst validators_1 = __webpack_require__(/*! ../validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\n/**\n * Allows any symbol (validated at runtime and compile time).\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst symbolProp = (validator) => (0, util_1.propOptionsGenerator)(undefined, validator, validators_1.isSymbol);\nexports.symbolProp = symbolProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy9zeW1ib2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQyxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC9wcm9wLXR5cGVzL3N5bWJvbC5qcz9lYzIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zeW1ib2xQcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9yc1wiKTtcbi8qKlxuICogQWxsb3dzIGFueSBzeW1ib2wgKHZhbGlkYXRlZCBhdCBydW50aW1lIGFuZCBjb21waWxlIHRpbWUpLlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBPcHRpb25hbCBmdW5jdGlvbiBmb3IgZnVydGhlciBydW50aW1lIHZhbGlkYXRpb247IHNob3VsZCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgdmFsaWQsIG9yIGFuIGVycm9yIHN0cmluZyBpZiBpbnZhbGlkLlxuICovXG5jb25zdCBzeW1ib2xQcm9wID0gKHZhbGlkYXRvcikgPT4gKDAsIHV0aWxfMS5wcm9wT3B0aW9uc0dlbmVyYXRvcikodW5kZWZpbmVkLCB2YWxpZGF0b3IsIHZhbGlkYXRvcnNfMS5pc1N5bWJvbCk7XG5leHBvcnRzLnN5bWJvbFByb3AgPSBzeW1ib2xQcm9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/symbol.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/prop-types/vueComponent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/prop-types/vueComponent.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.vueComponentProp = void 0;\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/vue-ts-types/dist/util.js\");\n/**\n * Allows any Vue component instance, name or options object. No built-in runtime validation is performed by default.\n *\n * @param validator - Optional function for further runtime validation; should return `undefined` if valid, or an error string if invalid.\n */\nconst vueComponentProp = (validator) => (0, util_1.propOptionsGenerator)([Object, String], validator);\nexports.vueComponentProp = vueComponentProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvcHJvcC10eXBlcy92dWVDb21wb25lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC9wcm9wLXR5cGVzL3Z1ZUNvbXBvbmVudC5qcz8zYTE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52dWVDb21wb25lbnRQcm9wID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIEFsbG93cyBhbnkgVnVlIGNvbXBvbmVudCBpbnN0YW5jZSwgbmFtZSBvciBvcHRpb25zIG9iamVjdC4gTm8gYnVpbHQtaW4gcnVudGltZSB2YWxpZGF0aW9uIGlzIHBlcmZvcm1lZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB2YWxpZGF0b3IgLSBPcHRpb25hbCBmdW5jdGlvbiBmb3IgZnVydGhlciBydW50aW1lIHZhbGlkYXRpb247IHNob3VsZCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgdmFsaWQsIG9yIGFuIGVycm9yIHN0cmluZyBpZiBpbnZhbGlkLlxuICovXG5jb25zdCB2dWVDb21wb25lbnRQcm9wID0gKHZhbGlkYXRvcikgPT4gKDAsIHV0aWxfMS5wcm9wT3B0aW9uc0dlbmVyYXRvcikoW09iamVjdCwgU3RyaW5nXSwgdmFsaWRhdG9yKTtcbmV4cG9ydHMudnVlQ29tcG9uZW50UHJvcCA9IHZ1ZUNvbXBvbmVudFByb3A7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/prop-types/vueComponent.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/util.js":
/*!************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.propOptionsGenerator = void 0;\nconst validators_1 = __webpack_require__(/*! ./validators */ \"./node_modules/vue-ts-types/dist/validators/index.js\");\nconst propOptionsGenerator = (type, userValidator, ...typeValidators) => ({\n    optional: {\n        type,\n        required: false,\n        default: undefined,\n        validator: (0, validators_1.vuePropValidator)(userValidator, ...typeValidators),\n    },\n    nullable: {\n        type,\n        required: false,\n        default: null,\n        validator: (0, validators_1.vuePropValidator)(userValidator, ...typeValidators),\n    },\n    withDefault: (defaultValue) => ({\n        type,\n        required: false,\n        default: defaultValue,\n        validator: (0, validators_1.vuePropValidator)(userValidator, ...typeValidators),\n    }),\n    required: {\n        type,\n        required: true,\n        validator: (0, validators_1.vuePropValidator)(userValidator, ...typeValidators),\n    },\n});\nexports.propOptionsGenerator = propOptionsGenerator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIscUJBQXFCLG1CQUFPLENBQUMsMEVBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS10cy10eXBlcy9kaXN0L3V0aWwuanM/YmFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvcE9wdGlvbnNHZW5lcmF0b3IgPSB2b2lkIDA7XG5jb25zdCB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzXCIpO1xuY29uc3QgcHJvcE9wdGlvbnNHZW5lcmF0b3IgPSAodHlwZSwgdXNlclZhbGlkYXRvciwgLi4udHlwZVZhbGlkYXRvcnMpID0+ICh7XG4gICAgb3B0aW9uYWw6IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgIHZhbGlkYXRvcjogKDAsIHZhbGlkYXRvcnNfMS52dWVQcm9wVmFsaWRhdG9yKSh1c2VyVmFsaWRhdG9yLCAuLi50eXBlVmFsaWRhdG9ycyksXG4gICAgfSxcbiAgICBudWxsYWJsZToge1xuICAgICAgICB0eXBlLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcjogKDAsIHZhbGlkYXRvcnNfMS52dWVQcm9wVmFsaWRhdG9yKSh1c2VyVmFsaWRhdG9yLCAuLi50eXBlVmFsaWRhdG9ycyksXG4gICAgfSxcbiAgICB3aXRoRGVmYXVsdDogKGRlZmF1bHRWYWx1ZSkgPT4gKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgICAgIHZhbGlkYXRvcjogKDAsIHZhbGlkYXRvcnNfMS52dWVQcm9wVmFsaWRhdG9yKSh1c2VyVmFsaWRhdG9yLCAuLi50eXBlVmFsaWRhdG9ycyksXG4gICAgfSksXG4gICAgcmVxdWlyZWQ6IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHZhbGlkYXRvcjogKDAsIHZhbGlkYXRvcnNfMS52dWVQcm9wVmFsaWRhdG9yKSh1c2VyVmFsaWRhdG9yLCAuLi50eXBlVmFsaWRhdG9ycyksXG4gICAgfSxcbn0pO1xuZXhwb3J0cy5wcm9wT3B0aW9uc0dlbmVyYXRvciA9IHByb3BPcHRpb25zR2VuZXJhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/util.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/index.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSymbol = exports.isOneOf = exports.isInteger = exports.isInstanceOf = exports.vuePropValidator = void 0;\nconst vue_1 = __importDefault(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\"));\n/**\n * Creates a Vue prop validator that runs all type validators and the user validator (if specified).\n * @param userValidator Validator function specified by the user.\n * @param typeValidators Validator functions hard-coded by the prop type function.\n */\nfunction vuePropValidator(userValidator, ...typeValidators) {\n    const validators = userValidator ? [...typeValidators, userValidator] : typeValidators;\n    if (validators.length === 0) {\n        return undefined;\n    }\n    return (value) => {\n        for (const validator of validators) {\n            const errorMessage = validator(value);\n            if (errorMessage) {\n                if (typeof vue_1.default === 'object' && 'util' in vue_1.default) {\n                    // @ts-expect-error -- Vue.util is only available in Vue 2, but provides more context than console.warn\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n                    vue_1.default.util.warn(`${errorMessage} (received: '${String(value)}')`);\n                }\n                else {\n                    console.warn(`${errorMessage} (received: '${String(value)}')`);\n                }\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexports.vuePropValidator = vuePropValidator;\n// for internal use only\nvar isInstanceOf_1 = __webpack_require__(/*! ./isInstanceOf */ \"./node_modules/vue-ts-types/dist/validators/isInstanceOf.js\");\nObject.defineProperty(exports, \"isInstanceOf\", ({ enumerable: true, get: function () { return isInstanceOf_1.isInstanceOf; } }));\nvar isInteger_1 = __webpack_require__(/*! ./isInteger */ \"./node_modules/vue-ts-types/dist/validators/isInteger.js\");\nObject.defineProperty(exports, \"isInteger\", ({ enumerable: true, get: function () { return isInteger_1.isInteger; } }));\nvar isOneOf_1 = __webpack_require__(/*! ./isOneOf */ \"./node_modules/vue-ts-types/dist/validators/isOneOf.js\");\nObject.defineProperty(exports, \"isOneOf\", ({ enumerable: true, get: function () { return isOneOf_1.isOneOf; } }));\nvar isSymbol_1 = __webpack_require__(/*! ./isSymbol */ \"./node_modules/vue-ts-types/dist/validators/isSymbol.js\");\nObject.defineProperty(exports, \"isSymbol\", ({ enumerable: true, get: function () { return isSymbol_1.isSymbol; } }));\n// custom validators provided for user convenience are exported from main entrypoint\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDeEcsOEJBQThCLG1CQUFPLENBQUMsK0NBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjLGNBQWMsY0FBYztBQUN6RjtBQUNBO0FBQ0Esb0NBQW9DLGNBQWMsY0FBYyxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsbUZBQWdCO0FBQzdDLGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2luZGV4LmpzP2Q0NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzU3ltYm9sID0gZXhwb3J0cy5pc09uZU9mID0gZXhwb3J0cy5pc0ludGVnZXIgPSBleHBvcnRzLmlzSW5zdGFuY2VPZiA9IGV4cG9ydHMudnVlUHJvcFZhbGlkYXRvciA9IHZvaWQgMDtcbmNvbnN0IHZ1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ2dWVcIikpO1xuLyoqXG4gKiBDcmVhdGVzIGEgVnVlIHByb3AgdmFsaWRhdG9yIHRoYXQgcnVucyBhbGwgdHlwZSB2YWxpZGF0b3JzIGFuZCB0aGUgdXNlciB2YWxpZGF0b3IgKGlmIHNwZWNpZmllZCkuXG4gKiBAcGFyYW0gdXNlclZhbGlkYXRvciBWYWxpZGF0b3IgZnVuY3Rpb24gc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxuICogQHBhcmFtIHR5cGVWYWxpZGF0b3JzIFZhbGlkYXRvciBmdW5jdGlvbnMgaGFyZC1jb2RlZCBieSB0aGUgcHJvcCB0eXBlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB2dWVQcm9wVmFsaWRhdG9yKHVzZXJWYWxpZGF0b3IsIC4uLnR5cGVWYWxpZGF0b3JzKSB7XG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IHVzZXJWYWxpZGF0b3IgPyBbLi4udHlwZVZhbGlkYXRvcnMsIHVzZXJWYWxpZGF0b3JdIDogdHlwZVZhbGlkYXRvcnM7XG4gICAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0b3Igb2YgdmFsaWRhdG9ycykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gdmFsaWRhdG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZ1ZV8xLmRlZmF1bHQgPT09ICdvYmplY3QnICYmICd1dGlsJyBpbiB2dWVfMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVnVlLnV0aWwgaXMgb25seSBhdmFpbGFibGUgaW4gVnVlIDIsIGJ1dCBwcm92aWRlcyBtb3JlIGNvbnRleHQgdGhhbiBjb25zb2xlLndhcm5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICAgICAgICAgIHZ1ZV8xLmRlZmF1bHQudXRpbC53YXJuKGAke2Vycm9yTWVzc2FnZX0gKHJlY2VpdmVkOiAnJHtTdHJpbmcodmFsdWUpfScpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7ZXJyb3JNZXNzYWdlfSAocmVjZWl2ZWQ6ICcke1N0cmluZyh2YWx1ZSl9JylgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5leHBvcnRzLnZ1ZVByb3BWYWxpZGF0b3IgPSB2dWVQcm9wVmFsaWRhdG9yO1xuLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG52YXIgaXNJbnN0YW5jZU9mXzEgPSByZXF1aXJlKFwiLi9pc0luc3RhbmNlT2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0luc3RhbmNlT2ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzSW5zdGFuY2VPZl8xLmlzSW5zdGFuY2VPZjsgfSB9KTtcbnZhciBpc0ludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2lzSW50ZWdlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW50ZWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNJbnRlZ2VyXzEuaXNJbnRlZ2VyOyB9IH0pO1xudmFyIGlzT25lT2ZfMSA9IHJlcXVpcmUoXCIuL2lzT25lT2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc09uZU9mXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc09uZU9mXzEuaXNPbmVPZjsgfSB9KTtcbnZhciBpc1N5bWJvbF8xID0gcmVxdWlyZShcIi4vaXNTeW1ib2xcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N5bWJvbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNTeW1ib2xfMS5pc1N5bWJvbDsgfSB9KTtcbi8vIGN1c3RvbSB2YWxpZGF0b3JzIHByb3ZpZGVkIGZvciB1c2VyIGNvbnZlbmllbmNlIGFyZSBleHBvcnRlZCBmcm9tIG1haW4gZW50cnlwb2ludFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/index.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isInstanceOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isInstanceOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInstanceOf = void 0;\n/** Validator that only allows instances of the given parent. */\nconst isInstanceOf = (parent) => value => {\n    if (!(value instanceof parent)) {\n        return `value should be an instance of ${parent.name}`;\n    }\n    return undefined;\n};\nexports.isInstanceOf = isInstanceOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc0luc3RhbmNlT2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2lzSW5zdGFuY2VPZi5qcz8yN2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0luc3RhbmNlT2YgPSB2b2lkIDA7XG4vKiogVmFsaWRhdG9yIHRoYXQgb25seSBhbGxvd3MgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBwYXJlbnQuICovXG5jb25zdCBpc0luc3RhbmNlT2YgPSAocGFyZW50KSA9PiB2YWx1ZSA9PiB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBgdmFsdWUgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mICR7cGFyZW50Lm5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzSW5zdGFuY2VPZiA9IGlzSW5zdGFuY2VPZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isInstanceOf.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isInteger.js":
/*!****************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isInteger.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInteger = void 0;\n/** Validator that only allows integer numbers. */\nconst isInteger = value => {\n    if (typeof value !== 'number' || !Number.isInteger(value)) {\n        return 'value should be an integer';\n    }\n    return undefined;\n};\nexports.isInteger = isInteger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc0ludGVnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS10cy10eXBlcy9kaXN0L3ZhbGlkYXRvcnMvaXNJbnRlZ2VyLmpzPzExNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSW50ZWdlciA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBpbnRlZ2VyIG51bWJlcnMuICovXG5jb25zdCBpc0ludGVnZXIgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAndmFsdWUgc2hvdWxkIGJlIGFuIGludGVnZXInO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isInteger.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isNegative.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isNegative.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNegative = void 0;\n/** Validator that only allows negative numbers (`< 0`). */\nconst isNegative = value => {\n    if (typeof value !== 'number' || value >= 0 || Number.isNaN(value)) {\n        return 'value should be a negative number';\n    }\n    return undefined;\n};\nexports.isNegative = isNegative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc05lZ2F0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2lzTmVnYXRpdmUuanM/MzNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNOZWdhdGl2ZSA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBuZWdhdGl2ZSBudW1iZXJzIChgPCAwYCkuICovXG5jb25zdCBpc05lZ2F0aXZlID0gdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlID49IDAgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ3ZhbHVlIHNob3VsZCBiZSBhIG5lZ2F0aXZlIG51bWJlcic7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5pc05lZ2F0aXZlID0gaXNOZWdhdGl2ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isNegative.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isNonNegative.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isNonNegative.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNonNegative = void 0;\n/** Validator that only allows non-negative numbers (`>= 0`). */\nconst isNonNegative = value => {\n    if (typeof value !== 'number' || value < 0 || Number.isNaN(value)) {\n        return 'value should be a non-negative number';\n    }\n    return undefined;\n};\nexports.isNonNegative = isNonNegative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc05vbk5lZ2F0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2lzTm9uTmVnYXRpdmUuanM/MzVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNOb25OZWdhdGl2ZSA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBub24tbmVnYXRpdmUgbnVtYmVycyAoYD49IDBgKS4gKi9cbmNvbnN0IGlzTm9uTmVnYXRpdmUgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICd2YWx1ZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzTm9uTmVnYXRpdmUgPSBpc05vbk5lZ2F0aXZlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isNonNegative.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isNonPositive.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isNonPositive.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNonPositive = void 0;\n/** Validator that only allows non-positive numbers (`<= 0`). */\nconst isNonPositive = value => {\n    if (typeof value !== 'number' || value > 0 || Number.isNaN(value)) {\n        return 'value should be a non-positive number';\n    }\n    return undefined;\n};\nexports.isNonPositive = isNonPositive;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc05vblBvc2l0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2lzTm9uUG9zaXRpdmUuanM/NWRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNOb25Qb3NpdGl2ZSA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBub24tcG9zaXRpdmUgbnVtYmVycyAoYDw9IDBgKS4gKi9cbmNvbnN0IGlzTm9uUG9zaXRpdmUgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPiAwIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICd2YWx1ZSBzaG91bGQgYmUgYSBub24tcG9zaXRpdmUgbnVtYmVyJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzTm9uUG9zaXRpdmUgPSBpc05vblBvc2l0aXZlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isNonPositive.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isOneOf.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isOneOf.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isOneOf = void 0;\n/** Validator that only allows any of the given values. */\nconst isOneOf = (allowedValues) => value => {\n    if (!allowedValues.includes(value)) {\n        return `value should be one of \"${allowedValues.join('\", \"')}\"`;\n    }\n    return undefined;\n};\nexports.isOneOf = isOneOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc09uZU9mLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc09uZU9mLmpzPzhhYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzT25lT2YgPSB2b2lkIDA7XG4vKiogVmFsaWRhdG9yIHRoYXQgb25seSBhbGxvd3MgYW55IG9mIHRoZSBnaXZlbiB2YWx1ZXMuICovXG5jb25zdCBpc09uZU9mID0gKGFsbG93ZWRWYWx1ZXMpID0+IHZhbHVlID0+IHtcbiAgICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBgdmFsdWUgc2hvdWxkIGJlIG9uZSBvZiBcIiR7YWxsb3dlZFZhbHVlcy5qb2luKCdcIiwgXCInKX1cImA7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5pc09uZU9mID0gaXNPbmVPZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isOneOf.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isPositive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isPositive.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPositive = void 0;\n/** Validator that only allows positive numbers (`> 0`). */\nconst isPositive = value => {\n    if (typeof value !== 'number' || value <= 0 || Number.isNaN(value)) {\n        return 'value should be a positive number';\n    }\n    return undefined;\n};\nexports.isPositive = isPositive;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc1Bvc2l0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtdHMtdHlwZXMvZGlzdC92YWxpZGF0b3JzL2lzUG9zaXRpdmUuanM/Njk2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNQb3NpdGl2ZSA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBwb3NpdGl2ZSBudW1iZXJzIChgPiAwYCkuICovXG5jb25zdCBpc1Bvc2l0aXZlID0gdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDw9IDAgfHwgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ3ZhbHVlIHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlcic7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5pc1Bvc2l0aXZlID0gaXNQb3NpdGl2ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isPositive.js\n");

/***/ }),

/***/ "./node_modules/vue-ts-types/dist/validators/isSymbol.js":
/*!***************************************************************!*\
  !*** ./node_modules/vue-ts-types/dist/validators/isSymbol.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSymbol = void 0;\n/** Validator that only allows symbols. */\nconst isSymbol = value => {\n    if (typeof value !== 'symbol') {\n        return 'value should be a symbol';\n    }\n    return undefined;\n};\nexports.isSymbol = isSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc1N5bWJvbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXRzLXR5cGVzL2Rpc3QvdmFsaWRhdG9ycy9pc1N5bWJvbC5qcz8xZGUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1N5bWJvbCA9IHZvaWQgMDtcbi8qKiBWYWxpZGF0b3IgdGhhdCBvbmx5IGFsbG93cyBzeW1ib2xzLiAqL1xuY29uc3QgaXNTeW1ib2wgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuICd2YWx1ZSBzaG91bGQgYmUgYSBzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-ts-types/dist/validators/isSymbol.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ extensions),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n\nfunction createChainableState(config) {\r\n    const { state, transaction } = config;\r\n    let { selection } = transaction;\r\n    let { doc } = transaction;\r\n    let { storedMarks } = transaction;\r\n    return {\r\n        ...state,\r\n        apply: state.apply.bind(state),\r\n        applyTransaction: state.applyTransaction.bind(state),\r\n        filterTransaction: state.filterTransaction,\r\n        plugins: state.plugins,\r\n        schema: state.schema,\r\n        reconfigure: state.reconfigure.bind(state),\r\n        toJSON: state.toJSON.bind(state),\r\n        get storedMarks() {\r\n            return storedMarks;\r\n        },\r\n        get selection() {\r\n            return selection;\r\n        },\r\n        get doc() {\r\n            return doc;\r\n        },\r\n        get tr() {\r\n            selection = transaction.selection;\r\n            doc = transaction.doc;\r\n            storedMarks = transaction.storedMarks;\r\n            return transaction;\r\n        },\r\n    };\r\n}\n\nclass CommandManager {\r\n    constructor(props) {\r\n        this.editor = props.editor;\r\n        this.rawCommands = this.editor.extensionManager.commands;\r\n        this.customState = props.state;\r\n    }\r\n    get hasCustomState() {\r\n        return !!this.customState;\r\n    }\r\n    get state() {\r\n        return this.customState || this.editor.state;\r\n    }\r\n    get commands() {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const { tr } = state;\r\n        const props = this.buildProps(tr);\r\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n            const method = (...args) => {\r\n                const callback = command(...args)(props);\r\n                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\r\n                    view.dispatch(tr);\r\n                }\r\n                return callback;\r\n            };\r\n            return [name, method];\r\n        }));\r\n    }\r\n    get chain() {\r\n        return () => this.createChain();\r\n    }\r\n    get can() {\r\n        return () => this.createCan();\r\n    }\r\n    createChain(startTr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const callbacks = [];\r\n        const hasStartTransaction = !!startTr;\r\n        const tr = startTr || state.tr;\r\n        const run = () => {\r\n            if (!hasStartTransaction\r\n                && shouldDispatch\r\n                && !tr.getMeta('preventDispatch')\r\n                && !this.hasCustomState) {\r\n                view.dispatch(tr);\r\n            }\r\n            return callbacks.every(callback => callback === true);\r\n        };\r\n        const chain = {\r\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n                const chainedCommand = (...args) => {\r\n                    const props = this.buildProps(tr, shouldDispatch);\r\n                    const callback = command(...args)(props);\r\n                    callbacks.push(callback);\r\n                    return chain;\r\n                };\r\n                return [name, chainedCommand];\r\n            })),\r\n            run,\r\n        };\r\n        return chain;\r\n    }\r\n    createCan(startTr) {\r\n        const { rawCommands, state } = this;\r\n        const dispatch = false;\r\n        const tr = startTr || state.tr;\r\n        const props = this.buildProps(tr, dispatch);\r\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n            return [name, (...args) => command(...args)({ ...props, dispatch: undefined })];\r\n        }));\r\n        return {\r\n            ...formattedCommands,\r\n            chain: () => this.createChain(tr, dispatch),\r\n        };\r\n    }\r\n    buildProps(tr, shouldDispatch = true) {\r\n        const { rawCommands, editor, state } = this;\r\n        const { view } = editor;\r\n        const props = {\r\n            tr,\r\n            editor,\r\n            view,\r\n            state: createChainableState({\r\n                state,\r\n                transaction: tr,\r\n            }),\r\n            dispatch: shouldDispatch ? () => undefined : undefined,\r\n            chain: () => this.createChain(tr, shouldDispatch),\r\n            can: () => this.createCan(tr),\r\n            get commands() {\r\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\r\n                    return [name, (...args) => command(...args)(props)];\r\n                }));\r\n            },\r\n        };\r\n        return props;\r\n    }\r\n}\n\nclass EventEmitter {\r\n    constructor() {\r\n        this.callbacks = {};\r\n    }\r\n    on(event, fn) {\r\n        if (!this.callbacks[event]) {\r\n            this.callbacks[event] = [];\r\n        }\r\n        this.callbacks[event].push(fn);\r\n        return this;\r\n    }\r\n    emit(event, ...args) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            callbacks.forEach(callback => callback.apply(this, args));\r\n        }\r\n        return this;\r\n    }\r\n    off(event, fn) {\r\n        const callbacks = this.callbacks[event];\r\n        if (callbacks) {\r\n            if (fn) {\r\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\r\n            }\r\n            else {\r\n                delete this.callbacks[event];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    removeAllListeners() {\r\n        this.callbacks = {};\r\n    }\r\n}\n\nfunction getExtensionField(extension, field, context) {\r\n    if (extension.config[field] === undefined && extension.parent) {\r\n        return getExtensionField(extension.parent, field, context);\r\n    }\r\n    if (typeof extension.config[field] === 'function') {\r\n        const value = extension.config[field].bind({\r\n            ...context,\r\n            parent: extension.parent\r\n                ? getExtensionField(extension.parent, field, context)\r\n                : null,\r\n        });\r\n        return value;\r\n    }\r\n    return extension.config[field];\r\n}\n\nfunction splitExtensions(extensions) {\r\n    const baseExtensions = extensions.filter(extension => extension.type === 'extension');\r\n    const nodeExtensions = extensions.filter(extension => extension.type === 'node');\r\n    const markExtensions = extensions.filter(extension => extension.type === 'mark');\r\n    return {\r\n        baseExtensions,\r\n        nodeExtensions,\r\n        markExtensions,\r\n    };\r\n}\n\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\r\nfunction getAttributesFromExtensions(extensions) {\r\n    const extensionAttributes = [];\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\r\n    const defaultAttribute = {\r\n        default: null,\r\n        rendered: true,\r\n        renderHTML: null,\r\n        parseHTML: null,\r\n        keepOnSplit: true,\r\n        isRequired: false,\r\n    };\r\n    extensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\r\n        if (!addGlobalAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as GlobalAttributes`\r\n        const globalAttributes = addGlobalAttributes();\r\n        globalAttributes.forEach(globalAttribute => {\r\n            globalAttribute.types.forEach(type => {\r\n                Object\r\n                    .entries(globalAttribute.attributes)\r\n                    .forEach(([name, attribute]) => {\r\n                    extensionAttributes.push({\r\n                        type,\r\n                        name,\r\n                        attribute: {\r\n                            ...defaultAttribute,\r\n                            ...attribute,\r\n                        },\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    });\r\n    nodeAndMarkExtensions.forEach(extension => {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        const addAttributes = getExtensionField(extension, 'addAttributes', context);\r\n        if (!addAttributes) {\r\n            return;\r\n        }\r\n        // TODO: remove `as Attributes`\r\n        const attributes = addAttributes();\r\n        Object\r\n            .entries(attributes)\r\n            .forEach(([name, attribute]) => {\r\n            const mergedAttr = {\r\n                ...defaultAttribute,\r\n                ...attribute,\r\n            };\r\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\r\n                mergedAttr.default = mergedAttr.default();\r\n            }\r\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\r\n                delete mergedAttr.default;\r\n            }\r\n            extensionAttributes.push({\r\n                type: extension.name,\r\n                name,\r\n                attribute: mergedAttr,\r\n            });\r\n        });\r\n    });\r\n    return extensionAttributes;\r\n}\n\nfunction getNodeType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.nodes[nameOrType]) {\r\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.nodes[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nfunction mergeAttributes(...objects) {\r\n    return objects\r\n        .filter(item => !!item)\r\n        .reduce((items, item) => {\r\n        const mergedAttributes = { ...items };\r\n        Object.entries(item).forEach(([key, value]) => {\r\n            const exists = mergedAttributes[key];\r\n            if (!exists) {\r\n                mergedAttributes[key] = value;\r\n                return;\r\n            }\r\n            if (key === 'class') {\r\n                const valueClasses = value ? value.split(' ') : [];\r\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\r\n                const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\r\n                mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\r\n            }\r\n            else if (key === 'style') {\r\n                mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\r\n            }\r\n            else {\r\n                mergedAttributes[key] = value;\r\n            }\r\n        });\r\n        return mergedAttributes;\r\n    }, {});\r\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\r\n    return extensionAttributes\r\n        .filter(item => item.attribute.rendered)\r\n        .map(item => {\r\n        if (!item.attribute.renderHTML) {\r\n            return {\r\n                [item.name]: nodeOrMark.attrs[item.name],\r\n            };\r\n        }\r\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\r\n    })\r\n        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\r\n}\n\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\n\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\r\nfunction callOrReturn(value, context = undefined, ...props) {\r\n    if (isFunction(value)) {\r\n        if (context) {\r\n            return value.bind(context)(...props);\r\n        }\r\n        return value(...props);\r\n    }\r\n    return value;\r\n}\n\nfunction isEmptyObject(value = {}) {\r\n    return Object.keys(value).length === 0 && value.constructor === Object;\r\n}\n\nfunction fromString(value) {\r\n    if (typeof value !== 'string') {\r\n        return value;\r\n    }\r\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\r\n        return Number(value);\r\n    }\r\n    if (value === 'true') {\r\n        return true;\r\n    }\r\n    if (value === 'false') {\r\n        return false;\r\n    }\r\n    return value;\r\n}\n\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\r\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\r\n    if (parseRule.style) {\r\n        return parseRule;\r\n    }\r\n    return {\r\n        ...parseRule,\r\n        getAttrs: node => {\r\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\r\n            if (oldAttributes === false) {\r\n                return false;\r\n            }\r\n            const newAttributes = extensionAttributes.reduce((items, item) => {\r\n                const value = item.attribute.parseHTML\r\n                    ? item.attribute.parseHTML(node)\r\n                    : fromString(node.getAttribute(item.name));\r\n                if (value === null || value === undefined) {\r\n                    return items;\r\n                }\r\n                return {\r\n                    ...items,\r\n                    [item.name]: value,\r\n                };\r\n            }, {});\r\n            return { ...oldAttributes, ...newAttributes };\r\n        },\r\n    };\r\n}\n\nfunction cleanUpSchemaItem(data) {\r\n    return Object.fromEntries(\r\n    // @ts-ignore\r\n    Object.entries(data).filter(([key, value]) => {\r\n        if (key === 'attrs' && isEmptyObject(value)) {\r\n            return false;\r\n        }\r\n        return value !== null && value !== undefined;\r\n    }));\r\n}\r\nfunction getSchemaByResolvedExtensions(extensions, editor) {\r\n    var _a;\r\n    const allAttributes = getAttributesFromExtensions(extensions);\r\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\r\n    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\r\n    const nodes = Object.fromEntries(nodeExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n            editor,\r\n        };\r\n        const extraNodeFields = extensions.reduce((fields, e) => {\r\n            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraNodeFields,\r\n            content: callOrReturn(getExtensionField(extension, 'content', context)),\r\n            marks: callOrReturn(getExtensionField(extension, 'marks', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            inline: callOrReturn(getExtensionField(extension, 'inline', context)),\r\n            atom: callOrReturn(getExtensionField(extension, 'atom', context)),\r\n            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\r\n            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            defining: callOrReturn(getExtensionField(extension, 'defining', context)),\r\n            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = node => renderHTML({\r\n                node,\r\n                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\r\n            });\r\n        }\r\n        const renderText = getExtensionField(extension, 'renderText', context);\r\n        if (renderText) {\r\n            schema.toText = renderText;\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    const marks = Object.fromEntries(markExtensions.map(extension => {\r\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n            editor,\r\n        };\r\n        const extraMarkFields = extensions.reduce((fields, e) => {\r\n            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\r\n            return {\r\n                ...fields,\r\n                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\r\n            };\r\n        }, {});\r\n        const schema = cleanUpSchemaItem({\r\n            ...extraMarkFields,\r\n            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\r\n            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\r\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\r\n            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\r\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\r\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\r\n                var _a;\r\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\r\n            })),\r\n        });\r\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\r\n        if (parseHTML) {\r\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\r\n        }\r\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\r\n        if (renderHTML) {\r\n            schema.toDOM = mark => renderHTML({\r\n                mark,\r\n                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\r\n            });\r\n        }\r\n        return [extension.name, schema];\r\n    }));\r\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\r\n        topNode,\r\n        nodes,\r\n        marks,\r\n    });\r\n}\n\nfunction getSchemaTypeByName(name, schema) {\r\n    return schema.nodes[name] || schema.marks[name] || null;\r\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\r\n    if (Array.isArray(enabled)) {\r\n        return enabled.some(enabledExtension => {\r\n            const name = typeof enabledExtension === 'string'\r\n                ? enabledExtension\r\n                : enabledExtension.name;\r\n            return name === extension.name;\r\n        });\r\n    }\r\n    return enabled;\r\n}\n\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\r\n    let textBefore = '';\r\n    const sliceEndPos = $from.parentOffset;\r\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\r\n        var _a, _b;\r\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\r\n            node,\r\n            pos,\r\n            parent,\r\n            index,\r\n        }))\r\n            || node.textContent\r\n            || '%leaf%';\r\n        textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\r\n    });\r\n    return textBefore;\r\n};\n\nfunction isRegExp(value) {\r\n    return Object.prototype.toString.call(value) === '[object RegExp]';\r\n}\n\nclass InputRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst inputRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return find.exec(text);\r\n    }\r\n    const inputRuleMatch = find(text);\r\n    if (!inputRuleMatch) {\r\n        return null;\r\n    }\r\n    const result = [inputRuleMatch.text];\r\n    result.index = inputRuleMatch.index;\r\n    result.input = text;\r\n    result.data = inputRuleMatch.data;\r\n    if (inputRuleMatch.replaceWith) {\r\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\r\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\r\n        }\r\n        result.push(inputRuleMatch.replaceWith);\r\n    }\r\n    return result;\r\n};\r\nfunction run$1(config) {\r\n    var _a;\r\n    const { editor, from, to, text, rules, plugin, } = config;\r\n    const { view } = editor;\r\n    if (view.composing) {\r\n        return false;\r\n    }\r\n    const $from = view.state.doc.resolve(from);\r\n    if (\r\n    // check for code node\r\n    $from.parent.type.spec.code\r\n        // check for code mark\r\n        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\r\n        return false;\r\n    }\r\n    let matched = false;\r\n    const textBefore = getTextContentFromNodes($from) + text;\r\n    rules.forEach(rule => {\r\n        if (matched) {\r\n            return;\r\n        }\r\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\r\n        if (!match) {\r\n            return;\r\n        }\r\n        const tr = view.state.tr;\r\n        const state = createChainableState({\r\n            state: view.state,\r\n            transaction: tr,\r\n        });\r\n        const range = {\r\n            from: from - (match[0].length - text.length),\r\n            to,\r\n        };\r\n        const { commands, chain, can } = new CommandManager({\r\n            editor,\r\n            state,\r\n        });\r\n        const handler = rule.handler({\r\n            state,\r\n            range,\r\n            match,\r\n            commands,\r\n            chain,\r\n            can,\r\n        });\r\n        // stop if there are no changes\r\n        if (handler === null || !tr.steps.length) {\r\n            return;\r\n        }\r\n        // store transform as meta data\r\n        // so we can undo input rules within the `undoInputRules` command\r\n        tr.setMeta(plugin, {\r\n            transform: tr,\r\n            from,\r\n            to,\r\n            text,\r\n        });\r\n        view.dispatch(tr);\r\n        matched = true;\r\n    });\r\n    return matched;\r\n}\r\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction inputRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n        state: {\r\n            init() {\r\n                return null;\r\n            },\r\n            apply(tr, prev) {\r\n                const stored = tr.getMeta(plugin);\r\n                if (stored) {\r\n                    return stored;\r\n                }\r\n                return tr.selectionSet || tr.docChanged ? null : prev;\r\n            },\r\n        },\r\n        props: {\r\n            handleTextInput(view, from, to, text) {\r\n                return run$1({\r\n                    editor,\r\n                    from,\r\n                    to,\r\n                    text,\r\n                    rules,\r\n                    plugin,\r\n                });\r\n            },\r\n            handleDOMEvents: {\r\n                compositionend: view => {\r\n                    setTimeout(() => {\r\n                        const { $cursor } = view.state.selection;\r\n                        if ($cursor) {\r\n                            run$1({\r\n                                editor,\r\n                                from: $cursor.pos,\r\n                                to: $cursor.pos,\r\n                                text: '',\r\n                                rules,\r\n                                plugin,\r\n                            });\r\n                        }\r\n                    });\r\n                    return false;\r\n                },\r\n            },\r\n            // add support for input rules to trigger on enter\r\n            // this is useful for example for code blocks\r\n            handleKeyDown(view, event) {\r\n                if (event.key !== 'Enter') {\r\n                    return false;\r\n                }\r\n                const { $cursor } = view.state.selection;\r\n                if ($cursor) {\r\n                    return run$1({\r\n                        editor,\r\n                        from: $cursor.pos,\r\n                        to: $cursor.pos,\r\n                        text: '\\n',\r\n                        rules,\r\n                        plugin,\r\n                    });\r\n                }\r\n                return false;\r\n            },\r\n        },\r\n        // @ts-ignore\r\n        isInputRules: true,\r\n    });\r\n    return plugin;\r\n}\n\nfunction isNumber(value) {\r\n    return typeof value === 'number';\r\n}\n\nclass PasteRule {\r\n    constructor(config) {\r\n        this.find = config.find;\r\n        this.handler = config.handler;\r\n    }\r\n}\r\nconst pasteRuleMatcherHandler = (text, find) => {\r\n    if (isRegExp(find)) {\r\n        return [...text.matchAll(find)];\r\n    }\r\n    const matches = find(text);\r\n    if (!matches) {\r\n        return [];\r\n    }\r\n    return matches.map(pasteRuleMatch => {\r\n        const result = [pasteRuleMatch.text];\r\n        result.index = pasteRuleMatch.index;\r\n        result.input = text;\r\n        result.data = pasteRuleMatch.data;\r\n        if (pasteRuleMatch.replaceWith) {\r\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\r\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\r\n            }\r\n            result.push(pasteRuleMatch.replaceWith);\r\n        }\r\n        return result;\r\n    });\r\n};\r\nfunction run(config) {\r\n    const { editor, state, from, to, rule, } = config;\r\n    const { commands, chain, can } = new CommandManager({\r\n        editor,\r\n        state,\r\n    });\r\n    const handlers = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (!node.isTextblock || node.type.spec.code) {\r\n            return;\r\n        }\r\n        const resolvedFrom = Math.max(from, pos);\r\n        const resolvedTo = Math.min(to, pos + node.content.size);\r\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\r\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\r\n        matches.forEach(match => {\r\n            if (match.index === undefined) {\r\n                return;\r\n            }\r\n            const start = resolvedFrom + match.index + 1;\r\n            const end = start + match[0].length;\r\n            const range = {\r\n                from: state.tr.mapping.map(start),\r\n                to: state.tr.mapping.map(end),\r\n            };\r\n            const handler = rule.handler({\r\n                state,\r\n                range,\r\n                match,\r\n                commands,\r\n                chain,\r\n                can,\r\n            });\r\n            handlers.push(handler);\r\n        });\r\n    });\r\n    const success = handlers.every(handler => handler !== null);\r\n    return success;\r\n}\r\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\r\nfunction pasteRulesPlugin(props) {\r\n    const { editor, rules } = props;\r\n    let dragSourceElement = null;\r\n    let isPastedFromProseMirror = false;\r\n    let isDroppedFromProseMirror = false;\r\n    const plugins = rules.map(rule => {\r\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n            // we register a global drag handler to track the current drag source element\r\n            view(view) {\r\n                const handleDragstart = (event) => {\r\n                    var _a;\r\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))\r\n                        ? view.dom.parentElement\r\n                        : null;\r\n                };\r\n                window.addEventListener('dragstart', handleDragstart);\r\n                return {\r\n                    destroy() {\r\n                        window.removeEventListener('dragstart', handleDragstart);\r\n                    },\r\n                };\r\n            },\r\n            props: {\r\n                handleDOMEvents: {\r\n                    drop: view => {\r\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\r\n                        return false;\r\n                    },\r\n                    paste: (view, event) => {\r\n                        var _a;\r\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\r\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\r\n                        return false;\r\n                    },\r\n                },\r\n            },\r\n            appendTransaction: (transactions, oldState, state) => {\r\n                const transaction = transactions[0];\r\n                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\r\n                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\r\n                if (!isPaste && !isDrop) {\r\n                    return;\r\n                }\r\n                // stop if there is no changed range\r\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\r\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\r\n                if (!isNumber(from) || !to || from === to.b) {\r\n                    return;\r\n                }\r\n                // build a chainable state\r\n                // so we can use a single transaction for all paste rules\r\n                const tr = state.tr;\r\n                const chainableState = createChainableState({\r\n                    state,\r\n                    transaction: tr,\r\n                });\r\n                const handler = run({\r\n                    editor,\r\n                    state: chainableState,\r\n                    from: Math.max(from - 1, 0),\r\n                    to: to.b - 1,\r\n                    rule,\r\n                });\r\n                // stop if there are no changes\r\n                if (!handler || !tr.steps.length) {\r\n                    return;\r\n                }\r\n                return tr;\r\n            },\r\n        });\r\n    });\r\n    return plugins;\r\n}\n\nfunction findDuplicates(items) {\r\n    const filtered = items.filter((el, index) => items.indexOf(el) !== index);\r\n    return [...new Set(filtered)];\r\n}\n\nclass ExtensionManager {\r\n    constructor(extensions, editor) {\r\n        this.splittableMarks = [];\r\n        this.editor = editor;\r\n        this.extensions = ExtensionManager.resolve(extensions);\r\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\r\n        this.extensions.forEach(extension => {\r\n            var _a;\r\n            // store extension storage in editor\r\n            this.editor.extensionStorage[extension.name] = extension.storage;\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            if (extension.type === 'mark') {\r\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\r\n                if (keepOnSplit) {\r\n                    this.splittableMarks.push(extension.name);\r\n                }\r\n            }\r\n            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\r\n            if (onBeforeCreate) {\r\n                this.editor.on('beforeCreate', onBeforeCreate);\r\n            }\r\n            const onCreate = getExtensionField(extension, 'onCreate', context);\r\n            if (onCreate) {\r\n                this.editor.on('create', onCreate);\r\n            }\r\n            const onUpdate = getExtensionField(extension, 'onUpdate', context);\r\n            if (onUpdate) {\r\n                this.editor.on('update', onUpdate);\r\n            }\r\n            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\r\n            if (onSelectionUpdate) {\r\n                this.editor.on('selectionUpdate', onSelectionUpdate);\r\n            }\r\n            const onTransaction = getExtensionField(extension, 'onTransaction', context);\r\n            if (onTransaction) {\r\n                this.editor.on('transaction', onTransaction);\r\n            }\r\n            const onFocus = getExtensionField(extension, 'onFocus', context);\r\n            if (onFocus) {\r\n                this.editor.on('focus', onFocus);\r\n            }\r\n            const onBlur = getExtensionField(extension, 'onBlur', context);\r\n            if (onBlur) {\r\n                this.editor.on('blur', onBlur);\r\n            }\r\n            const onDestroy = getExtensionField(extension, 'onDestroy', context);\r\n            if (onDestroy) {\r\n                this.editor.on('destroy', onDestroy);\r\n            }\r\n        });\r\n    }\r\n    static resolve(extensions) {\r\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\r\n        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\r\n        if (duplicatedNames.length) {\r\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames\r\n                .map(item => `'${item}'`)\r\n                .join(', ')}]. This can lead to issues.`);\r\n        }\r\n        return resolvedExtensions;\r\n    }\r\n    static flatten(extensions) {\r\n        return (extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n            };\r\n            const addExtensions = getExtensionField(extension, 'addExtensions', context);\r\n            if (addExtensions) {\r\n                return [extension, ...this.flatten(addExtensions())];\r\n            }\r\n            return extension;\r\n        })\r\n            // `Infinity` will break TypeScript so we set a number that is probably high enough\r\n            .flat(10));\r\n    }\r\n    static sort(extensions) {\r\n        const defaultPriority = 100;\r\n        return extensions.sort((a, b) => {\r\n            const priorityA = getExtensionField(a, 'priority') || defaultPriority;\r\n            const priorityB = getExtensionField(b, 'priority') || defaultPriority;\r\n            if (priorityA > priorityB) {\r\n                return -1;\r\n            }\r\n            if (priorityA < priorityB) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n    get commands() {\r\n        return this.extensions.reduce((commands, extension) => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor: this.editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const addCommands = getExtensionField(extension, 'addCommands', context);\r\n            if (!addCommands) {\r\n                return commands;\r\n            }\r\n            return {\r\n                ...commands,\r\n                ...addCommands(),\r\n            };\r\n        }, {});\r\n    }\r\n    get plugins() {\r\n        const { editor } = this;\r\n        // With ProseMirror, first plugins within an array are executed first.\r\n        // In Tiptap, we provide the ability to override plugins,\r\n        // so it feels more natural to run plugins at the end of an array first.\r\n        // That’s why we have to reverse the `extensions` array and sort again\r\n        // based on the `priority` option.\r\n        const extensions = ExtensionManager.sort([...this.extensions].reverse());\r\n        const inputRules = [];\r\n        const pasteRules = [];\r\n        const allPlugins = extensions\r\n            .map(extension => {\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getSchemaTypeByName(extension.name, this.schema),\r\n            };\r\n            const plugins = [];\r\n            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\r\n            let defaultBindings = {};\r\n            // bind exit handling\r\n            if (extension.type === 'mark' && extension.config.exitable) {\r\n                defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\r\n            }\r\n            if (addKeyboardShortcuts) {\r\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\r\n                    return [shortcut, () => method({ editor })];\r\n                }));\r\n                defaultBindings = { ...defaultBindings, ...bindings };\r\n            }\r\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\r\n            plugins.push(keyMapPlugin);\r\n            const addInputRules = getExtensionField(extension, 'addInputRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\r\n                inputRules.push(...addInputRules());\r\n            }\r\n            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\r\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\r\n                pasteRules.push(...addPasteRules());\r\n            }\r\n            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\r\n            if (addProseMirrorPlugins) {\r\n                const proseMirrorPlugins = addProseMirrorPlugins();\r\n                plugins.push(...proseMirrorPlugins);\r\n            }\r\n            return plugins;\r\n        })\r\n            .flat();\r\n        return [\r\n            inputRulesPlugin({\r\n                editor,\r\n                rules: inputRules,\r\n            }),\r\n            ...pasteRulesPlugin({\r\n                editor,\r\n                rules: pasteRules,\r\n            }),\r\n            ...allPlugins,\r\n        ];\r\n    }\r\n    get attributes() {\r\n        return getAttributesFromExtensions(this.extensions);\r\n    }\r\n    get nodeViews() {\r\n        const { editor } = this;\r\n        const { nodeExtensions } = splitExtensions(this.extensions);\r\n        return Object.fromEntries(nodeExtensions\r\n            .filter(extension => !!getExtensionField(extension, 'addNodeView'))\r\n            .map(extension => {\r\n            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\r\n            const context = {\r\n                name: extension.name,\r\n                options: extension.options,\r\n                storage: extension.storage,\r\n                editor,\r\n                type: getNodeType(extension.name, this.schema),\r\n            };\r\n            const addNodeView = getExtensionField(extension, 'addNodeView', context);\r\n            if (!addNodeView) {\r\n                return [];\r\n            }\r\n            const nodeview = (node, view, getPos, decorations) => {\r\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\r\n                return addNodeView()({\r\n                    editor,\r\n                    node,\r\n                    getPos,\r\n                    decorations,\r\n                    HTMLAttributes,\r\n                    extension,\r\n                });\r\n            };\r\n            return [extension.name, nodeview];\r\n        }));\r\n    }\r\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\r\nfunction getType(value) {\r\n    return Object.prototype.toString.call(value).slice(8, -1);\r\n}\r\nfunction isPlainObject(value) {\r\n    if (getType(value) !== 'Object') {\r\n        return false;\r\n    }\r\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\r\n}\n\nfunction mergeDeep(target, source) {\r\n    const output = { ...target };\r\n    if (isPlainObject(target) && isPlainObject(source)) {\r\n        Object.keys(source).forEach(key => {\r\n            if (isPlainObject(source[key])) {\r\n                if (!(key in target)) {\r\n                    Object.assign(output, { [key]: source[key] });\r\n                }\r\n                else {\r\n                    output[key] = mergeDeep(target[key], source[key]);\r\n                }\r\n            }\r\n            else {\r\n                Object.assign(output, { [key]: source[key] });\r\n            }\r\n        });\r\n    }\r\n    return output;\r\n}\n\nclass Extension {\r\n    constructor(config = {}) {\r\n        this.type = 'extension';\r\n        this.name = 'extension';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Extension(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Extension(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nfunction getTextBetween(startNode, range, options) {\r\n    const { from, to } = range;\r\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\r\n    let text = '';\r\n    let separated = true;\r\n    startNode.nodesBetween(from, to, (node, pos, parent, index) => {\r\n        var _a;\r\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\r\n        if (textSerializer) {\r\n            if (node.isBlock && !separated) {\r\n                text += blockSeparator;\r\n                separated = true;\r\n            }\r\n            if (parent) {\r\n                text += textSerializer({\r\n                    node,\r\n                    pos,\r\n                    parent,\r\n                    index,\r\n                    range,\r\n                });\r\n            }\r\n        }\r\n        else if (node.isText) {\r\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\r\n            separated = false;\r\n        }\r\n        else if (node.isBlock && !separated) {\r\n            text += blockSeparator;\r\n            separated = true;\r\n        }\r\n    });\r\n    return text;\r\n}\n\nfunction getTextSerializersFromSchema(schema) {\r\n    return Object.fromEntries(Object.entries(schema.nodes)\r\n        .filter(([, node]) => node.spec.toText)\r\n        .map(([name, node]) => [name, node.spec.toText]));\r\n}\n\nconst ClipboardTextSerializer = Extension.create({\r\n    name: 'clipboardTextSerializer',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clipboardTextSerializer'),\r\n                props: {\r\n                    clipboardTextSerializer: () => {\r\n                        const { editor } = this;\r\n                        const { state, schema } = editor;\r\n                        const { doc, selection } = state;\r\n                        const { ranges } = selection;\r\n                        const from = Math.min(...ranges.map(range => range.$from.pos));\r\n                        const to = Math.max(...ranges.map(range => range.$to.pos));\r\n                        const textSerializers = getTextSerializersFromSchema(schema);\r\n                        const range = { from, to };\r\n                        return getTextBetween(doc, range, {\r\n                            textSerializers,\r\n                        });\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst blur = () => ({ editor, view }) => {\r\n    requestAnimationFrame(() => {\r\n        var _a;\r\n        if (!editor.isDestroyed) {\r\n            view.dom.blur();\r\n            // Browsers should remove the caret on blur but safari does not.\r\n            // See: https://github.com/ueberdosis/tiptap/issues/2405\r\n            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\r\n        }\r\n    });\r\n    return true;\r\n};\n\nconst clearContent = (emitUpdate = false) => ({ commands }) => {\r\n    return commands.setContent('', emitUpdate);\r\n};\n\nconst clearNodes = () => ({ state, tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    ranges.forEach(({ $from, $to }) => {\r\n        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\r\n            if (node.type.isText) {\r\n                return;\r\n            }\r\n            const { doc, mapping } = tr;\r\n            const $mappedFrom = doc.resolve(mapping.map(pos));\r\n            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\r\n            const nodeRange = $mappedFrom.blockRange($mappedTo);\r\n            if (!nodeRange) {\r\n                return;\r\n            }\r\n            const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\r\n            if (node.type.isTextblock) {\r\n                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\r\n                tr.setNodeMarkup(nodeRange.start, defaultType);\r\n            }\r\n            if (targetLiftDepth || targetLiftDepth === 0) {\r\n                tr.lift(nodeRange, targetLiftDepth);\r\n            }\r\n        });\r\n    });\r\n    return true;\r\n};\n\nconst command = fn => props => {\r\n    return fn(props);\r\n};\n\nconst createParagraphNear = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\r\n};\n\nconst cut = (originRange, targetPos) => ({ editor, tr }) => {\r\n    const { state } = editor;\r\n    const contentSlice = state.doc.slice(originRange.from, originRange.to);\r\n    tr.deleteRange(originRange.from, originRange.to);\r\n    const newPos = tr.mapping.map(targetPos);\r\n    tr.insert(newPos, contentSlice.content);\r\n    tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(newPos - 1)));\r\n    return true;\r\n};\n\nconst deleteCurrentNode = () => ({ tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const currentNode = selection.$anchor.node();\r\n    // if there is content inside the current node, break out of this command\r\n    if (currentNode.content.size > 0) {\r\n        return false;\r\n    }\r\n    const $pos = tr.selection.$anchor;\r\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\r\n        const node = $pos.node(depth);\r\n        if (node.type === currentNode.type) {\r\n            if (dispatch) {\r\n                const from = $pos.before(depth);\r\n                const to = $pos.after(depth);\r\n                tr.delete(from, to).scrollIntoView();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nconst deleteNode = typeOrName => ({ tr, state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const $pos = tr.selection.$anchor;\r\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\r\n        const node = $pos.node(depth);\r\n        if (node.type === type) {\r\n            if (dispatch) {\r\n                const from = $pos.before(depth);\r\n                const to = $pos.after(depth);\r\n                tr.delete(from, to).scrollIntoView();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nconst deleteRange = range => ({ tr, dispatch }) => {\r\n    const { from, to } = range;\r\n    if (dispatch) {\r\n        tr.delete(from, to);\r\n    }\r\n    return true;\r\n};\n\nconst deleteSelection = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\r\n};\n\nconst enter = () => ({ commands }) => {\r\n    return commands.keyboardShortcut('Enter');\r\n};\n\nconst exitCode = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\r\n};\n\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\r\nfunction objectIncludes(object1, object2, options = { strict: true }) {\r\n    const keys = Object.keys(object2);\r\n    if (!keys.length) {\r\n        return true;\r\n    }\r\n    return keys.every(key => {\r\n        if (options.strict) {\r\n            return object2[key] === object1[key];\r\n        }\r\n        if (isRegExp(object2[key])) {\r\n            return object2[key].test(object1[key]);\r\n        }\r\n        return object2[key] === object1[key];\r\n    });\r\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\r\n    return marks.find(item => {\r\n        return item.type === type && objectIncludes(item.attrs, attributes);\r\n    });\r\n}\r\nfunction isMarkInSet(marks, type, attributes = {}) {\r\n    return !!findMarkInSet(marks, type, attributes);\r\n}\r\nfunction getMarkRange($pos, type, attributes = {}) {\r\n    if (!$pos || !type) {\r\n        return;\r\n    }\r\n    let start = $pos.parent.childAfter($pos.parentOffset);\r\n    if ($pos.parentOffset === start.offset && start.offset !== 0) {\r\n        start = $pos.parent.childBefore($pos.parentOffset);\r\n    }\r\n    if (!start.node) {\r\n        return;\r\n    }\r\n    const mark = findMarkInSet([...start.node.marks], type, attributes);\r\n    if (!mark) {\r\n        return;\r\n    }\r\n    let startIndex = start.index;\r\n    let startPos = $pos.start() + start.offset;\r\n    let endIndex = startIndex + 1;\r\n    let endPos = startPos + start.node.nodeSize;\r\n    findMarkInSet([...start.node.marks], type, attributes);\r\n    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\r\n        startIndex -= 1;\r\n        startPos -= $pos.parent.child(startIndex).nodeSize;\r\n    }\r\n    while (endIndex < $pos.parent.childCount\r\n        && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\r\n        endPos += $pos.parent.child(endIndex).nodeSize;\r\n        endIndex += 1;\r\n    }\r\n    return {\r\n        from: startPos,\r\n        to: endPos,\r\n    };\r\n}\n\nfunction getMarkType(nameOrType, schema) {\r\n    if (typeof nameOrType === 'string') {\r\n        if (!schema.marks[nameOrType]) {\r\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\r\n        }\r\n        return schema.marks[nameOrType];\r\n    }\r\n    return nameOrType;\r\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { doc, selection } = tr;\r\n    const { $from, from, to } = selection;\r\n    if (dispatch) {\r\n        const range = getMarkRange($from, type, attributes);\r\n        if (range && range.from <= from && range.to >= to) {\r\n            const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\r\n            tr.setSelection(newSelection);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nconst first = commands => props => {\r\n    const items = typeof commands === 'function'\r\n        ? commands(props)\r\n        : commands;\r\n    for (let i = 0; i < items.length; i += 1) {\r\n        if (items[i](props)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nfunction isTextSelection(value) {\r\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\r\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\r\n    return Math.min(Math.max(value, min), max);\r\n}\n\nfunction resolveFocusPosition(doc, position = null) {\r\n    if (!position) {\r\n        return null;\r\n    }\r\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\r\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\r\n    if (position === 'start' || position === true) {\r\n        return selectionAtStart;\r\n    }\r\n    if (position === 'end') {\r\n        return selectionAtEnd;\r\n    }\r\n    const minPos = selectionAtStart.from;\r\n    const maxPos = selectionAtEnd.to;\r\n    if (position === 'all') {\r\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\r\n    }\r\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\r\n}\n\nfunction isiOS() {\r\n    return [\r\n        'iPad Simulator',\r\n        'iPhone Simulator',\r\n        'iPod Simulator',\r\n        'iPad',\r\n        'iPhone',\r\n        'iPod',\r\n    ].includes(navigator.platform)\r\n        // iPad on iOS 13 detection\r\n        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\r\n}\n\nconst focus = (position = null, options = {}) => ({ editor, view, tr, dispatch, }) => {\r\n    options = {\r\n        scrollIntoView: true,\r\n        ...options,\r\n    };\r\n    const delayedFocus = () => {\r\n        // focus within `requestAnimationFrame` breaks focus on iOS\r\n        // so we have to call this\r\n        if (isiOS()) {\r\n            view.dom.focus();\r\n        }\r\n        // For React we have to focus asynchronously. Otherwise wild things happen.\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1520\r\n        requestAnimationFrame(() => {\r\n            if (!editor.isDestroyed) {\r\n                view.focus();\r\n                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\r\n                    editor.commands.scrollIntoView();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    if ((view.hasFocus() && position === null) || position === false) {\r\n        return true;\r\n    }\r\n    // we don’t try to resolve a NodeSelection or CellSelection\r\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\r\n        delayedFocus();\r\n        return true;\r\n    }\r\n    // pass through tr.doc instead of editor.state.doc\r\n    // since transactions could change the editors state before this command has been run\r\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\r\n    const isSameSelection = editor.state.selection.eq(selection);\r\n    if (dispatch) {\r\n        if (!isSameSelection) {\r\n            tr.setSelection(selection);\r\n        }\r\n        // `tr.setSelection` resets the stored marks\r\n        // so we’ll restore them if the selection is the same as before\r\n        if (isSameSelection && tr.storedMarks) {\r\n            tr.setStoredMarks(tr.storedMarks);\r\n        }\r\n        delayedFocus();\r\n    }\r\n    return true;\r\n};\n\nconst forEach = (items, fn) => props => {\r\n    return items.every((item, index) => fn(item, { ...props, index }));\r\n};\n\nconst insertContent = (value, options) => ({ tr, commands }) => {\r\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\r\n};\n\nfunction elementFromString(value) {\r\n    // add a wrapper to preserve leading and trailing whitespace\r\n    const wrappedValue = `<body>${value}</body>`;\r\n    return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\r\n}\n\nfunction createNodeFromContent(content, schema, options) {\r\n    options = {\r\n        slice: true,\r\n        parseOptions: {},\r\n        ...options,\r\n    };\r\n    if (typeof content === 'object' && content !== null) {\r\n        try {\r\n            if (Array.isArray(content) && content.length > 0) {\r\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\r\n            }\r\n            return schema.nodeFromJSON(content);\r\n        }\r\n        catch (error) {\r\n            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\r\n            return createNodeFromContent('', schema, options);\r\n        }\r\n    }\r\n    if (typeof content === 'string') {\r\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\r\n        return options.slice\r\n            ? parser.parseSlice(elementFromString(content), options.parseOptions).content\r\n            : parser.parse(elementFromString(content), options.parseOptions);\r\n    }\r\n    return createNodeFromContent('', schema, options);\r\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\r\nfunction selectionToInsertionEnd(tr, startLen, bias) {\r\n    const last = tr.steps.length - 1;\r\n    if (last < startLen) {\r\n        return;\r\n    }\r\n    const step = tr.steps[last];\r\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\r\n        return;\r\n    }\r\n    const map = tr.mapping.maps[last];\r\n    let end = 0;\r\n    map.forEach((_from, _to, _newFrom, newTo) => {\r\n        if (end === 0) {\r\n            end = newTo;\r\n        }\r\n    });\r\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\r\n}\n\nconst isFragment = (nodeOrFragment) => {\r\n    return nodeOrFragment.toString().startsWith('<');\r\n};\r\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\r\n    if (dispatch) {\r\n        options = {\r\n            parseOptions: {},\r\n            updateSelection: true,\r\n            ...options,\r\n        };\r\n        const content = createNodeFromContent(value, editor.schema, {\r\n            parseOptions: {\r\n                preserveWhitespace: 'full',\r\n                ...options.parseOptions,\r\n            },\r\n        });\r\n        // don’t dispatch an empty fragment because this can lead to strange errors\r\n        if (content.toString() === '<>') {\r\n            return true;\r\n        }\r\n        let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to };\r\n        let isOnlyTextContent = true;\r\n        let isOnlyBlockContent = true;\r\n        const nodes = isFragment(content) ? content : [content];\r\n        nodes.forEach(node => {\r\n            // check if added node is valid\r\n            node.check();\r\n            isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\r\n            isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\r\n        });\r\n        // check if we can replace the wrapping node by\r\n        // the newly inserted content\r\n        // example:\r\n        // replace an empty paragraph by an inserted image\r\n        // instead of inserting the image below the paragraph\r\n        if (from === to && isOnlyBlockContent) {\r\n            const { parent } = tr.doc.resolve(from);\r\n            const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\r\n            if (isEmptyTextBlock) {\r\n                from -= 1;\r\n                to += 1;\r\n            }\r\n        }\r\n        // if there is only plain text we have to use `insertText`\r\n        // because this will keep the current marks\r\n        if (isOnlyTextContent) {\r\n            // if value is string, we can use it directly\r\n            // otherwise if it is an array, we have to join it\r\n            if (Array.isArray(value)) {\r\n                tr.insertText(value.map(v => v.text || '').join(''), from, to);\r\n            }\r\n            else if (typeof value === 'object' && !!value && !!value.text) {\r\n                tr.insertText(value.text, from, to);\r\n            }\r\n            else {\r\n                tr.insertText(value, from, to);\r\n            }\r\n        }\r\n        else {\r\n            tr.replaceWith(from, to, content);\r\n        }\r\n        // set cursor at end of inserted content\r\n        if (options.updateSelection) {\r\n            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\r\n        }\r\n    }\r\n    return true;\r\n};\n\nconst joinUp = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\r\n};\r\nconst joinDown = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\r\n};\r\nconst joinBackward = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\r\n};\r\nconst joinForward = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\r\n};\n\nconst joinItemBackward = () => ({ tr, state, dispatch, }) => {\r\n    try {\r\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\r\n        if (point === null || point === undefined) {\r\n            return false;\r\n        }\r\n        tr.join(point, 2);\r\n        if (dispatch) {\r\n            dispatch(tr);\r\n        }\r\n        return true;\r\n    }\r\n    catch {\r\n        return false;\r\n    }\r\n};\n\nconst joinItemForward = () => ({ state, dispatch, tr, }) => {\r\n    try {\r\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\r\n        if (point === null || point === undefined) {\r\n            return false;\r\n        }\r\n        tr.join(point, 2);\r\n        if (dispatch) {\r\n            dispatch(tr);\r\n        }\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n};\n\nfunction isMacOS() {\r\n    return typeof navigator !== 'undefined'\r\n        ? /Mac/.test(navigator.platform)\r\n        : false;\r\n}\n\nfunction normalizeKeyName(name) {\r\n    const parts = name.split(/-(?!$)/);\r\n    let result = parts[parts.length - 1];\r\n    if (result === 'Space') {\r\n        result = ' ';\r\n    }\r\n    let alt;\r\n    let ctrl;\r\n    let shift;\r\n    let meta;\r\n    for (let i = 0; i < parts.length - 1; i += 1) {\r\n        const mod = parts[i];\r\n        if (/^(cmd|meta|m)$/i.test(mod)) {\r\n            meta = true;\r\n        }\r\n        else if (/^a(lt)?$/i.test(mod)) {\r\n            alt = true;\r\n        }\r\n        else if (/^(c|ctrl|control)$/i.test(mod)) {\r\n            ctrl = true;\r\n        }\r\n        else if (/^s(hift)?$/i.test(mod)) {\r\n            shift = true;\r\n        }\r\n        else if (/^mod$/i.test(mod)) {\r\n            if (isiOS() || isMacOS()) {\r\n                meta = true;\r\n            }\r\n            else {\r\n                ctrl = true;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(`Unrecognized modifier name: ${mod}`);\r\n        }\r\n    }\r\n    if (alt) {\r\n        result = `Alt-${result}`;\r\n    }\r\n    if (ctrl) {\r\n        result = `Ctrl-${result}`;\r\n    }\r\n    if (meta) {\r\n        result = `Meta-${result}`;\r\n    }\r\n    if (shift) {\r\n        result = `Shift-${result}`;\r\n    }\r\n    return result;\r\n}\r\nconst keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {\r\n    const keys = normalizeKeyName(name).split(/-(?!$)/);\r\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\r\n    const event = new KeyboardEvent('keydown', {\r\n        key: key === 'Space'\r\n            ? ' '\r\n            : key,\r\n        altKey: keys.includes('Alt'),\r\n        ctrlKey: keys.includes('Ctrl'),\r\n        metaKey: keys.includes('Meta'),\r\n        shiftKey: keys.includes('Shift'),\r\n        bubbles: true,\r\n        cancelable: true,\r\n    });\r\n    const capturedTransaction = editor.captureTransaction(() => {\r\n        view.someProp('handleKeyDown', f => f(view, event));\r\n    });\r\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\r\n        const newStep = step.map(tr.mapping);\r\n        if (newStep && dispatch) {\r\n            tr.maybeStep(newStep);\r\n        }\r\n    });\r\n    return true;\r\n};\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\r\n    const { from, to, empty } = state.selection;\r\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\r\n    const nodeRanges = [];\r\n    state.doc.nodesBetween(from, to, (node, pos) => {\r\n        if (node.isText) {\r\n            return;\r\n        }\r\n        const relativeFrom = Math.max(from, pos);\r\n        const relativeTo = Math.min(to, pos + node.nodeSize);\r\n        nodeRanges.push({\r\n            node,\r\n            from: relativeFrom,\r\n            to: relativeTo,\r\n        });\r\n    });\r\n    const selectionRange = to - from;\r\n    const matchedNodeRanges = nodeRanges\r\n        .filter(nodeRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === nodeRange.node.type.name;\r\n    })\r\n        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\r\n    if (empty) {\r\n        return !!matchedNodeRanges.length;\r\n    }\r\n    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\r\n    return range >= selectionRange;\r\n}\n\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (!isActive) {\r\n        return false;\r\n    }\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\r\n};\n\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\r\n};\n\nconst liftListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\r\n};\n\nconst newlineInCode = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\r\n};\n\nfunction getSchemaTypeNameByName(name, schema) {\r\n    if (schema.nodes[name]) {\r\n        return 'node';\r\n    }\r\n    if (schema.marks[name]) {\r\n        return 'mark';\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\r\nfunction deleteProps(obj, propOrProps) {\r\n    const props = typeof propOrProps === 'string'\r\n        ? [propOrProps]\r\n        : propOrProps;\r\n    return Object\r\n        .keys(obj)\r\n        .reduce((newObj, prop) => {\r\n        if (!props.includes(prop)) {\r\n            newObj[prop] = obj[prop];\r\n        }\r\n        return newObj;\r\n    }, {});\r\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nconst scrollIntoView = () => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nconst selectAll = () => ({ tr, commands }) => {\r\n    return commands.setTextSelection({\r\n        from: 0,\r\n        to: tr.doc.content.size,\r\n    });\r\n};\n\nconst selectNodeBackward = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\r\n};\n\nconst selectNodeForward = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\r\n};\n\nconst selectParentNode = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\r\n};\n\n// @ts-ignore\r\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\r\n};\n\n// @ts-ignore\r\nconst selectTextblockStart = () => ({ state, dispatch }) => {\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\r\n};\n\nfunction createDocument(content, schema, parseOptions = {}) {\r\n    return createNodeFromContent(content, schema, { slice: false, parseOptions });\r\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\r\n    const { doc } = tr;\r\n    const document = createDocument(content, editor.schema, parseOptions);\r\n    if (dispatch) {\r\n        tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\r\n    }\r\n    return true;\r\n};\n\nfunction getMarkAttributes(state, typeOrName) {\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { from, to, empty } = state.selection;\r\n    const marks = [];\r\n    if (empty) {\r\n        if (state.storedMarks) {\r\n            marks.push(...state.storedMarks);\r\n        }\r\n        marks.push(...state.selection.$head.marks());\r\n    }\r\n    else {\r\n        state.doc.nodesBetween(from, to, node => {\r\n            marks.push(...node.marks);\r\n        });\r\n    }\r\n    const mark = marks.find(markItem => markItem.type.name === type.name);\r\n    if (!mark) {\r\n        return {};\r\n    }\r\n    return { ...mark.attrs };\r\n}\n\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\r\nfunction combineTransactionSteps(oldDoc, transactions) {\r\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\r\n    transactions.forEach(transaction => {\r\n        transaction.steps.forEach(step => {\r\n            transform.step(step);\r\n        });\r\n    });\r\n    return transform;\r\n}\n\nfunction defaultBlockAt(match) {\r\n    for (let i = 0; i < match.edgeCount; i += 1) {\r\n        const { type } = match.edge(i);\r\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\r\n            return type;\r\n        }\r\n    }\r\n    return null;\r\n}\n\nfunction findChildren(node, predicate) {\r\n    const nodesWithPos = [];\r\n    node.descendants((child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\r\nfunction findChildrenInRange(node, range, predicate) {\r\n    const nodesWithPos = [];\r\n    // if (range.from === range.to) {\r\n    //   const nodeAt = node.nodeAt(range.from)\r\n    //   if (nodeAt) {\r\n    //     nodesWithPos.push({\r\n    //       node: nodeAt,\r\n    //       pos: range.from,\r\n    //     })\r\n    //   }\r\n    // }\r\n    node.nodesBetween(range.from, range.to, (child, pos) => {\r\n        if (predicate(child)) {\r\n            nodesWithPos.push({\r\n                node: child,\r\n                pos,\r\n            });\r\n        }\r\n    });\r\n    return nodesWithPos;\r\n}\n\nfunction findParentNodeClosestToPos($pos, predicate) {\r\n    for (let i = $pos.depth; i > 0; i -= 1) {\r\n        const node = $pos.node(i);\r\n        if (predicate(node)) {\r\n            return {\r\n                pos: i > 0 ? $pos.before(i) : 0,\r\n                start: $pos.start(i),\r\n                depth: i,\r\n                node,\r\n            };\r\n        }\r\n    }\r\n}\n\nfunction findParentNode(predicate) {\r\n    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\r\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\r\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\r\n    const temporaryDocument = document.implementation.createHTMLDocument();\r\n    const container = temporaryDocument.createElement('div');\r\n    container.appendChild(documentFragment);\r\n    return container.innerHTML;\r\n}\n\nfunction getSchema(extensions, editor) {\r\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\r\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\r\n}\n\nfunction generateHTML(doc, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\r\n    return getHTMLFromFragment(contentNode.content, schema);\r\n}\n\nfunction generateJSON(html, extensions) {\r\n    const schema = getSchema(extensions);\r\n    const dom = elementFromString(html);\r\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\r\n}\n\nfunction getText(node, options) {\r\n    const range = {\r\n        from: 0,\r\n        to: node.content.size,\r\n    };\r\n    return getTextBetween(node, range, options);\r\n}\n\nfunction generateText(doc, extensions, options) {\r\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\r\n    const schema = getSchema(extensions);\r\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\r\n    return getText(contentNode, {\r\n        blockSeparator,\r\n        textSerializers: {\r\n            ...getTextSerializersFromSchema(schema),\r\n            ...textSerializers,\r\n        },\r\n    });\r\n}\n\nfunction getNodeAttributes(state, typeOrName) {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { from, to } = state.selection;\r\n    const nodes = [];\r\n    state.doc.nodesBetween(from, to, node => {\r\n        nodes.push(node);\r\n    });\r\n    const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\r\n    if (!node) {\r\n        return {};\r\n    }\r\n    return { ...node.attrs };\r\n}\n\nfunction getAttributes(state, typeOrName) {\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return getNodeAttributes(state, typeOrName);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return getMarkAttributes(state, typeOrName);\r\n    }\r\n    return {};\r\n}\n\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\r\nfunction removeDuplicates(array, by = JSON.stringify) {\r\n    const seen = {};\r\n    return array.filter(item => {\r\n        const key = by(item);\r\n        return Object.prototype.hasOwnProperty.call(seen, key)\r\n            ? false\r\n            : (seen[key] = true);\r\n    });\r\n}\n\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\r\nfunction simplifyChangedRanges(changes) {\r\n    const uniqueChanges = removeDuplicates(changes);\r\n    return uniqueChanges.length === 1\r\n        ? uniqueChanges\r\n        : uniqueChanges.filter((change, index) => {\r\n            const rest = uniqueChanges.filter((_, i) => i !== index);\r\n            return !rest.some(otherChange => {\r\n                return change.oldRange.from >= otherChange.oldRange.from\r\n                    && change.oldRange.to <= otherChange.oldRange.to\r\n                    && change.newRange.from >= otherChange.newRange.from\r\n                    && change.newRange.to <= otherChange.newRange.to;\r\n            });\r\n        });\r\n}\r\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\r\nfunction getChangedRanges(transform) {\r\n    const { mapping, steps } = transform;\r\n    const changes = [];\r\n    mapping.maps.forEach((stepMap, index) => {\r\n        const ranges = [];\r\n        // This accounts for step changes where no range was actually altered\r\n        // e.g. when setting a mark, node attribute, etc.\r\n        // @ts-ignore\r\n        if (!stepMap.ranges.length) {\r\n            const { from, to } = steps[index];\r\n            if (from === undefined || to === undefined) {\r\n                return;\r\n            }\r\n            ranges.push({ from, to });\r\n        }\r\n        else {\r\n            stepMap.forEach((from, to) => {\r\n                ranges.push({ from, to });\r\n            });\r\n        }\r\n        ranges.forEach(({ from, to }) => {\r\n            const newStart = mapping.slice(index).map(from, -1);\r\n            const newEnd = mapping.slice(index).map(to);\r\n            const oldStart = mapping.invert().map(newStart, -1);\r\n            const oldEnd = mapping.invert().map(newEnd);\r\n            changes.push({\r\n                oldRange: {\r\n                    from: oldStart,\r\n                    to: oldEnd,\r\n                },\r\n                newRange: {\r\n                    from: newStart,\r\n                    to: newEnd,\r\n                },\r\n            });\r\n        });\r\n    });\r\n    return simplifyChangedRanges(changes);\r\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\r\n    const isTopNode = node.type === node.type.schema.topNodeType;\r\n    const increment = isTopNode ? 0 : 1;\r\n    const from = startOffset;\r\n    const to = from + node.nodeSize;\r\n    const marks = node.marks.map(mark => {\r\n        const output = {\r\n            type: mark.type.name,\r\n        };\r\n        if (Object.keys(mark.attrs).length) {\r\n            output.attrs = { ...mark.attrs };\r\n        }\r\n        return output;\r\n    });\r\n    const attrs = { ...node.attrs };\r\n    const output = {\r\n        type: node.type.name,\r\n        from,\r\n        to,\r\n    };\r\n    if (Object.keys(attrs).length) {\r\n        output.attrs = attrs;\r\n    }\r\n    if (marks.length) {\r\n        output.marks = marks;\r\n    }\r\n    if (node.content.childCount) {\r\n        output.content = [];\r\n        node.forEach((child, offset) => {\r\n            var _a;\r\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\r\n        });\r\n    }\r\n    if (node.text) {\r\n        output.text = node.text;\r\n    }\r\n    return output;\r\n}\n\nfunction getMarksBetween(from, to, doc) {\r\n    const marks = [];\r\n    // get all inclusive marks on empty selection\r\n    if (from === to) {\r\n        doc\r\n            .resolve(from)\r\n            .marks()\r\n            .forEach(mark => {\r\n            const $pos = doc.resolve(from - 1);\r\n            const range = getMarkRange($pos, mark.type);\r\n            if (!range) {\r\n                return;\r\n            }\r\n            marks.push({\r\n                mark,\r\n                ...range,\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        doc.nodesBetween(from, to, (node, pos) => {\r\n            marks.push(...node.marks.map(mark => ({\r\n                from: pos,\r\n                to: pos + node.nodeSize,\r\n                mark,\r\n            })));\r\n        });\r\n    }\r\n    return marks;\r\n}\n\n/**\r\n * Finds the first node of a given type or name in the current selection.\r\n * @param state The editor state.\r\n * @param typeOrName The node type or name.\r\n * @param pos The position to start searching from.\r\n * @param maxDepth The maximum depth to search.\r\n * @returns The node and the depth as an array.\r\n */\r\nconst getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\r\n    const $pos = state.doc.resolve(pos);\r\n    let currentDepth = maxDepth;\r\n    let node = null;\r\n    while (currentDepth > 0 && node === null) {\r\n        const currentNode = $pos.node(currentDepth);\r\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\r\n            node = currentNode;\r\n        }\r\n        else {\r\n            currentDepth -= 1;\r\n        }\r\n    }\r\n    return [node, currentDepth];\r\n};\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\r\n    return Object.fromEntries(Object\r\n        .entries(attributes)\r\n        .filter(([name]) => {\r\n        const extensionAttribute = extensionAttributes.find(item => {\r\n            return item.type === typeName && item.name === name;\r\n        });\r\n        if (!extensionAttribute) {\r\n            return false;\r\n        }\r\n        return extensionAttribute.attribute.keepOnSplit;\r\n    }));\r\n}\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\r\n    const { empty, ranges } = state.selection;\r\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\r\n    if (empty) {\r\n        return !!(state.storedMarks || state.selection.$from.marks())\r\n            .filter(mark => {\r\n            if (!type) {\r\n                return true;\r\n            }\r\n            return type.name === mark.type.name;\r\n        })\r\n            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));\r\n    }\r\n    let selectionRange = 0;\r\n    const markRanges = [];\r\n    ranges.forEach(({ $from, $to }) => {\r\n        const from = $from.pos;\r\n        const to = $to.pos;\r\n        state.doc.nodesBetween(from, to, (node, pos) => {\r\n            if (!node.isText && !node.marks.length) {\r\n                return;\r\n            }\r\n            const relativeFrom = Math.max(from, pos);\r\n            const relativeTo = Math.min(to, pos + node.nodeSize);\r\n            const range = relativeTo - relativeFrom;\r\n            selectionRange += range;\r\n            markRanges.push(...node.marks.map(mark => ({\r\n                mark,\r\n                from: relativeFrom,\r\n                to: relativeTo,\r\n            })));\r\n        });\r\n    });\r\n    if (selectionRange === 0) {\r\n        return false;\r\n    }\r\n    // calculate range of matched mark\r\n    const matchedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return type.name === markRange.mark.type.name;\r\n    })\r\n        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // calculate range of marks that excludes the searched mark\r\n    // for example `code` doesn’t allow any other marks\r\n    const excludedRange = markRanges\r\n        .filter(markRange => {\r\n        if (!type) {\r\n            return true;\r\n        }\r\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\r\n    })\r\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\r\n    // we only include the result of `excludedRange`\r\n    // if there is a match at all\r\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\r\n    return range >= selectionRange;\r\n}\n\nfunction isActive(state, name, attributes = {}) {\r\n    if (!name) {\r\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\r\n    }\r\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\r\n    if (schemaType === 'node') {\r\n        return isNodeActive(state, name, attributes);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        return isMarkActive(state, name, attributes);\r\n    }\r\n    return false;\r\n}\n\nconst isAtEndOfNode = (state, nodeType) => {\r\n    const { $from, $to, $anchor } = state.selection;\r\n    if (nodeType) {\r\n        const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\r\n        if (!parentNode) {\r\n            return false;\r\n        }\r\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\r\n        if ($anchor.pos + 1 === $parentPos.end()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\n\nconst isAtStartOfNode = (state) => {\r\n    const { $from, $to } = state.selection;\r\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\n\nfunction isList(name, extensions) {\r\n    const { nodeExtensions } = splitExtensions(extensions);\r\n    const extension = nodeExtensions.find(item => item.name === name);\r\n    if (!extension) {\r\n        return false;\r\n    }\r\n    const context = {\r\n        name: extension.name,\r\n        options: extension.options,\r\n        storage: extension.storage,\r\n    };\r\n    const group = callOrReturn(getExtensionField(extension, 'group', context));\r\n    if (typeof group !== 'string') {\r\n        return false;\r\n    }\r\n    return group.split(' ').includes('list');\r\n}\n\nfunction isNodeEmpty(node) {\r\n    var _a;\r\n    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\r\n    const content = node.toJSON();\r\n    return JSON.stringify(defaultContent) === JSON.stringify(content);\r\n}\n\nfunction isNodeSelection(value) {\r\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\r\n}\n\nfunction posToDOMRect(view, from, to) {\r\n    const minPos = 0;\r\n    const maxPos = view.state.doc.content.size;\r\n    const resolvedFrom = minMax(from, minPos, maxPos);\r\n    const resolvedEnd = minMax(to, minPos, maxPos);\r\n    const start = view.coordsAtPos(resolvedFrom);\r\n    const end = view.coordsAtPos(resolvedEnd, -1);\r\n    const top = Math.min(start.top, end.top);\r\n    const bottom = Math.max(start.bottom, end.bottom);\r\n    const left = Math.min(start.left, end.left);\r\n    const right = Math.max(start.right, end.right);\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n    const x = left;\r\n    const y = top;\r\n    const data = {\r\n        top,\r\n        bottom,\r\n        left,\r\n        right,\r\n        width,\r\n        height,\r\n        x,\r\n        y,\r\n    };\r\n    return {\r\n        ...data,\r\n        toJSON: () => data,\r\n    };\r\n}\n\nfunction canSetMark(state, tr, newMarkType) {\r\n    var _a;\r\n    const { selection } = tr;\r\n    let cursor = null;\r\n    if (isTextSelection(selection)) {\r\n        cursor = selection.$cursor;\r\n    }\r\n    if (cursor) {\r\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\r\n        // There can be no current marks that exclude the new mark\r\n        return (!!newMarkType.isInSet(currentMarks)\r\n            || !currentMarks.some(mark => mark.type.excludes(newMarkType)));\r\n    }\r\n    const { ranges } = selection;\r\n    return ranges.some(({ $from, $to }) => {\r\n        let someNodeSupportsMark = $from.depth === 0\r\n            ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\r\n            : false;\r\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\r\n            // If we already found a mark that we can enable, return false to bypass the remaining search\r\n            if (someNodeSupportsMark) {\r\n                return false;\r\n            }\r\n            if (node.isInline) {\r\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\r\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\r\n                    || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\r\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\r\n            }\r\n            return !someNodeSupportsMark;\r\n        });\r\n        return someNodeSupportsMark;\r\n    });\r\n}\r\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    if (dispatch) {\r\n        if (empty) {\r\n            const oldAttributes = getMarkAttributes(state, type);\r\n            tr.addStoredMark(type.create({\r\n                ...oldAttributes,\r\n                ...attributes,\r\n            }));\r\n        }\r\n        else {\r\n            ranges.forEach(range => {\r\n                const from = range.$from.pos;\r\n                const to = range.$to.pos;\r\n                state.doc.nodesBetween(from, to, (node, pos) => {\r\n                    const trimmedFrom = Math.max(pos, from);\r\n                    const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                    const someHasMark = node.marks.find(mark => mark.type === type);\r\n                    // if there is already a mark of this type\r\n                    // we know that we have to merge its attributes\r\n                    // otherwise we add a fresh new mark\r\n                    if (someHasMark) {\r\n                        node.marks.forEach(mark => {\r\n                            if (type === mark.type) {\r\n                                tr.addMark(trimmedFrom, trimmedTo, type.create({\r\n                                    ...mark.attrs,\r\n                                    ...attributes,\r\n                                }));\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n    return canSetMark(state, tr, type);\r\n};\n\nconst setMeta = (key, value) => ({ tr }) => {\r\n    tr.setMeta(key, value);\r\n    return true;\r\n};\n\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    // TODO: use a fallback like insertContent?\r\n    if (!type.isTextblock) {\r\n        console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\r\n        return false;\r\n    }\r\n    return (chain()\r\n        // try to convert node to default node if needed\r\n        .command(({ commands }) => {\r\n        const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(state);\r\n        if (canSetBlock) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .command(({ state: updatedState }) => {\r\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(updatedState, dispatch);\r\n    })\r\n        .run());\r\n};\n\nconst setNodeSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const from = minMax(position, 0, doc.content.size);\r\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nconst setTextSelection = position => ({ tr, dispatch }) => {\r\n    if (dispatch) {\r\n        const { doc } = tr;\r\n        const { from, to } = typeof position === 'number' ? { from: position, to: position } : position;\r\n        const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\r\n        const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\r\n        const resolvedFrom = minMax(from, minPos, maxPos);\r\n        const resolvedEnd = minMax(to, minPos, maxPos);\r\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\r\n        tr.setSelection(selection);\r\n    }\r\n    return true;\r\n};\n\nconst sinkListItem = typeOrName => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\r\n};\n\nfunction ensureMarks(state, splittableMarks) {\r\n    const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\r\n    if (marks) {\r\n        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\r\n        state.tr.ensureMarks(filteredMarks);\r\n    }\r\n}\r\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {\r\n    const { selection, doc } = tr;\r\n    const { $from, $to } = selection;\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\r\n        if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            if (keepMarks) {\r\n                ensureMarks(state, editor.extensionManager.splittableMarks);\r\n            }\r\n            tr.split($from.pos).scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    if (!$from.parent.isBlock) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        const atEnd = $to.parentOffset === $to.parent.content.size;\r\n        if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\r\n            tr.deleteSelection();\r\n        }\r\n        const deflt = $from.depth === 0\r\n            ? undefined\r\n            : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\r\n        let types = atEnd && deflt\r\n            ? [\r\n                {\r\n                    type: deflt,\r\n                    attrs: newAttributes,\r\n                },\r\n            ]\r\n            : undefined;\r\n        let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\r\n        if (!types\r\n            && !can\r\n            && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\r\n            can = true;\r\n            types = deflt\r\n                ? [\r\n                    {\r\n                        type: deflt,\r\n                        attrs: newAttributes,\r\n                    },\r\n                ]\r\n                : undefined;\r\n        }\r\n        if (can) {\r\n            tr.split(tr.mapping.map($from.pos), 1, types);\r\n            if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\r\n                const first = tr.mapping.map($from.before());\r\n                const $first = tr.doc.resolve(first);\r\n                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\r\n                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\r\n                }\r\n            }\r\n        }\r\n        if (keepMarks) {\r\n            ensureMarks(state, editor.extensionManager.splittableMarks);\r\n        }\r\n        tr.scrollIntoView();\r\n    }\r\n    return true;\r\n};\n\nconst splitListItem = typeOrName => ({ tr, state, dispatch, editor, }) => {\r\n    var _a;\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const { $from, $to } = state.selection;\r\n    // @ts-ignore\r\n    // eslint-disable-next-line\r\n    const node = state.selection.node;\r\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\r\n        return false;\r\n    }\r\n    const grandParent = $from.node(-1);\r\n    if (grandParent.type !== type) {\r\n        return false;\r\n    }\r\n    const extensionAttributes = editor.extensionManager.attributes;\r\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\r\n        // In an empty block. If this is a nested list, the wrapping\r\n        // list item should be split. Otherwise, bail out and let next\r\n        // command handle lifting.\r\n        if ($from.depth === 2\r\n            || $from.node(-3).type !== type\r\n            || $from.index(-2) !== $from.node(-2).childCount - 1) {\r\n            return false;\r\n        }\r\n        if (dispatch) {\r\n            let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\r\n            // eslint-disable-next-line\r\n            const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\r\n            // Build a fragment containing empty versions of the structure\r\n            // from the outer list item to the parent node of the cursor\r\n            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\r\n                wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\r\n            }\r\n            // eslint-disable-next-line\r\n            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\r\n            // Add a second list item with an empty default start node\r\n            const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\r\n            wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\r\n            const start = $from.before($from.depth - (depthBefore - 1));\r\n            tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\r\n            let sel = -1;\r\n            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\r\n                if (sel > -1) {\r\n                    return false;\r\n                }\r\n                if (n.isTextblock && n.content.size === 0) {\r\n                    sel = pos + 1;\r\n                }\r\n            });\r\n            if (sel > -1) {\r\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\r\n            }\r\n            tr.scrollIntoView();\r\n        }\r\n        return true;\r\n    }\r\n    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\r\n    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\r\n    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\r\n    tr.delete($from.pos, $to.pos);\r\n    const types = nextType\r\n        ? [\r\n            { type, attrs: newTypeAttributes },\r\n            { type: nextType, attrs: newNextTypeAttributes },\r\n        ]\r\n        : [{ type, attrs: newTypeAttributes }];\r\n    if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\r\n        return false;\r\n    }\r\n    if (dispatch) {\r\n        const { selection, storedMarks } = state;\r\n        const { splittableMarks } = editor.extensionManager;\r\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\r\n        tr.split($from.pos, 2, types).scrollIntoView();\r\n        if (!marks || !dispatch) {\r\n            return true;\r\n        }\r\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\r\n        tr.ensureMarks(filteredMarks);\r\n    }\r\n    return true;\r\n};\n\nconst joinListBackwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\r\n    if (before === undefined) {\r\n        return true;\r\n    }\r\n    const nodeBefore = tr.doc.nodeAt(before);\r\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\r\n    if (!canJoinBackwards) {\r\n        return true;\r\n    }\r\n    tr.join(list.pos);\r\n    return true;\r\n};\r\nconst joinListForwards = (tr, listType) => {\r\n    const list = findParentNode(node => node.type === listType)(tr.selection);\r\n    if (!list) {\r\n        return true;\r\n    }\r\n    const after = tr.doc.resolve(list.start).after(list.depth);\r\n    if (after === undefined) {\r\n        return true;\r\n    }\r\n    const nodeAfter = tr.doc.nodeAt(after);\r\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\r\n    if (!canJoinForwards) {\r\n        return true;\r\n    }\r\n    tr.join(after);\r\n    return true;\r\n};\r\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {\r\n    const { extensions, splittableMarks } = editor.extensionManager;\r\n    const listType = getNodeType(listTypeOrName, state.schema);\r\n    const itemType = getNodeType(itemTypeOrName, state.schema);\r\n    const { selection, storedMarks } = state;\r\n    const { $from, $to } = selection;\r\n    const range = $from.blockRange($to);\r\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\r\n    if (!range) {\r\n        return false;\r\n    }\r\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\r\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\r\n        // remove list\r\n        if (parentList.node.type === listType) {\r\n            return commands.liftListItem(itemType);\r\n        }\r\n        // change list type\r\n        if (isList(parentList.node.type.name, extensions)\r\n            && listType.validContent(parentList.node.content)\r\n            && dispatch) {\r\n            return chain()\r\n                .command(() => {\r\n                tr.setNodeMarkup(parentList.pos, listType);\r\n                return true;\r\n            })\r\n                .command(() => joinListBackwards(tr, listType))\r\n                .command(() => joinListForwards(tr, listType))\r\n                .run();\r\n        }\r\n    }\r\n    if (!keepMarks || !marks || !dispatch) {\r\n        return chain()\r\n            // try to convert node to default node if needed\r\n            .command(() => {\r\n            const canWrapInList = can().wrapInList(listType, attributes);\r\n            if (canWrapInList) {\r\n                return true;\r\n            }\r\n            return commands.clearNodes();\r\n        })\r\n            .wrapInList(listType, attributes)\r\n            .command(() => joinListBackwards(tr, listType))\r\n            .command(() => joinListForwards(tr, listType))\r\n            .run();\r\n    }\r\n    return (chain()\r\n        // try to convert node to default node if needed\r\n        .command(() => {\r\n        const canWrapInList = can().wrapInList(listType, attributes);\r\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\r\n        tr.ensureMarks(filteredMarks);\r\n        if (canWrapInList) {\r\n            return true;\r\n        }\r\n        return commands.clearNodes();\r\n    })\r\n        .wrapInList(listType, attributes)\r\n        .command(() => joinListBackwards(tr, listType))\r\n        .command(() => joinListForwards(tr, listType))\r\n        .run());\r\n};\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const isActive = isMarkActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.unsetMark(type, { extendEmptyMarkRange });\r\n    }\r\n    return commands.setMark(type, attributes);\r\n};\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.setNode(toggleType);\r\n    }\r\n    return commands.setNode(type, attributes);\r\n};\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    const isActive = isNodeActive(state, type, attributes);\r\n    if (isActive) {\r\n        return commands.lift(type);\r\n    }\r\n    return commands.wrapIn(type, attributes);\r\n};\n\nconst undoInputRule = () => ({ state, dispatch }) => {\r\n    const plugins = state.plugins;\r\n    for (let i = 0; i < plugins.length; i += 1) {\r\n        const plugin = plugins[i];\r\n        let undoable;\r\n        // @ts-ignore\r\n        // eslint-disable-next-line\r\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\r\n            if (dispatch) {\r\n                const tr = state.tr;\r\n                const toUndo = undoable.transform;\r\n                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\r\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\r\n                }\r\n                if (undoable.text) {\r\n                    const marks = tr.doc.resolve(undoable.from).marks();\r\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\r\n                }\r\n                else {\r\n                    tr.delete(undoable.from, undoable.to);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\r\n    const { selection } = tr;\r\n    const { empty, ranges } = selection;\r\n    if (empty) {\r\n        return true;\r\n    }\r\n    if (dispatch) {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos);\r\n        });\r\n    }\r\n    return true;\r\n};\n\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\r\n    var _a;\r\n    const { extendEmptyMarkRange = false } = options;\r\n    const { selection } = tr;\r\n    const type = getMarkType(typeOrName, state.schema);\r\n    const { $from, empty, ranges } = selection;\r\n    if (!dispatch) {\r\n        return true;\r\n    }\r\n    if (empty && extendEmptyMarkRange) {\r\n        let { from, to } = selection;\r\n        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\r\n        const range = getMarkRange($from, type, attrs);\r\n        if (range) {\r\n            from = range.from;\r\n            to = range.to;\r\n        }\r\n        tr.removeMark(from, to, type);\r\n    }\r\n    else {\r\n        ranges.forEach(range => {\r\n            tr.removeMark(range.$from.pos, range.$to.pos, type);\r\n        });\r\n    }\r\n    tr.removeStoredMark(type);\r\n    return true;\r\n};\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\r\n    let nodeType = null;\r\n    let markType = null;\r\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\r\n    if (!schemaType) {\r\n        return false;\r\n    }\r\n    if (schemaType === 'node') {\r\n        nodeType = getNodeType(typeOrName, state.schema);\r\n    }\r\n    if (schemaType === 'mark') {\r\n        markType = getMarkType(typeOrName, state.schema);\r\n    }\r\n    if (dispatch) {\r\n        tr.selection.ranges.forEach(range => {\r\n            const from = range.$from.pos;\r\n            const to = range.$to.pos;\r\n            state.doc.nodesBetween(from, to, (node, pos) => {\r\n                if (nodeType && nodeType === node.type) {\r\n                    tr.setNodeMarkup(pos, undefined, {\r\n                        ...node.attrs,\r\n                        ...attributes,\r\n                    });\r\n                }\r\n                if (markType && node.marks.length) {\r\n                    node.marks.forEach(mark => {\r\n                        if (markType === mark.type) {\r\n                            const trimmedFrom = Math.max(pos, from);\r\n                            const trimmedTo = Math.min(pos + node.nodeSize, to);\r\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\r\n                                ...mark.attrs,\r\n                                ...attributes,\r\n                            }));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return true;\r\n};\n\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\r\n};\n\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\r\n    const type = getNodeType(typeOrName, state.schema);\r\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\r\n};\n\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinUp: joinUp,\n  joinDown: joinDown,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\n\nconst Commands = Extension.create({\r\n    name: 'commands',\r\n    addCommands() {\r\n        return {\r\n            ...commands,\r\n        };\r\n    },\r\n});\n\nconst Editable = Extension.create({\r\n    name: 'editable',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('editable'),\r\n                props: {\r\n                    editable: () => this.editor.options.editable,\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst FocusEvents = Extension.create({\r\n    name: 'focusEvents',\r\n    addProseMirrorPlugins() {\r\n        const { editor } = this;\r\n        return [\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('focusEvents'),\r\n                props: {\r\n                    handleDOMEvents: {\r\n                        focus: (view, event) => {\r\n                            editor.isFocused = true;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('focus', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                        blur: (view, event) => {\r\n                            editor.isFocused = false;\r\n                            const transaction = editor.state.tr\r\n                                .setMeta('blur', { event })\r\n                                .setMeta('addToHistory', false);\r\n                            view.dispatch(transaction);\r\n                            return false;\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst Keymap = Extension.create({\r\n    name: 'keymap',\r\n    addKeyboardShortcuts() {\r\n        const handleBackspace = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.undoInputRule(),\r\n            // maybe convert first text block node to default node\r\n            () => commands.command(({ tr }) => {\r\n                const { selection, doc } = tr;\r\n                const { empty, $anchor } = selection;\r\n                const { pos, parent } = $anchor;\r\n                const $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;\r\n                const parentIsIsolating = $parentPos.parent.type.spec.isolating;\r\n                const parentPos = $anchor.pos - $anchor.parentOffset;\r\n                const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\r\n                    ? parentPos === $anchor.pos\r\n                    : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\r\n                if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\r\n                    return false;\r\n                }\r\n                return commands.clearNodes();\r\n            }),\r\n            () => commands.deleteSelection(),\r\n            () => commands.joinBackward(),\r\n            () => commands.selectNodeBackward(),\r\n        ]);\r\n        const handleDelete = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.deleteSelection(),\r\n            () => commands.deleteCurrentNode(),\r\n            () => commands.joinForward(),\r\n            () => commands.selectNodeForward(),\r\n        ]);\r\n        const handleEnter = () => this.editor.commands.first(({ commands }) => [\r\n            () => commands.newlineInCode(),\r\n            () => commands.createParagraphNear(),\r\n            () => commands.liftEmptyBlock(),\r\n            () => commands.splitBlock(),\r\n        ]);\r\n        const baseKeymap = {\r\n            Enter: handleEnter,\r\n            'Mod-Enter': () => this.editor.commands.exitCode(),\r\n            Backspace: handleBackspace,\r\n            'Mod-Backspace': handleBackspace,\r\n            'Shift-Backspace': handleBackspace,\r\n            Delete: handleDelete,\r\n            'Mod-Delete': handleDelete,\r\n            'Mod-a': () => this.editor.commands.selectAll(),\r\n        };\r\n        const pcKeymap = {\r\n            ...baseKeymap,\r\n        };\r\n        const macKeymap = {\r\n            ...baseKeymap,\r\n            'Ctrl-h': handleBackspace,\r\n            'Alt-Backspace': handleBackspace,\r\n            'Ctrl-d': handleDelete,\r\n            'Ctrl-Alt-Backspace': handleDelete,\r\n            'Alt-Delete': handleDelete,\r\n            'Alt-d': handleDelete,\r\n            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\r\n            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\r\n        };\r\n        if (isiOS() || isMacOS()) {\r\n            return macKeymap;\r\n        }\r\n        return pcKeymap;\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            // With this plugin we check if the whole document was selected and deleted.\r\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\r\n            // to a paragraph if necessary.\r\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\r\n            // with many other commands.\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clearDocument'),\r\n                appendTransaction: (transactions, oldState, newState) => {\r\n                    const docChanges = transactions.some(transaction => transaction.docChanged)\r\n                        && !oldState.doc.eq(newState.doc);\r\n                    if (!docChanges) {\r\n                        return;\r\n                    }\r\n                    const { empty, from, to } = oldState.selection;\r\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\r\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\r\n                    const allWasSelected = from === allFrom && to === allEnd;\r\n                    if (empty || !allWasSelected) {\r\n                        return;\r\n                    }\r\n                    const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\r\n                    if (!isEmpty) {\r\n                        return;\r\n                    }\r\n                    const tr = newState.tr;\r\n                    const state = createChainableState({\r\n                        state: newState,\r\n                        transaction: tr,\r\n                    });\r\n                    const { commands } = new CommandManager({\r\n                        editor: this.editor,\r\n                        state,\r\n                    });\r\n                    commands.clearNodes();\r\n                    if (!tr.steps.length) {\r\n                        return;\r\n                    }\r\n                    return tr;\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nconst Tabindex = Extension.create({\r\n    name: 'tabindex',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tabindex'),\r\n                props: {\r\n                    attributes: this.editor.isEditable ? { tabindex: '0' } : {},\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nfunction createStyleTag(style, nonce, suffix) {\r\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`);\r\n    if (tiptapStyleTag !== null) {\r\n        return tiptapStyleTag;\r\n    }\r\n    const styleNode = document.createElement('style');\r\n    if (nonce) {\r\n        styleNode.setAttribute('nonce', nonce);\r\n    }\r\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '');\r\n    styleNode.innerHTML = style;\r\n    document.getElementsByTagName('head')[0].appendChild(styleNode);\r\n    return styleNode;\r\n}\n\nclass Editor extends EventEmitter {\r\n    constructor(options = {}) {\r\n        super();\r\n        this.isFocused = false;\r\n        this.extensionStorage = {};\r\n        this.options = {\r\n            element: document.createElement('div'),\r\n            content: '',\r\n            injectCSS: true,\r\n            injectNonce: undefined,\r\n            extensions: [],\r\n            autofocus: false,\r\n            editable: true,\r\n            editorProps: {},\r\n            parseOptions: {},\r\n            enableInputRules: true,\r\n            enablePasteRules: true,\r\n            enableCoreExtensions: true,\r\n            onBeforeCreate: () => null,\r\n            onCreate: () => null,\r\n            onUpdate: () => null,\r\n            onSelectionUpdate: () => null,\r\n            onTransaction: () => null,\r\n            onFocus: () => null,\r\n            onBlur: () => null,\r\n            onDestroy: () => null,\r\n        };\r\n        this.isCapturingTransaction = false;\r\n        this.capturedTransaction = null;\r\n        this.setOptions(options);\r\n        this.createExtensionManager();\r\n        this.createCommandManager();\r\n        this.createSchema();\r\n        this.on('beforeCreate', this.options.onBeforeCreate);\r\n        this.emit('beforeCreate', { editor: this });\r\n        this.createView();\r\n        this.injectCSS();\r\n        this.on('create', this.options.onCreate);\r\n        this.on('update', this.options.onUpdate);\r\n        this.on('selectionUpdate', this.options.onSelectionUpdate);\r\n        this.on('transaction', this.options.onTransaction);\r\n        this.on('focus', this.options.onFocus);\r\n        this.on('blur', this.options.onBlur);\r\n        this.on('destroy', this.options.onDestroy);\r\n        window.setTimeout(() => {\r\n            if (this.isDestroyed) {\r\n                return;\r\n            }\r\n            this.commands.focus(this.options.autofocus);\r\n            this.emit('create', { editor: this });\r\n        }, 0);\r\n    }\r\n    /**\r\n     * Returns the editor storage.\r\n     */\r\n    get storage() {\r\n        return this.extensionStorage;\r\n    }\r\n    /**\r\n     * An object of all registered commands.\r\n     */\r\n    get commands() {\r\n        return this.commandManager.commands;\r\n    }\r\n    /**\r\n     * Create a command chain to call multiple commands at once.\r\n     */\r\n    chain() {\r\n        return this.commandManager.chain();\r\n    }\r\n    /**\r\n     * Check if a command or a command chain can be executed. Without executing it.\r\n     */\r\n    can() {\r\n        return this.commandManager.can();\r\n    }\r\n    /**\r\n     * Inject CSS styles.\r\n     */\r\n    injectCSS() {\r\n        if (this.options.injectCSS && document) {\r\n            this.css = createStyleTag(style, this.options.injectNonce);\r\n        }\r\n    }\r\n    /**\r\n     * Update editor options.\r\n     *\r\n     * @param options A list of options\r\n     */\r\n    setOptions(options = {}) {\r\n        this.options = {\r\n            ...this.options,\r\n            ...options,\r\n        };\r\n        if (!this.view || !this.state || this.isDestroyed) {\r\n            return;\r\n        }\r\n        if (this.options.editorProps) {\r\n            this.view.setProps(this.options.editorProps);\r\n        }\r\n        this.view.updateState(this.state);\r\n    }\r\n    /**\r\n     * Update editable state of the editor.\r\n     */\r\n    setEditable(editable, emitUpdate = true) {\r\n        this.setOptions({ editable });\r\n        if (emitUpdate) {\r\n            this.emit('update', { editor: this, transaction: this.state.tr });\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the editor is editable.\r\n     */\r\n    get isEditable() {\r\n        // since plugins are applied after creating the view\r\n        // `editable` is always `true` for one tick.\r\n        // that’s why we also have to check for `options.editable`\r\n        return this.options.editable && this.view && this.view.editable;\r\n    }\r\n    /**\r\n     * Returns the editor state.\r\n     */\r\n    get state() {\r\n        return this.view.state;\r\n    }\r\n    /**\r\n     * Register a ProseMirror plugin.\r\n     *\r\n     * @param plugin A ProseMirror plugin\r\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n     */\r\n    registerPlugin(plugin, handlePlugins) {\r\n        const plugins = isFunction(handlePlugins)\r\n            ? handlePlugins(plugin, [...this.state.plugins])\r\n            : [...this.state.plugins, plugin];\r\n        const state = this.state.reconfigure({ plugins });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Unregister a ProseMirror plugin.\r\n     *\r\n     * @param nameOrPluginKey The plugins name\r\n     */\r\n    unregisterPlugin(nameOrPluginKey) {\r\n        if (this.isDestroyed) {\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\r\n        const state = this.state.reconfigure({\r\n            // @ts-ignore\r\n            plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\r\n        });\r\n        this.view.updateState(state);\r\n    }\r\n    /**\r\n     * Creates an extension manager.\r\n     */\r\n    createExtensionManager() {\r\n        const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\r\n        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\r\n            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\r\n        });\r\n        this.extensionManager = new ExtensionManager(allExtensions, this);\r\n    }\r\n    /**\r\n     * Creates an command manager.\r\n     */\r\n    createCommandManager() {\r\n        this.commandManager = new CommandManager({\r\n            editor: this,\r\n        });\r\n    }\r\n    /**\r\n     * Creates a ProseMirror schema.\r\n     */\r\n    createSchema() {\r\n        this.schema = this.extensionManager.schema;\r\n    }\r\n    /**\r\n     * Creates a ProseMirror view.\r\n     */\r\n    createView() {\r\n        const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\r\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\r\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\r\n            ...this.options.editorProps,\r\n            dispatchTransaction: this.dispatchTransaction.bind(this),\r\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\r\n                doc,\r\n                selection: selection || undefined,\r\n            }),\r\n        });\r\n        // `editor.view` is not yet available at this time.\r\n        // Therefore we will add all plugins and node views directly afterwards.\r\n        const newState = this.state.reconfigure({\r\n            plugins: this.extensionManager.plugins,\r\n        });\r\n        this.view.updateState(newState);\r\n        this.createNodeViews();\r\n        this.prependClass();\r\n        // Let’s store the editor instance in the DOM element.\r\n        // So we’ll have access to it for tests.\r\n        const dom = this.view.dom;\r\n        dom.editor = this;\r\n    }\r\n    /**\r\n     * Creates all node views.\r\n     */\r\n    createNodeViews() {\r\n        this.view.setProps({\r\n            nodeViews: this.extensionManager.nodeViews,\r\n        });\r\n    }\r\n    /**\r\n     * Prepend class name to element.\r\n     */\r\n    prependClass() {\r\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\r\n    }\r\n    captureTransaction(fn) {\r\n        this.isCapturingTransaction = true;\r\n        fn();\r\n        this.isCapturingTransaction = false;\r\n        const tr = this.capturedTransaction;\r\n        this.capturedTransaction = null;\r\n        return tr;\r\n    }\r\n    /**\r\n     * The callback over which to send transactions (state updates) produced by the view.\r\n     *\r\n     * @param transaction An editor state transaction\r\n     */\r\n    dispatchTransaction(transaction) {\r\n        // if the editor / the view of the editor was destroyed\r\n        // the transaction should not be dispatched as there is no view anymore.\r\n        if (this.view.isDestroyed) {\r\n            return;\r\n        }\r\n        if (this.isCapturingTransaction) {\r\n            if (!this.capturedTransaction) {\r\n                this.capturedTransaction = transaction;\r\n                return;\r\n            }\r\n            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });\r\n            return;\r\n        }\r\n        const state = this.state.apply(transaction);\r\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\r\n        this.view.updateState(state);\r\n        this.emit('transaction', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n        if (selectionHasChanged) {\r\n            this.emit('selectionUpdate', {\r\n                editor: this,\r\n                transaction,\r\n            });\r\n        }\r\n        const focus = transaction.getMeta('focus');\r\n        const blur = transaction.getMeta('blur');\r\n        if (focus) {\r\n            this.emit('focus', {\r\n                editor: this,\r\n                event: focus.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (blur) {\r\n            this.emit('blur', {\r\n                editor: this,\r\n                event: blur.event,\r\n                transaction,\r\n            });\r\n        }\r\n        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\r\n            return;\r\n        }\r\n        this.emit('update', {\r\n            editor: this,\r\n            transaction,\r\n        });\r\n    }\r\n    /**\r\n     * Get attributes of the currently selected node or mark.\r\n     */\r\n    getAttributes(nameOrType) {\r\n        return getAttributes(this.state, nameOrType);\r\n    }\r\n    isActive(nameOrAttributes, attributesOrUndefined) {\r\n        const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\r\n        const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\r\n        return isActive(this.state, name, attributes);\r\n    }\r\n    /**\r\n     * Get the document as JSON.\r\n     */\r\n    getJSON() {\r\n        return this.state.doc.toJSON();\r\n    }\r\n    /**\r\n     * Get the document as HTML.\r\n     */\r\n    getHTML() {\r\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\r\n    }\r\n    /**\r\n     * Get the document as text.\r\n     */\r\n    getText(options) {\r\n        const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\r\n        return getText(this.state.doc, {\r\n            blockSeparator,\r\n            textSerializers: {\r\n                ...getTextSerializersFromSchema(this.schema),\r\n                ...textSerializers,\r\n            },\r\n        });\r\n    }\r\n    /**\r\n     * Check if there is no content.\r\n     */\r\n    get isEmpty() {\r\n        return isNodeEmpty(this.state.doc);\r\n    }\r\n    /**\r\n     * Get the number of characters for the current document.\r\n     *\r\n     * @deprecated\r\n     */\r\n    getCharacterCount() {\r\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\r\n        return this.state.doc.content.size - 2;\r\n    }\r\n    /**\r\n     * Destroy the editor.\r\n     */\r\n    destroy() {\r\n        this.emit('destroy');\r\n        if (this.view) {\r\n            this.view.destroy();\r\n        }\r\n        this.removeAllListeners();\r\n    }\r\n    /**\r\n     * Check if the editor is already destroyed.\r\n     */\r\n    get isDestroyed() {\r\n        var _a;\r\n        // @ts-ignore\r\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\r\n    }\r\n}\n\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\r\nfunction markInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                const markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\r\nfunction nodeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const { tr } = state;\r\n            const start = range.from;\r\n            let end = range.to;\r\n            const newNode = config.type.create(attributes);\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                let matchStart = start + offset;\r\n                if (matchStart > end) {\r\n                    matchStart = end;\r\n                }\r\n                else {\r\n                    end = matchStart + match[1].length;\r\n                }\r\n                // insert last typed character\r\n                const lastChar = match[0][match[0].length - 1];\r\n                tr.insertText(lastChar, start + match[0].length - 1);\r\n                // insert node from input rule\r\n                tr.replaceWith(matchStart, end, newNode);\r\n            }\r\n            else if (match[0]) {\r\n                tr.insert(start - 1, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\r\n            }\r\n            tr.scrollIntoView();\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\r\nfunction textblockTypeInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const $start = state.doc.resolve(range.from);\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\r\n                return null;\r\n            }\r\n            state.tr\r\n                .delete(range.from, range.to)\r\n                .setBlockType(range.from, range.from, config.type, attributes);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\r\nfunction textInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\r\nfunction wrappingInputRule(config) {\r\n    return new InputRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match, chain, }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\r\n            const tr = state.tr.delete(range.from, range.to);\r\n            const $start = tr.doc.resolve(range.from);\r\n            const blockRange = $start.blockRange();\r\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\r\n            if (!wrapping) {\r\n                return null;\r\n            }\r\n            tr.wrap(blockRange, wrapping);\r\n            if (config.keepMarks && config.editor) {\r\n                const { selection, storedMarks } = state;\r\n                const { splittableMarks } = config.editor.extensionManager;\r\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\r\n                if (marks) {\r\n                    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\r\n                    tr.ensureMarks(filteredMarks);\r\n                }\r\n            }\r\n            if (config.keepAttributes) {\r\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\r\n                const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\r\n                chain().updateAttributes(nodeType, attributes).run();\r\n            }\r\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\r\n            if (before\r\n                && before.type === config.type\r\n                && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1)\r\n                && (!config.joinPredicate || config.joinPredicate(match, before))) {\r\n                tr.join(range.from - 1);\r\n            }\r\n        },\r\n    });\r\n}\n\nclass Mark {\r\n    constructor(config = {}) {\r\n        this.type = 'mark';\r\n        this.name = 'mark';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Mark(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Mark(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    static handleExit({ editor, mark }) {\r\n        const { tr } = editor.state;\r\n        const currentPos = editor.state.selection.$from;\r\n        const isAtEnd = currentPos.pos === currentPos.end();\r\n        if (isAtEnd) {\r\n            const currentMarks = currentPos.marks();\r\n            const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\r\n            if (!isInMark) {\r\n                return false;\r\n            }\r\n            const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\r\n            if (removeMark) {\r\n                tr.removeStoredMark(removeMark);\r\n            }\r\n            tr.insertText(' ', currentPos.pos);\r\n            editor.view.dispatch(tr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\n\nclass Node {\r\n    constructor(config = {}) {\r\n        this.type = 'node';\r\n        this.name = 'node';\r\n        this.parent = null;\r\n        this.child = null;\r\n        this.config = {\r\n            name: this.name,\r\n            defaultOptions: {},\r\n        };\r\n        this.config = {\r\n            ...this.config,\r\n            ...config,\r\n        };\r\n        this.name = this.config.name;\r\n        if (config.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\r\n        }\r\n        // TODO: remove `addOptions` fallback\r\n        this.options = this.config.defaultOptions;\r\n        if (this.config.addOptions) {\r\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\r\n                name: this.name,\r\n            }));\r\n        }\r\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\r\n            name: this.name,\r\n            options: this.options,\r\n        })) || {};\r\n    }\r\n    static create(config = {}) {\r\n        return new Node(config);\r\n    }\r\n    configure(options = {}) {\r\n        // return a new instance so we can use the same extension\r\n        // with different calls of `configure`\r\n        const extension = this.extend();\r\n        extension.options = mergeDeep(this.options, options);\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n    extend(extendedConfig = {}) {\r\n        const extension = new Node(extendedConfig);\r\n        extension.parent = this;\r\n        this.child = extension;\r\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\r\n        if (extendedConfig.defaultOptions) {\r\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\r\n        }\r\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\r\n            name: extension.name,\r\n        }));\r\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\r\n            name: extension.name,\r\n            options: extension.options,\r\n        }));\r\n        return extension;\r\n    }\r\n}\n\nfunction isAndroid() {\r\n    return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\r\n}\n\nclass NodeView {\r\n    constructor(component, props, options) {\r\n        this.isDragging = false;\r\n        this.component = component;\r\n        this.editor = props.editor;\r\n        this.options = {\r\n            stopEvent: null,\r\n            ignoreMutation: null,\r\n            ...options,\r\n        };\r\n        this.extension = props.extension;\r\n        this.node = props.node;\r\n        this.decorations = props.decorations;\r\n        this.getPos = props.getPos;\r\n        this.mount();\r\n    }\r\n    mount() {\r\n        // eslint-disable-next-line\r\n        return;\r\n    }\r\n    get dom() {\r\n        return this.editor.view.dom;\r\n    }\r\n    get contentDOM() {\r\n        return null;\r\n    }\r\n    onDragStart(event) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        const { view } = this.editor;\r\n        const target = event.target;\r\n        // get the drag handle element\r\n        // `closest` is not available for text nodes so we may have to use its parent\r\n        const dragHandle = target.nodeType === 3\r\n            ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')\r\n            : target.closest('[data-drag-handle]');\r\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\r\n            return;\r\n        }\r\n        let x = 0;\r\n        let y = 0;\r\n        // calculate offset for drag element if we use a different drag handle element\r\n        if (this.dom !== dragHandle) {\r\n            const domBox = this.dom.getBoundingClientRect();\r\n            const handleBox = dragHandle.getBoundingClientRect();\r\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\r\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\r\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\r\n            x = handleBox.x - domBox.x + offsetX;\r\n            y = handleBox.y - domBox.y + offsetY;\r\n        }\r\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\r\n        // we need to tell ProseMirror that we want to move the whole node\r\n        // so we create a NodeSelection\r\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, this.getPos());\r\n        const transaction = view.state.tr.setSelection(selection);\r\n        view.dispatch(transaction);\r\n    }\r\n    stopEvent(event) {\r\n        var _a;\r\n        if (!this.dom) {\r\n            return false;\r\n        }\r\n        if (typeof this.options.stopEvent === 'function') {\r\n            return this.options.stopEvent({ event });\r\n        }\r\n        const target = event.target;\r\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\r\n        // any event from child nodes should be handled by ProseMirror\r\n        if (!isInElement) {\r\n            return false;\r\n        }\r\n        const isDragEvent = event.type.startsWith('drag');\r\n        const isDropEvent = event.type === 'drop';\r\n        const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\r\n        // any input event within node views should be ignored by ProseMirror\r\n        if (isInput && !isDropEvent && !isDragEvent) {\r\n            return true;\r\n        }\r\n        const { isEditable } = this.editor;\r\n        const { isDragging } = this;\r\n        const isDraggable = !!this.node.type.spec.draggable;\r\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\r\n        const isCopyEvent = event.type === 'copy';\r\n        const isPasteEvent = event.type === 'paste';\r\n        const isCutEvent = event.type === 'cut';\r\n        const isClickEvent = event.type === 'mousedown';\r\n        // ProseMirror tries to drag selectable nodes\r\n        // even if `draggable` is set to `false`\r\n        // this fix prevents that\r\n        if (!isDraggable && isSelectable && isDragEvent) {\r\n            event.preventDefault();\r\n        }\r\n        if (isDraggable && isDragEvent && !isDragging) {\r\n            event.preventDefault();\r\n            return false;\r\n        }\r\n        // we have to store that dragging started\r\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\r\n            const dragHandle = target.closest('[data-drag-handle]');\r\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\r\n            if (isValidDragHandle) {\r\n                this.isDragging = true;\r\n                document.addEventListener('dragend', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n                document.addEventListener('drop', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n                document.addEventListener('mouseup', () => {\r\n                    this.isDragging = false;\r\n                }, { once: true });\r\n            }\r\n        }\r\n        // these events are handled by prosemirror\r\n        if (isDragging\r\n            || isDropEvent\r\n            || isCopyEvent\r\n            || isPasteEvent\r\n            || isCutEvent\r\n            || (isClickEvent && isSelectable)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        if (!this.dom || !this.contentDOM) {\r\n            return true;\r\n        }\r\n        if (typeof this.options.ignoreMutation === 'function') {\r\n            return this.options.ignoreMutation({ mutation });\r\n        }\r\n        // a leaf/atom node is like a black box for ProseMirror\r\n        // and should be fully handled by the node view\r\n        if (this.node.isLeaf || this.node.isAtom) {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any selections\r\n        if (mutation.type === 'selection') {\r\n            return false;\r\n        }\r\n        // try to prevent a bug on iOS and Android that will break node views on enter\r\n        // this is because ProseMirror can’t preventDispatch on enter\r\n        // this will lead to a re-render of the node view on enter\r\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\r\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\r\n        if (this.dom.contains(mutation.target)\r\n            && mutation.type === 'childList'\r\n            && (isiOS() || isAndroid())\r\n            && this.editor.isFocused) {\r\n            const changedNodes = [\r\n                ...Array.from(mutation.addedNodes),\r\n                ...Array.from(mutation.removedNodes),\r\n            ];\r\n            // we’ll check if every changed node is contentEditable\r\n            // to make sure it’s probably mutated by ProseMirror\r\n            if (changedNodes.every(node => node.isContentEditable)) {\r\n                return false;\r\n            }\r\n        }\r\n        // we will allow mutation contentDOM with attributes\r\n        // so we can for example adding classes within our node view\r\n        if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\r\n            return true;\r\n        }\r\n        // ProseMirror should handle any changes within contentDOM\r\n        if (this.contentDOM.contains(mutation.target)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    updateAttributes(attributes) {\r\n        this.editor.commands.command(({ tr }) => {\r\n            const pos = this.getPos();\r\n            tr.setNodeMarkup(pos, undefined, {\r\n                ...this.node.attrs,\r\n                ...attributes,\r\n            });\r\n            return true;\r\n        });\r\n    }\r\n    deleteNode() {\r\n        const from = this.getPos();\r\n        const to = from + this.node.nodeSize;\r\n        this.editor.commands.deleteRange({ from, to });\r\n    }\r\n}\n\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\r\nfunction markPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            const { tr } = state;\r\n            const captureGroup = match[match.length - 1];\r\n            const fullMatch = match[0];\r\n            let markEnd = range.to;\r\n            if (captureGroup) {\r\n                const startSpaces = fullMatch.search(/\\S/);\r\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\r\n                const textEnd = textStart + captureGroup.length;\r\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\r\n                    .filter(item => {\r\n                    // @ts-ignore\r\n                    const excluded = item.mark.type.excluded;\r\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\r\n                })\r\n                    .filter(item => item.to > textStart);\r\n                if (excludedMarks.length) {\r\n                    return null;\r\n                }\r\n                if (textEnd < range.to) {\r\n                    tr.delete(textEnd, range.to);\r\n                }\r\n                if (textStart > range.from) {\r\n                    tr.delete(range.from + startSpaces, textStart);\r\n                }\r\n                markEnd = range.from + startSpaces + captureGroup.length;\r\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\r\n                tr.removeStoredMark(config.type);\r\n            }\r\n        },\r\n    });\r\n}\n\n// source: https://stackoverflow.com/a/6969486\r\nfunction escapeForRegEx(string) {\r\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\r\n}\n\nfunction isString(value) {\r\n    return typeof value === 'string';\r\n}\n\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\r\nfunction nodePasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler({ match, chain, range }) {\r\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\r\n            if (attributes === false || attributes === null) {\r\n                return null;\r\n            }\r\n            if (match.input) {\r\n                chain().deleteRange(range).insertContentAt(range.from, {\r\n                    type: config.type.name,\r\n                    attrs: attributes,\r\n                });\r\n            }\r\n        },\r\n    });\r\n}\n\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\r\nfunction textPasteRule(config) {\r\n    return new PasteRule({\r\n        find: config.find,\r\n        handler: ({ state, range, match }) => {\r\n            let insert = config.replace;\r\n            let start = range.from;\r\n            const end = range.to;\r\n            if (match[1]) {\r\n                const offset = match[0].lastIndexOf(match[1]);\r\n                insert += match[0].slice(offset + match[1].length);\r\n                start += offset;\r\n                const cutOff = start - end;\r\n                if (cutOff > 0) {\r\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\r\n                    start = end;\r\n                }\r\n            }\r\n            state.tr.insertText(insert, start, end);\r\n        },\r\n    });\r\n}\n\nclass Tracker {\r\n    constructor(transaction) {\r\n        this.transaction = transaction;\r\n        this.currentStep = this.transaction.steps.length;\r\n    }\r\n    map(position) {\r\n        let deleted = false;\r\n        const mappedPosition = this.transaction.steps\r\n            .slice(this.currentStep)\r\n            .reduce((newPosition, step) => {\r\n            const mapResult = step.getMap().mapResult(newPosition);\r\n            if (mapResult.deleted) {\r\n                deleted = true;\r\n            }\r\n            return mapResult.pos;\r\n        }, position);\r\n        return {\r\n            position: mappedPosition,\r\n            deleted,\r\n        };\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRztBQUM5RDtBQUNGO0FBQzBEO0FBQ29DO0FBQ29jO0FBQ3pjOztBQUVwSTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFVBQVUsWUFBWTtBQUN0QixVQUFVLE1BQU07QUFDaEIsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtCQUErQjtBQUN6RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0tBQXNLO0FBQ3pOLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0tBQXNLO0FBQ3pOLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSxvREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1Qix1QkFBdUIsb0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0MsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsaUNBQWlDLEtBQUs7QUFDdEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUseUJBQXlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdELGlCQUFpQjtBQUNqQixvQ0FBb0M7QUFDcEM7QUFDQSxpQ0FBaUMseURBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osVUFBVTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osZUFBZTtBQUNqSztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFNO0FBQ3RCLHlCQUF5Qix1REFBUztBQUNsQztBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekMsZ0NBQWdDLGdCQUFnQjtBQUNoRCxnQ0FBZ0MsaUJBQWlCO0FBQ2pELGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7O0FBRUEsNEJBQTRCLHFCQUFxQjtBQUNqRCxZQUFZLFlBQVk7QUFDeEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFVO0FBQzlDO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGlCQUFpQjtBQUN0RCxXQUFXLHdFQUFxQjtBQUNoQzs7QUFFQSwyQ0FBMkMsWUFBWTtBQUN2RCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQWE7QUFDckM7QUFDQTs7QUFFQSxtQ0FBbUMsY0FBYztBQUNqRCxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsY0FBYztBQUM5QyxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsaUJBQWlCO0FBQ2xELFdBQVcsb0VBQWlCO0FBQzVCOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7O0FBRUEsMEJBQTBCLGlCQUFpQjtBQUMzQyxXQUFXLDZEQUFVO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsUUFBUSxxQkFBcUI7QUFDakY7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDJEQUFhO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBUztBQUN0QywyQkFBMkIsdURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBYTtBQUM1QjtBQUNBLFdBQVcsMkRBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFRLDZCQUE2QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTs7QUFFQSw2Q0FBNkMsY0FBYztBQUMzRCxzQ0FBc0MsOENBQThDO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQVcsb0JBQW9CLG1FQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQix1REFBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLG1DQUFtQywrQkFBK0IsSUFBSTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekMsV0FBVywyREFBUTtBQUNuQjtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsV0FBVyw2REFBVTtBQUNyQjtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0MsV0FBVyxpRUFBYztBQUN6QjtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUMsV0FBVyxnRUFBYTtBQUN4Qjs7QUFFQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0Esc0JBQXNCLCtEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQSxzQkFBc0IsK0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnRkFBZ0YsZUFBZTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVEsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFNO0FBQ2pCOztBQUVBLGdDQUFnQyxpQkFBaUI7QUFDakQsV0FBVyxtRUFBZ0I7QUFDM0I7O0FBRUEsc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBLFdBQVcsb0VBQWM7QUFDekI7O0FBRUEsK0JBQStCLGlCQUFpQjtBQUNoRCxXQUFXLGtFQUFlO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLG9DQUFvQyxpQkFBaUI7QUFDckQsV0FBVyx1RUFBb0I7QUFDL0I7O0FBRUEsbUNBQW1DLGlCQUFpQjtBQUNwRCxXQUFXLHNFQUFtQjtBQUM5Qjs7QUFFQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELFdBQVcscUVBQWtCO0FBQzdCOztBQUVBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRCxXQUFXLHVFQUFvQjtBQUMvQjs7QUFFQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQsV0FBVyx5RUFBc0I7QUFDakM7O0FBRUEsMERBQTBEO0FBQzFELG9EQUFvRCw0QkFBNEI7QUFDaEY7O0FBRUEsa0VBQWtFLFFBQVEsc0JBQXNCO0FBQ2hHLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QiwyREFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQU07QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQSx3QkFBd0Isa0RBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsd0RBQXdEO0FBQ3hELFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUVBQW1FLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDJEQUFhO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxRQUFRLHFCQUFxQjtBQUN6RSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVEsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5Qiw0QkFBNEIsaUVBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLHFCQUFxQjtBQUN6QyxlQUFlLGlFQUFZO0FBQzNCLEtBQUs7QUFDTDtBQUNBOztBQUVBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSwwQkFBMEIsMkRBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsV0FBVyxtQ0FBbUMsK0JBQStCO0FBQzdGLHVCQUF1QiwyREFBYTtBQUNwQyx1QkFBdUIsMkRBQWE7QUFDcEM7QUFDQTtBQUNBLDBCQUEwQiwyREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0EsV0FBVyxvRUFBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUIsSUFBSSxRQUFRLDhCQUE4QjtBQUNuRixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLDZCQUE2QiwyREFBYTtBQUMxQyxvQ0FBb0MsOERBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsOERBQVE7QUFDMUI7QUFDQTtBQUNBLGVBQWUsOERBQVEsa0RBQWtELGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUUsdUJBQXVCLHNEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBUTtBQUN2QztBQUNBLDREQUE0RCxtREFBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0NBQWdDLDJEQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QyxjQUFjLDhDQUE4QztBQUM1RDtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLFNBQVMsOERBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILDZEQUFPO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILDZEQUFPO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxRQUFRLG9EQUFvRDtBQUMxSSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsUUFBUSxpQkFBaUI7QUFDdEYsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFLFFBQVEsaUJBQWlCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVEsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGNBQWM7QUFDN0MsWUFBWSxZQUFZO0FBQ3hCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVEscUJBQXFCO0FBQ3hFO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsUUFBUSxxQkFBcUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRLGlCQUFpQjtBQUNwRTtBQUNBLFdBQVcsMkRBQVE7QUFDbkI7O0FBRUEsK0NBQStDLFFBQVEsaUJBQWlCO0FBQ3hFO0FBQ0EsV0FBVyxrRUFBWTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQU07QUFDdEIseUJBQXlCLHVEQUFTO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxnQkFBZ0Isb0RBQU07QUFDdEIseUJBQXlCLHVEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGlCQUFpQjtBQUN6Qyx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBTTtBQUN0Qix5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QyxvQ0FBb0MsdURBQVM7QUFDN0MsbUNBQW1DLHVEQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQU07QUFDdEIseUJBQXlCLHVEQUFTO0FBQ2xDO0FBQ0EsMkRBQTJELGdCQUFnQixJQUFJO0FBQy9FLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSw0RUFBNEUsYUFBYSxPQUFPLE9BQU87QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYSxPQUFPLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQVU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsNEZBQTRGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRCx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osVUFBVTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osZUFBZTtBQUNqSztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QyxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osVUFBVTtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osZUFBZTtBQUNqSztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0EsNkJBQTZCLDJEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUksWUFBWTtBQUNqQztBQUNBO0FBQ0EsaUJBQWlCLElBQUksWUFBWTtBQUNqQztBQUNBO0FBQ0EsaUJBQWlCLElBQUksWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbzhDO0FBQ3A4QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcz9jNjgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uLCBTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJztcbmltcG9ydCB7IFNjaGVtYSwgRnJhZ21lbnQsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgTm9kZSBhcyBOb2RlJDEsIFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBsaWZ0VGFyZ2V0LCBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGpvaW5Qb2ludCwgVHJhbnNmb3JtLCBjYW5TcGxpdCwgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nO1xuaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEsIGRlbGV0ZVNlbGVjdGlvbiBhcyBkZWxldGVTZWxlY3Rpb24kMSwgZXhpdENvZGUgYXMgZXhpdENvZGUkMSwgam9pblVwIGFzIGpvaW5VcCQxLCBqb2luRG93biBhcyBqb2luRG93biQxLCBqb2luQmFja3dhcmQgYXMgam9pbkJhY2t3YXJkJDEsIGpvaW5Gb3J3YXJkIGFzIGpvaW5Gb3J3YXJkJDEsIGxpZnQgYXMgbGlmdCQxLCBsaWZ0RW1wdHlCbG9jayBhcyBsaWZ0RW1wdHlCbG9jayQxLCBuZXdsaW5lSW5Db2RlIGFzIG5ld2xpbmVJbkNvZGUkMSwgc2VsZWN0Tm9kZUJhY2t3YXJkIGFzIHNlbGVjdE5vZGVCYWNrd2FyZCQxLCBzZWxlY3ROb2RlRm9yd2FyZCBhcyBzZWxlY3ROb2RlRm9yd2FyZCQxLCBzZWxlY3RQYXJlbnROb2RlIGFzIHNlbGVjdFBhcmVudE5vZGUkMSwgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIHNlbGVjdFRleHRibG9ja0VuZCQxLCBzZWxlY3RUZXh0YmxvY2tTdGFydCBhcyBzZWxlY3RUZXh0YmxvY2tTdGFydCQxLCBzZXRCbG9ja1R5cGUsIHdyYXBJbiBhcyB3cmFwSW4kMSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnO1xuaW1wb3J0IHsgbGlmdExpc3RJdGVtIGFzIGxpZnRMaXN0SXRlbSQxLCBzaW5rTGlzdEl0ZW0gYXMgc2lua0xpc3RJdGVtJDEsIHdyYXBJbkxpc3QgYXMgd3JhcEluTGlzdCQxIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVN0YXRlKGNvbmZpZykge1xyXG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcclxuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XHJcbiAgICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGF0ZSxcclxuICAgICAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXHJcbiAgICAgICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcclxuICAgICAgICBmaWx0ZXJUcmFuc2FjdGlvbjogc3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcclxuICAgICAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcclxuICAgICAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXHJcbiAgICAgICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXHJcbiAgICAgICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkTWFya3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2VsZWN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGRvYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCB0cigpIHtcclxuICAgICAgICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XHJcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gdHJhbnNhY3Rpb24uc3RvcmVkTWFya3M7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xyXG4gICAgICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZTtcclxuICAgIH1cclxuICAgIGdldCBoYXNDdXN0b21TdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmN1c3RvbVN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVN0YXRlIHx8IHRoaXMuZWRpdG9yLnN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbW1hbmRzKCkge1xyXG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XHJcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNoYWluKCkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgY2FuKCkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNhbigpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2hhaW4oc3RhcnRUciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcclxuICAgICAgICBjb25zdCBoYXNTdGFydFRyYW5zYWN0aW9uID0gISFzdGFydFRyO1xyXG4gICAgICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcclxuICAgICAgICBjb25zdCBydW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaGFzU3RhcnRUcmFuc2FjdGlvblxyXG4gICAgICAgICAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcclxuICAgICAgICAgICAgICAgICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKVxyXG4gICAgICAgICAgICAgICAgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja3MuZXZlcnkoY2FsbGJhY2sgPT4gY2FsbGJhY2sgPT09IHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgY2hhaW4gPSB7XHJcbiAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBydW4sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2hhaW47XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYW4oc3RhcnRUcikge1xyXG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaCk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxyXG4gICAgICAgICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBidWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xyXG4gICAgICAgICAgICB0cixcclxuICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICB2aWV3LFxyXG4gICAgICAgICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXHJcbiAgICAgICAgICAgIGNhbjogKCkgPT4gdGhpcy5jcmVhdGVDYW4odHIpLFxyXG4gICAgICAgICAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50LCBmbikge1xyXG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xyXG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG9mZihldmVudCwgZm4pIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIGZpZWxkLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xyXG4gICAgICAgICAgICAuLi5jb250ZXh0LFxyXG4gICAgICAgICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcclxuICAgICAgICAgICAgICAgID8gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdO1xyXG59XG5cbmZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XHJcbiAgICBjb25zdCBiYXNlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ2V4dGVuc2lvbicpO1xyXG4gICAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJyk7XHJcbiAgICBjb25zdCBtYXJrRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmFzZUV4dGVuc2lvbnMsXHJcbiAgICAgICAgbm9kZUV4dGVuc2lvbnMsXHJcbiAgICAgICAgbWFya0V4dGVuc2lvbnMsXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBHZXQgYSBsaXN0IG9mIGFsbCBleHRlbnNpb24gYXR0cmlidXRlcyBkZWZpbmVkIGluIGBhZGRBdHRyaWJ1dGVgIGFuZCBgYWRkR2xvYmFsQXR0cmlidXRlYC5cclxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IFtdO1xyXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcclxuICAgIGNvbnN0IG5vZGVBbmRNYXJrRXh0ZW5zaW9ucyA9IFsuLi5ub2RlRXh0ZW5zaW9ucywgLi4ubWFya0V4dGVuc2lvbnNdO1xyXG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZSA9IHtcclxuICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIHJlbmRlcmVkOiB0cnVlLFxyXG4gICAgICAgIHJlbmRlckhUTUw6IG51bGwsXHJcbiAgICAgICAgcGFyc2VIVE1MOiBudWxsLFxyXG4gICAgICAgIGtlZXBPblNwbGl0OiB0cnVlLFxyXG4gICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgfTtcclxuICAgIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhZGRHbG9iYWxBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkR2xvYmFsQXR0cmlidXRlcycsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgR2xvYmFsQXR0cmlidXRlc2BcclxuICAgICAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVzID0gYWRkR2xvYmFsQXR0cmlidXRlcygpO1xyXG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xyXG4gICAgICAgICAgICBnbG9iYWxBdHRyaWJ1dGUudHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcclxuICAgICAgICAgICAgICAgIE9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYWRkQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEF0dHJpYnV0ZXMnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICBPYmplY3RcclxuICAgICAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcclxuICAgICAgICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxyXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgobWVyZ2VkQXR0ciA9PT0gbnVsbCB8fCBtZXJnZWRBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmlzUmVxdWlyZWQpICYmIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlZEF0dHIuZGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXM7XHJcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVR5cGUobmFtZU9yVHlwZSwgc2NoZW1hKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKCFzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV0pIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcclxufVxuXG5mdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0cykge1xyXG4gICAgcmV0dXJuIG9iamVjdHNcclxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxyXG4gICAgICAgIC5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHsgLi4uaXRlbXMgfTtcclxuICAgICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVDbGFzc2VzID0gdmFsdWUgPyB2YWx1ZS5zcGxpdCgnICcpIDogW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV0uc3BsaXQoJyAnKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIodmFsdWVDbGFzcyA9PiAhZXhpc3RpbmdDbGFzc2VzLmluY2x1ZGVzKHZhbHVlQ2xhc3MpKTtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFttZXJnZWRBdHRyaWJ1dGVzW2tleV0sIHZhbHVlXS5qb2luKCc7ICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWVyZ2VkQXR0cmlidXRlcztcclxuICAgIH0sIHt9KTtcclxufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZU9yTWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xyXG4gICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcclxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hdHRyaWJ1dGUucmVuZGVyZWQpXHJcbiAgICAgICAgLm1hcChpdGVtID0+IHtcclxuICAgICAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9O1xyXG4gICAgfSlcclxuICAgICAgICAucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSk7XHJcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxufVxuXG4vKipcclxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXHJcbiAqIE90aGVyd2lzZSBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cclxuICogQHBhcmFtIHZhbHVlIEZ1bmN0aW9uIG9yIGFueSB2YWx1ZS5cclxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0gcHJvcHMgT3B0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNhbGxPclJldHVybih2YWx1ZSwgY29udGV4dCA9IHVuZGVmaW5lZCwgLi4ucHJvcHMpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlKC4uLnByb3BzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KHZhbHVlID0ge30pIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XHJcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUubWF0Y2goL15bKy1dPyg/OlxcZCpcXC4pP1xcZCskLykpIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGludG8gcGFyc2VydWxlIGF0dHJpYnV0ZXMgKGBhdHRyc2Agb3IgYGdldEF0dHJzYCkuXHJcbiAqIENhbmNlbHMgd2hlbiBgZ2V0QXR0cnNgIHJldHVybmVkIGBmYWxzZWAuXHJcbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXHJcbiAqIEBwYXJhbSBleHRlbnNpb25BdHRyaWJ1dGVzIExpc3Qgb2YgYXR0cmlidXRlcyB0byBpbmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcclxuICAgIGlmIChwYXJzZVJ1bGUuc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VSdWxlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5wYXJzZVJ1bGUsXHJcbiAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzO1xyXG4gICAgICAgICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgID8gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBmcm9tU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLml0ZW1zLFxyXG4gICAgICAgICAgICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtKGRhdGEpIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zLCBlZGl0b3IpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XHJcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgdG9wTm9kZSA9IChfYSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3RvcE5vZGUnKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGV4dHJhTm9kZUZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmROb2RlU2NoZW1hJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXHJcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xyXG4gICAgICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb250ZW50JywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdpbmxpbmUnLCBjb250ZXh0KSksXHJcbiAgICAgICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZGVmaW5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkZWZpbmluZycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnaXNvbGF0aW5nJywgY29udGV4dCkpLFxyXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBleHRlbnNpb25BdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0IH1dO1xyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKTtcclxuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAocmVuZGVySFRNTCkge1xyXG4gICAgICAgICAgICBzY2hlbWEudG9ET00gPSBub2RlID0+IHJlbmRlckhUTUwoe1xyXG4gICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW5kZXJUZXh0ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVyVGV4dCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0KSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdO1xyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgbWFya3MgPSBPYmplY3QuZnJvbUVudHJpZXMobWFya0V4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmRNYXJrU2NoZW1hJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXHJcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xyXG4gICAgICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcclxuICAgICAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXHJcbiAgICAgICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xyXG4gICAgICAgIGlmIChwYXJzZUhUTUwpIHtcclxuICAgICAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVySFRNTCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChyZW5kZXJIVE1MKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG1hcmsgPT4gcmVuZGVySFRNTCh7XHJcbiAgICAgICAgICAgICAgICBtYXJrLFxyXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gbmV3IFNjaGVtYSh7XHJcbiAgICAgICAgdG9wTm9kZSxcclxuICAgICAgICBub2RlcyxcclxuICAgICAgICBtYXJrcyxcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XHJcbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsO1xyXG59XG5cbmZ1bmN0aW9uIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZW5hYmxlZCkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcclxuICAgICAgICByZXR1cm4gZW5hYmxlZC5zb21lKGVuYWJsZWRFeHRlbnNpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGVuYWJsZWRFeHRlbnNpb24gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cclxuICAgICAgICAgICAgICAgIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5hYmxlZDtcclxufVxuXG5jb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcclxuICAgIGxldCB0ZXh0QmVmb3JlID0gJyc7XHJcbiAgICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldDtcclxuICAgICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksIHNsaWNlRW5kUG9zLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjaHVuayA9ICgoX2IgPSAoX2EgPSBub2RlLnR5cGUuc3BlYykudG9UZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBwb3MsXHJcbiAgICAgICAgICAgIHBhcmVudCxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIHx8IG5vZGUudGV4dENvbnRlbnRcclxuICAgICAgICAgICAgfHwgJyVsZWFmJSc7XHJcbiAgICAgICAgdGV4dEJlZm9yZSArPSBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGV4dEJlZm9yZTtcclxufTtcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJztcclxufVxuXG5jbGFzcyBJbnB1dFJ1bGUge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmQ7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXI7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dCwgZmluZCkgPT4ge1xyXG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcclxuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XTtcclxuICAgIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4O1xyXG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcclxuICAgIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YTtcclxuICAgIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xyXG4gICAgICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5mdW5jdGlvbiBydW4kMShjb25maWcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiwgfSA9IGNvbmZpZztcclxuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xyXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xyXG4gICAgaWYgKFxyXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxyXG4gICAgJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xyXG4gICAgICAgIHx8ICEhKChfYSA9ICgkZnJvbS5ub2RlQmVmb3JlIHx8ICRmcm9tLm5vZGVBZnRlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlLnNwZWMuY29kZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRUZXh0Q29udGVudEZyb21Ob2RlcygkZnJvbSkgKyB0ZXh0O1xyXG4gICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcclxuICAgICAgICBpZiAobWF0Y2hlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xyXG4gICAgICAgICAgICBzdGF0ZTogdmlldy5zdGF0ZSxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xyXG4gICAgICAgICAgICBmcm9tOiBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xyXG4gICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xyXG4gICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgIG1hdGNoLFxyXG4gICAgICAgICAgICBjb21tYW5kcyxcclxuICAgICAgICAgICAgY2hhaW4sXHJcbiAgICAgICAgICAgIGNhbixcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzXHJcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcclxuICAgICAgICAvLyBzbyB3ZSBjYW4gdW5kbyBpbnB1dCBydWxlcyB3aXRoaW4gdGhlIGB1bmRvSW5wdXRSdWxlc2AgY29tbWFuZFxyXG4gICAgICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHIsXHJcbiAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xyXG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbWF0Y2hlZDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIGlucHV0IHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHRleHRcclxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcclxuICogYWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wcykge1xyXG4gICAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xyXG4gICAgICAgIHN0YXRlOiB7XHJcbiAgICAgICAgICAgIGluaXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXBwbHkodHIsIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdG9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnNlbGVjdGlvblNldCB8fCB0ci5kb2NDaGFuZ2VkID8gbnVsbCA6IHByZXY7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBydW4kMSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvbmVuZDogdmlldyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW4kMSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBleGFtcGxlIGZvciBjb2RlIGJsb2Nrc1xyXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1biQxKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnXFxuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBpc0lucHV0UnVsZXM6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwbHVnaW47XHJcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xyXG59XG5cbmNsYXNzIFBhc3RlUnVsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZDtcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcclxuICAgIH1cclxufVxyXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kKSA9PiB7XHJcbiAgICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGZpbmQodGV4dCk7XHJcbiAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAocGFzdGVSdWxlTWF0Y2ggPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtwYXN0ZVJ1bGVNYXRjaC50ZXh0XTtcclxuICAgICAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleDtcclxuICAgICAgICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xyXG4gICAgICAgIHJlc3VsdC5kYXRhID0gcGFzdGVSdWxlTWF0Y2guZGF0YTtcclxuICAgICAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcInBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwicGFzdGVSdWxlTWF0Y2gudGV4dFwiLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG59O1xyXG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XHJcbiAgICBjb25zdCB7IGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLCB9ID0gY29uZmlnO1xyXG4gICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcclxuICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XHJcbiAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5jb250ZW50LnNpemUpO1xyXG4gICAgICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKTtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZCk7XHJcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlc29sdmVkRnJvbSArIG1hdGNoLmluZGV4ICsgMTtcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xyXG4gICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgICAgIG1hdGNoLFxyXG4gICAgICAgICAgICAgICAgY29tbWFuZHMsXHJcbiAgICAgICAgICAgICAgICBjaGFpbixcclxuICAgICAgICAgICAgICAgIGNhbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHN1Y2Nlc3MgPSBoYW5kbGVycy5ldmVyeShoYW5kbGVyID0+IGhhbmRsZXIgIT09IG51bGwpO1xyXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcclxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xyXG4gKiBhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXN0ZVJ1bGVzUGx1Z2luKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzO1xyXG4gICAgbGV0IGRyYWdTb3VyY2VFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xyXG4gICAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XHJcbiAgICAgICAgICAgIHZpZXcodmlldykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyb3A6IHZpZXcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YSgndGV4dC9odG1sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gISEoaHRtbCA9PT0gbnVsbCB8fCBodG1sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodG1sLmluY2x1ZGVzKCdkYXRhLXBtLXNsaWNlJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3VpRXZlbnQnKSA9PT0gJ3Bhc3RlJyAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGlzIG5vIGNoYW5nZWQgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZlN0YXJ0KHN0YXRlLmRvYy5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgY2hhaW5hYmxlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGZvciBhbGwgcGFzdGUgcnVsZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogTWF0aC5tYXgoZnJvbSAtIDEsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0by5iIC0gMSxcclxuICAgICAgICAgICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHBsdWdpbnM7XHJcbn1cblxuZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoaXRlbXMpIHtcclxuICAgIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleCk7XHJcbiAgICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXTtcclxufVxuXG5jbGFzcyBFeHRlbnNpb25NYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xyXG4gICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzID0gW107XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgLy8gc3RvcmUgZXh0ZW5zaW9uIHN0b3JhZ2UgaW4gZWRpdG9yXHJcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnN0b3JhZ2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSAoX2EgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcy5wdXNoKGV4dGVuc2lvbi5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkJlZm9yZUNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uQmVmb3JlQ3JlYXRlJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uQ3JlYXRlJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvbkNyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2NyZWF0ZScsIG9uQ3JlYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uVXBkYXRlJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvblVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3VwZGF0ZScsIG9uVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uU2VsZWN0aW9uVXBkYXRlJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvblVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvblRyYW5zYWN0aW9uID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25UcmFuc2FjdGlvbicsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAob25UcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb25Gb2N1cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uRm9jdXMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKG9uRm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uQmx1cicsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAob25CbHVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvbkRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdkZXN0cm95Jywgb25EZXN0cm95KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9ucykge1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChFeHRlbnNpb25NYW5hZ2VyLmZsYXR0ZW4oZXh0ZW5zaW9ucykpO1xyXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSk7XHJcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBEdXBsaWNhdGUgZXh0ZW5zaW9uIG5hbWVzIGZvdW5kOiBbJHtkdXBsaWNhdGVkTmFtZXNcclxuICAgICAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBgJyR7aXRlbX0nYClcclxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfV0uIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9ucykge1xyXG4gICAgICAgIHJldHVybiAoZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRFeHRlbnNpb25zJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbiwgLi4udGhpcy5mbGF0dGVuKGFkZEV4dGVuc2lvbnMoKSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gYEluZmluaXR5YCB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc28gd2Ugc2V0IGEgbnVtYmVyIHRoYXQgaXMgcHJvYmFibHkgaGlnaCBlbm91Z2hcclxuICAgICAgICAgICAgLmZsYXQoMTApKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzb3J0KGV4dGVuc2lvbnMpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0UHJpb3JpdHkgPSAxMDA7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eUEgPSBnZXRFeHRlbnNpb25GaWVsZChhLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkKGIsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eTtcclxuICAgICAgICAgICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZENvbW1hbmRzJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uY29tbWFuZHMsXHJcbiAgICAgICAgICAgICAgICAuLi5hZGRDb21tYW5kcygpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuICAgIGdldCBwbHVnaW5zKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIC8vIFdpdGggUHJvc2VNaXJyb3IsIGZpcnN0IHBsdWdpbnMgd2l0aGluIGFuIGFycmF5IGFyZSBleGVjdXRlZCBmaXJzdC5cclxuICAgICAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcclxuICAgICAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cclxuICAgICAgICAvLyBUaGF04oCZcyB3aHkgd2UgaGF2ZSB0byByZXZlcnNlIHRoZSBgZXh0ZW5zaW9uc2AgYXJyYXkgYW5kIHNvcnQgYWdhaW5cclxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0UnVsZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBwYXN0ZVJ1bGVzID0gW107XHJcbiAgICAgICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5ncyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcclxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycgJiYgZXh0ZW5zaW9uLmNvbmZpZy5leGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleU1hcFBsdWdpbiA9IGtleW1hcChkZWZhdWx0QmluZGluZ3MpO1xyXG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZElucHV0UnVsZXMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlSW5wdXRSdWxlcykgJiYgYWRkSW5wdXRSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYWRkUGFzdGVSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFBhc3RlUnVsZXMnLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYWRkUHJvc2VNaXJyb3JQbHVnaW5zID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3NlTWlycm9yUGx1Z2lucyA9IGFkZFByb3NlTWlycm9yUGx1Z2lucygpO1xyXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbnM7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZsYXQoKTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBpbnB1dFJ1bGVzUGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIC4uLmFsbFBsdWdpbnMsXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcclxuICAgIH1cclxuICAgIGdldCBub2RlVmlld3MoKSB7XHJcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhub2RlRXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JykpXHJcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICghYWRkTm9kZVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub2RldmlldyA9IChub2RlLCB2aWV3LCBnZXRQb3MsIGRlY29yYXRpb25zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGROb2RlVmlldygpKHtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXRQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cblxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXHJcbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufVxyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcclxufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufVxuXG5jbGFzcyBFeHRlbnNpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXh0ZW5zaW9uJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnZXh0ZW5zaW9uJztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxyXG4gICAgICAgICAgICAuLi5jb25maWcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xyXG4gICAgICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxyXG4gICAgICAgIH0pKSB8fCB7fTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvbihjb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxyXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKTtcclxuICAgICAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgIH1cclxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IEV4dGVuc2lvbihleHRlbmRlZENvbmZpZyk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcclxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lO1xyXG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb247XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEJldHdlZW4oc3RhcnROb2RlLCByYW5nZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XHJcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgbGV0IHRleHQgPSAnJztcclxuICAgIGxldCBzZXBhcmF0ZWQgPSB0cnVlO1xyXG4gICAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PT0gbnVsbCB8fCB0ZXh0U2VyaWFsaXplcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRTZXJpYWxpemVyc1tub2RlLnR5cGUubmFtZV07XHJcbiAgICAgICAgaWYgKHRleHRTZXJpYWxpemVyKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgIXNlcGFyYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBwb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpIHtcclxuICAgICAgICAgICAgdGV4dCArPSAoX2EgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUudGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICBzZXBhcmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc0Jsb2NrICYmICFzZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcclxuICAgICAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0ZXh0O1xyXG59XG5cbmZ1bmN0aW9uIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcclxuICAgICAgICAuZmlsdGVyKChbLCBub2RlXSkgPT4gbm9kZS5zcGVjLnRvVGV4dClcclxuICAgICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSkpO1xyXG59XG5cbmNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInLFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXJzID0gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTZXJpYWxpemVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgYmx1ciA9ICgpID0+ICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XHJcbiAgICAgICAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCByZW1vdmUgdGhlIGNhcmV0IG9uIGJsdXIgYnV0IHNhZmFyaSBkb2VzIG5vdC5cclxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcclxuICAgICAgICAgICAgKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgY2xlYXJDb250ZW50ID0gKGVtaXRVcGRhdGUgPSBmYWxzZSkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpO1xyXG59O1xuXG5jb25zdCBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XHJcbiAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgaWYgKCFkaXNwYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XHJcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XHJcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRUbyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpKTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGNvbW1hbmQgPSBmbiA9PiBwcm9wcyA9PiB7XHJcbiAgICByZXR1cm4gZm4ocHJvcHMpO1xyXG59O1xuXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuY29uc3QgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xyXG4gICAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcclxuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcyk7XHJcbiAgICB0ci5pbnNlcnQobmV3UG9zLCBjb250ZW50U2xpY2UuY29udGVudCk7XHJcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobmV3UG9zIC0gMSkpKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBkZWxldGVDdXJyZW50Tm9kZSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XHJcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKTtcclxuICAgIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcclxuICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xyXG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xuXG5jb25zdCBkZWxldGVOb2RlID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yO1xyXG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xuXG5jb25zdCBkZWxldGVSYW5nZSA9IHJhbmdlID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBkZWxldGVTZWxlY3Rpb24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5jb25zdCBlbnRlciA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpO1xyXG59O1xuXG5jb25zdCBleGl0Q29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gZXhpdENvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG4vKipcclxuICogQ2hlY2sgaWYgb2JqZWN0MSBpbmNsdWRlcyBvYmplY3QyXHJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxyXG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKG9iamVjdDEsIG9iamVjdDIsIG9wdGlvbnMgPSB7IHN0cmljdDogdHJ1ZSB9KSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XHJcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xyXG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgb2JqZWN0SW5jbHVkZXMoaXRlbS5hdHRycywgYXR0cmlidXRlcyk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpc01hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxufVxyXG5mdW5jdGlvbiBnZXRNYXJrUmFuZ2UoJHBvcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KTtcclxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PT0gc3RhcnQub2Zmc2V0ICYmIHN0YXJ0Lm9mZnNldCAhPT0gMCkge1xyXG4gICAgICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzdGFydC5ub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmICghbWFyaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXg7XHJcbiAgICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXQ7XHJcbiAgICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMTtcclxuICAgIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemU7XHJcbiAgICBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbWFyay5pc0luU2V0KCRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrcykpIHtcclxuICAgICAgICBzdGFydEluZGV4IC09IDE7XHJcbiAgICAgICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemU7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XHJcbiAgICAgICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XHJcbiAgICAgICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZTtcclxuICAgICAgICBlbmRJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmcm9tOiBzdGFydFBvcyxcclxuICAgICAgICB0bzogZW5kUG9zLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lT3JUeXBlO1xyXG59XG5cbmNvbnN0IGV4dGVuZE1hcmtSYW5nZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcclxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGZpcnN0ID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xyXG4gICAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IGNvbW1hbmRzKHByb3BzKVxyXG4gICAgICAgIDogY29tbWFuZHM7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjtcclxufVxuXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XHJcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCBwb3NpdGlvbiA9IG51bGwpIHtcclxuICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpO1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKTtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0O1xyXG4gICAgfVxyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZDtcclxuICAgIH1cclxuICAgIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbTtcclxuICAgIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xyXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKTtcclxufVxuXG5mdW5jdGlvbiBpc2lPUygpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgJ2lQYWQgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBob25lIFNpbXVsYXRvcicsXHJcbiAgICAgICAgJ2lQb2QgU2ltdWxhdG9yJyxcclxuICAgICAgICAnaVBhZCcsXHJcbiAgICAgICAgJ2lQaG9uZScsXHJcbiAgICAgICAgJ2lQb2QnLFxyXG4gICAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pXHJcbiAgICAgICAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXHJcbiAgICAgICAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCk7XHJcbn1cblxuY29uc3QgZm9jdXMgPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoLCB9KSA9PiB7XHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGZvY3VzIHdpdGhpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBicmVha3MgZm9jdXMgb24gaU9TXHJcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBjYWxsIHRoaXNcclxuICAgICAgICBpZiAoaXNpT1MoKSkge1xyXG4gICAgICAgICAgICB2aWV3LmRvbS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTUyMFxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcm9sbEludG9WaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBpZiAoKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCkgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXHJcbiAgICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xyXG4gICAgICAgIGRlbGF5ZWRGb2N1cygpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcclxuICAgIC8vIHNpbmNlIHRyYW5zYWN0aW9ucyBjb3VsZCBjaGFuZ2UgdGhlIGVkaXRvcnMgc3RhdGUgYmVmb3JlIHRoaXMgY29tbWFuZCBoYXMgYmVlbiBydW5cclxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbik7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYHRyLnNldFNlbGVjdGlvbmAgcmVzZXRzIHRoZSBzdG9yZWQgbWFya3NcclxuICAgICAgICAvLyBzbyB3ZeKAmWxsIHJlc3RvcmUgdGhlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxyXG4gICAgICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcclxuICAgICAgICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxheWVkRm9jdXMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBmb3JFYWNoID0gKGl0ZW1zLCBmbikgPT4gcHJvcHMgPT4ge1xyXG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpO1xyXG59O1xuXG5jb25zdCBpbnNlcnRDb250ZW50ID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sIHZhbHVlLCBvcHRpb25zKTtcclxufTtcblxuZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWUpIHtcclxuICAgIC8vIGFkZCBhIHdyYXBwZXIgdG8gcHJlc2VydmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XHJcbiAgICByZXR1cm4gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcod3JhcHBlZFZhbHVlLCAndGV4dC9odG1sJykuYm9keTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICAgIHNsaWNlOiB0cnVlLFxyXG4gICAgICAgIHBhcnNlT3B0aW9uczoge30sXHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgIH07XHJcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIGNvbnRlbnQgIT09IG51bGwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSk7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2xpY2VcclxuICAgICAgICAgICAgPyBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnRcclxuICAgICAgICAgICAgOiBwYXJzZXIucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucyk7XHJcbn1cblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XHJcbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xyXG4gICAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XHJcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xyXG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF07XHJcbiAgICBsZXQgZW5kID0gMDtcclxuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHtcclxuICAgICAgICBpZiAoZW5kID09PSAwKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG5ld1RvO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcclxufVxuXG5jb25zdCBpc0ZyYWdtZW50ID0gKG5vZGVPckZyYWdtZW50KSA9PiB7XHJcbiAgICByZXR1cm4gbm9kZU9yRnJhZ21lbnQudG9TdHJpbmcoKS5zdGFydHNXaXRoKCc8Jyk7XHJcbn07XHJcbmNvbnN0IGluc2VydENvbnRlbnRBdCA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHBhcnNlT3B0aW9uczoge30sXHJcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVOb2RlRnJvbUNvbnRlbnQodmFsdWUsIGVkaXRvci5zY2hlbWEsIHtcclxuICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcclxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGRvbuKAmXQgZGlzcGF0Y2ggYW4gZW1wdHkgZnJhZ21lbnQgYmVjYXVzZSB0aGlzIGNhbiBsZWFkIHRvIHN0cmFuZ2UgZXJyb3JzXHJcbiAgICAgICAgaWYgKGNvbnRlbnQudG9TdHJpbmcoKSA9PT0gJzw+Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHsgZnJvbTogcG9zaXRpb24uZnJvbSwgdG86IHBvc2l0aW9uLnRvIH07XHJcbiAgICAgICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaXNPbmx5QmxvY2tDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFkZGVkIG5vZGUgaXMgdmFsaWRcclxuICAgICAgICAgICAgbm9kZS5jaGVjaygpO1xyXG4gICAgICAgICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcclxuICAgICAgICAgICAgaXNPbmx5QmxvY2tDb250ZW50ID0gaXNPbmx5QmxvY2tDb250ZW50ID8gbm9kZS5pc0Jsb2NrIDogZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcclxuICAgICAgICAvLyB0aGUgbmV3bHkgaW5zZXJ0ZWQgY29udGVudFxyXG4gICAgICAgIC8vIGV4YW1wbGU6XHJcbiAgICAgICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcclxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGluc2VydGluZyB0aGUgaW1hZ2UgYmVsb3cgdGhlIHBhcmFncmFwaFxyXG4gICAgICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xyXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gcGFyZW50LmlzVGV4dGJsb2NrICYmICFwYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgIXBhcmVudC5jaGlsZENvdW50O1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgZnJvbSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgdG8gKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IHBsYWluIHRleHQgd2UgaGF2ZSB0byB1c2UgYGluc2VydFRleHRgXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xyXG4gICAgICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBzdHJpbmcsIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHlcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlLm1hcCh2ID0+IHYudGV4dCB8fCAnJykuam9pbignJyksIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEhdmFsdWUgJiYgISF2YWx1ZS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlLnRleHQsIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQodmFsdWUsIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgY3Vyc29yIGF0IGVuZCBvZiBpbnNlcnRlZCBjb250ZW50XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGpvaW5VcCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gam9pblVwJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcclxuY29uc3Qgam9pbkRvd24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIGpvaW5Eb3duJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcclxuY29uc3Qgam9pbkJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBqb2luQmFja3dhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xyXG5jb25zdCBqb2luRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gam9pbkZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5jb25zdCBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgfSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKTtcclxuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xyXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2gge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcblxuY29uc3Qgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsICsxKTtcclxuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xyXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGlzTWFjT1MoKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xyXG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xyXG4gICAgICAgIHJlc3VsdCA9ICcgJztcclxuICAgIH1cclxuICAgIGxldCBhbHQ7XHJcbiAgICBsZXQgY3RybDtcclxuICAgIGxldCBzaGlmdDtcclxuICAgIGxldCBtZXRhO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcclxuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcclxuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XHJcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcclxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xyXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcclxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcclxuICAgICAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gO1xyXG4gICAgfVxyXG4gICAgaWYgKGN0cmwpIHtcclxuICAgICAgICByZXN1bHQgPSBgQ3RybC0ke3Jlc3VsdH1gO1xyXG4gICAgfVxyXG4gICAgaWYgKG1ldGEpIHtcclxuICAgICAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoaWZ0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IGtleWJvYXJkU2hvcnRjdXQgPSBuYW1lID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoLCB9KSA9PiB7XHJcbiAgICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLyk7XHJcbiAgICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoaXRlbSA9PiAhWydBbHQnLCAnQ3RybCcsICdNZXRhJywgJ1NoaWZ0J10uaW5jbHVkZXMoaXRlbSkpO1xyXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcclxuICAgICAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xyXG4gICAgICAgICAgICA/ICcgJ1xyXG4gICAgICAgICAgICA6IGtleSxcclxuICAgICAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxyXG4gICAgICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoJ0N0cmwnKSxcclxuICAgICAgICBtZXRhS2V5OiBrZXlzLmluY2x1ZGVzKCdNZXRhJyksXHJcbiAgICAgICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXHJcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcclxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XHJcbiAgICAgICAgdmlldy5zb21lUHJvcCgnaGFuZGxlS2V5RG93bicsIGYgPT4gZih2aWV3LCBldmVudCkpO1xyXG4gICAgfSk7XHJcbiAgICBjYXB0dXJlZFRyYW5zYWN0aW9uID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcclxuICAgICAgICBjb25zdCBuZXdTdGVwID0gc3RlcC5tYXAodHIubWFwcGluZyk7XHJcbiAgICAgICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmZ1bmN0aW9uIGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbDtcclxuICAgIGNvbnN0IG5vZGVSYW5nZXMgPSBbXTtcclxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSk7XHJcbiAgICAgICAgbm9kZVJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxyXG4gICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb207XHJcbiAgICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXNcclxuICAgICAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XHJcbiAgICB9KVxyXG4gICAgICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IG9iamVjdEluY2x1ZGVzKG5vZGVSYW5nZS5ub2RlLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpO1xyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMCk7XHJcbiAgICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XHJcbn1cblxuY29uc3QgbGlmdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmICghaXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGlmdCQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBsaWZ0RW1wdHlCbG9jayQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IGxpZnRMaXN0SXRlbSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgcmV0dXJuIGxpZnRMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IG5ld2xpbmVJbkNvZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIG5ld2xpbmVJbkNvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcclxuICAgIGlmIChzY2hlbWEubm9kZXNbbmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gJ25vZGUnO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYS5tYXJrc1tuYW1lXSkge1xyXG4gICAgICAgIHJldHVybiAnbWFyayc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxuXG4vKipcclxuICogUmVtb3ZlIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxyXG4gKiBAcGFyYW0gb2JqIE9iamVjdFxyXG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaiwgcHJvcE9yUHJvcHMpIHtcclxuICAgIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gW3Byb3BPclByb3BzXVxyXG4gICAgICAgIDogcHJvcE9yUHJvcHM7XHJcbiAgICByZXR1cm4gT2JqZWN0XHJcbiAgICAgICAgLmtleXMob2JqKVxyXG4gICAgICAgIC5yZWR1Y2UoKG5ld09iaiwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcclxuICAgICAgICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgfSwge30pO1xyXG59XG5cbmNvbnN0IHJlc2V0QXR0cmlidXRlcyA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzKSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGxldCBub2RlVHlwZSA9IG51bGw7XHJcbiAgICBsZXQgbWFya1R5cGUgPSBudWxsO1xyXG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBpZiAoIXNjaGVtYVR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XHJcbiAgICAgICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xyXG4gICAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIH1cclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4ocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBzY3JvbGxJbnRvVmlldyA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IHNlbGVjdEFsbCA9ICgpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbih7XHJcbiAgICAgICAgZnJvbTogMCxcclxuICAgICAgICB0bzogdHIuZG9jLmNvbnRlbnQuc2l6ZSxcclxuICAgIH0pO1xyXG59O1xuXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIHNlbGVjdE5vZGVCYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHJldHVybiBzZWxlY3ROb2RlRm9yd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgcmV0dXJuIHNlbGVjdFBhcmVudE5vZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0VGV4dGJsb2NrRW5kJDEoc3RhdGUsIGRpc3BhdGNoKTtcclxufTtcblxuLy8gQHRzLWlnbm9yZVxyXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gc2VsZWN0VGV4dGJsb2NrU3RhcnQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudChjb250ZW50LCBzY2hlbWEsIHBhcnNlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgeyBzbGljZTogZmFsc2UsIHBhcnNlT3B0aW9ucyB9KTtcclxufVxuXG5jb25zdCBzZXRDb250ZW50ID0gKGNvbnRlbnQsIGVtaXRVcGRhdGUgPSBmYWxzZSwgcGFyc2VPcHRpb25zID0ge30pID0+ICh7IHRyLCBlZGl0b3IsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcclxuICAgIGNvbnN0IGRvY3VtZW50ID0gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgZWRpdG9yLnNjaGVtYSwgcGFyc2VPcHRpb25zKTtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIGRvY3VtZW50KS5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XHJcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xyXG4gICAgaWYgKCFtYXJrKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9O1xyXG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYyk7XHJcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cmFuc2Zvcm07XHJcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpICs9IDEpIHtcclxuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XHJcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUpIHtcclxuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xyXG4gICAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQsIHBvcykgPT4ge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XHJcbn1cblxuLyoqXHJcbiAqIFNhbWUgYXMgYGZpbmRDaGlsZHJlbmAgYnV0IHNlYXJjaGVzIG9ubHkgd2l0aGluIGEgYHJhbmdlYC5cclxuICovXHJcbmZ1bmN0aW9uIGZpbmRDaGlsZHJlbkluUmFuZ2Uobm9kZSwgcmFuZ2UsIHByZWRpY2F0ZSkge1xyXG4gICAgY29uc3Qgbm9kZXNXaXRoUG9zID0gW107XHJcbiAgICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcclxuICAgIC8vICAgY29uc3Qgbm9kZUF0ID0gbm9kZS5ub2RlQXQocmFuZ2UuZnJvbSlcclxuICAgIC8vICAgaWYgKG5vZGVBdCkge1xyXG4gICAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcclxuICAgIC8vICAgICAgIG5vZGU6IG5vZGVBdCxcclxuICAgIC8vICAgICAgIHBvczogcmFuZ2UuZnJvbSxcclxuICAgIC8vICAgICB9KVxyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcbiAgICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xyXG4gICAgICAgICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcclxuICAgICAgICAgICAgICAgIHBvcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbm9kZXNXaXRoUG9zO1xyXG59XG5cbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKCRwb3MsIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGkpO1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBvczogaSA+IDAgPyAkcG9zLmJlZm9yZShpKSA6IDAsXHJcbiAgICAgICAgICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcclxuICAgICAgICAgICAgICAgIGRlcHRoOiBpLFxyXG4gICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudE5vZGUocHJlZGljYXRlKSB7XHJcbiAgICByZXR1cm4gKHNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpO1xyXG59XG5cbmZ1bmN0aW9uIGdldEhUTUxGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHNjaGVtYSkge1xyXG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpLnNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KTtcclxuICAgIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0ZW1wb3JhcnlEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcclxuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xyXG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zLCBlZGl0b3IpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKTtcclxuICAgIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcik7XHJcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYywgZXh0ZW5zaW9ucykge1xyXG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlJDEuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xyXG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKTtcclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbCwgZXh0ZW5zaW9ucykge1xyXG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgZG9tID0gZWxlbWVudEZyb21TdHJpbmcoaHRtbCk7XHJcbiAgICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xyXG59XG5cbmZ1bmN0aW9uIGdldFRleHQobm9kZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcmFuZ2UgPSB7XHJcbiAgICAgICAgZnJvbTogMCxcclxuICAgICAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKTtcclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVRleHQoZG9jLCBleHRlbnNpb25zLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlJDEuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xyXG4gICAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcclxuICAgICAgICBibG9ja1NlcGFyYXRvcixcclxuICAgICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcclxuICAgICAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpLFxyXG4gICAgICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcclxuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgLi4ubm9kZS5hdHRycyB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcclxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xyXG4gICAgICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7fTtcclxufVxuXG4vKipcclxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHZhbHVlcyB3aXRoaW4gYW4gYXJyYXkuXHJcbiAqIFN1cHBvcnRzIG51bWJlcnMsIHN0cmluZ3MgYW5kIG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycmF5LCBieSA9IEpTT04uc3RyaW5naWZ5KSB7XHJcbiAgICBjb25zdCBzZWVuID0ge307XHJcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KVxyXG4gICAgICAgICAgICA/IGZhbHNlXHJcbiAgICAgICAgICAgIDogKHNlZW5ba2V5XSA9IHRydWUpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCByYW5nZXMgYW5kIHJhbmdlcyB0aGF0IGFyZVxyXG4gKiBmdWxseSBjYXB0dXJlZCBieSBvdGhlciByYW5nZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcykge1xyXG4gICAgY29uc3QgdW5pcXVlQ2hhbmdlcyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2hhbmdlcyk7XHJcbiAgICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcclxuICAgICAgICA/IHVuaXF1ZUNoYW5nZXNcclxuICAgICAgICA6IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChjaGFuZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlLm9sZFJhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2Uub2xkUmFuZ2UuZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xyXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm5ld1JhbmdlLmZyb21cclxuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UudG8gPD0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UudG87XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VkIHJhbmdlc1xyXG4gKiBiYXNlZCBvbiB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGUgb2YgYWxsIHN0ZXBzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pIHtcclxuICAgIGNvbnN0IHsgbWFwcGluZywgc3RlcHMgfSA9IHRyYW5zZm9ybTtcclxuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcclxuICAgIG1hcHBpbmcubWFwcy5mb3JFYWNoKChzdGVwTWFwLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxyXG4gICAgICAgIC8vIGUuZy4gd2hlbiBzZXR0aW5nIGEgbWFyaywgbm9kZSBhdHRyaWJ1dGUsIGV0Yy5cclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RlcE1hcC5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAodG8pO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XHJcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvbGRSYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiBvbGRFbmQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3UmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBuZXdTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3RW5kLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcyk7XHJcbn1cblxuZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc3QgaXNUb3BOb2RlID0gbm9kZS50eXBlID09PSBub2RlLnR5cGUuc2NoZW1hLnRvcE5vZGVUeXBlO1xyXG4gICAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDE7XHJcbiAgICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXQ7XHJcbiAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplO1xyXG4gICAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcChtYXJrID0+IHtcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IG1hcmsudHlwZS5uYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvdXRwdXQuYXR0cnMgPSB7IC4uLm1hcmsuYXR0cnMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYXR0cnMgPSB7IC4uLm5vZGUuYXR0cnMgfTtcclxuICAgIGNvbnN0IG91dHB1dCA9IHtcclxuICAgICAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcclxuICAgICAgICBmcm9tLFxyXG4gICAgICAgIHRvLFxyXG4gICAgfTtcclxuICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XHJcbiAgICAgICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XHJcbiAgICB9XHJcbiAgICBpZiAobWFya3MubGVuZ3RoKSB7XHJcbiAgICAgICAgb3V0cHV0Lm1hcmtzID0gbWFya3M7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQpIHtcclxuICAgICAgICBvdXRwdXQuY29udGVudCA9IFtdO1xyXG4gICAgICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IG91dHB1dC5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50ZXh0KSB7XHJcbiAgICAgICAgb3V0cHV0LnRleHQgPSBub2RlLnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XG5cbmZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tLCB0bywgZG9jKSB7XHJcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xyXG4gICAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXHJcbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICBkb2NcclxuICAgICAgICAgICAgLnJlc29sdmUoZnJvbSlcclxuICAgICAgICAgICAgLm1hcmtzKClcclxuICAgICAgICAgICAgLmZvckVhY2gobWFyayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tIC0gMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSk7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG1hcmssXHJcbiAgICAgICAgICAgICAgICAuLi5yYW5nZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XHJcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xyXG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxyXG4gICAgICAgICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXHJcbiAgICAgICAgICAgICAgICBtYXJrLFxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcmtzO1xyXG59XG5cbi8qKlxyXG4gKiBGaW5kcyB0aGUgZmlyc3Qgbm9kZSBvZiBhIGdpdmVuIHR5cGUgb3IgbmFtZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxyXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSB0eXBlIG9yIG5hbWUuXHJcbiAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxyXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxyXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhbmQgdGhlIGRlcHRoIGFzIGFuIGFycmF5LlxyXG4gKi9cclxuY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGUsIHR5cGVPck5hbWUsIHBvcywgbWF4RGVwdGggPSAyMCkgPT4ge1xyXG4gICAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XHJcbiAgICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGg7XHJcbiAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSAkcG9zLm5vZGUoY3VycmVudERlcHRoKTtcclxuICAgICAgICBpZiAoKGN1cnJlbnROb2RlID09PSBudWxsIHx8IGN1cnJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS50eXBlLm5hbWUpID09PSB0eXBlT3JOYW1lKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnREZXB0aCAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbbm9kZSwgY3VycmVudERlcHRoXTtcclxufTtcblxuZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsIHR5cGVOYW1lLCBhdHRyaWJ1dGVzKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdFxyXG4gICAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXHJcbiAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5maW5kKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlTmFtZSAmJiBpdGVtLm5hbWUgPT09IG5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZS5rZWVwT25TcGxpdDtcclxuICAgIH0pKTtcclxufVxuXG5mdW5jdGlvbiBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHN0YXRlLnN0b3JlZE1hcmtzIHx8IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxyXG4gICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmsudHlwZS5uYW1lO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcclxuICAgIH1cclxuICAgIGxldCBzZWxlY3Rpb25SYW5nZSA9IDA7XHJcbiAgICBjb25zdCBtYXJrUmFuZ2VzID0gW107XHJcbiAgICByYW5nZXMuZm9yRWFjaCgoeyAkZnJvbSwgJHRvIH0pID0+IHtcclxuICAgICAgICBjb25zdCBmcm9tID0gJGZyb20ucG9zO1xyXG4gICAgICAgIGNvbnN0IHRvID0gJHRvLnBvcztcclxuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcclxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByZWxhdGl2ZVRvIC0gcmVsYXRpdmVGcm9tO1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSArPSByYW5nZTtcclxuICAgICAgICAgICAgbWFya1Jhbmdlcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcclxuICAgICAgICAgICAgICAgIG1hcmssXHJcbiAgICAgICAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xyXG4gICAgY29uc3QgbWF0Y2hlZFJhbmdlID0gbWFya1Jhbmdlc1xyXG4gICAgICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZTtcclxuICAgIH0pXHJcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcclxuICAgICAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xyXG4gICAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hcmtzIHRoYXQgZXhjbHVkZXMgdGhlIHNlYXJjaGVkIG1hcmtcclxuICAgIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXHJcbiAgICBjb25zdCBleGNsdWRlZFJhbmdlID0gbWFya1Jhbmdlc1xyXG4gICAgICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSk7XHJcbiAgICB9KVxyXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMCk7XHJcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcclxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbWF0Y2ggYXQgYWxsXHJcbiAgICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlO1xyXG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xyXG59XG5cbmZ1bmN0aW9uIGlzQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcclxuICAgICAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcclxuICAgICAgICByZXR1cm4gaXNNYXJrQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG5jb25zdCBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlLCBub2RlVHlwZSkgPT4ge1xyXG4gICAgY29uc3QgeyAkZnJvbSwgJHRvLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XHJcbiAgICBpZiAobm9kZVR5cGUpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbik7XHJcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSk7XHJcbiAgICAgICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5mdW5jdGlvbiBpc0xpc3QobmFtZSwgZXh0ZW5zaW9ucykge1xyXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbm9kZUV4dGVuc2lvbnMuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gbmFtZSk7XHJcbiAgICBpZiAoIWV4dGVuc2lvbikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ3JvdXAgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSk7XHJcbiAgICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jyk7XHJcbn1cblxuZnVuY3Rpb24gaXNOb2RlRW1wdHkobm9kZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZGVmYXVsdENvbnRlbnQgPSAoX2EgPSBub2RlLnR5cGUuY3JlYXRlQW5kRmlsbCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCk7XHJcbiAgICBjb25zdCBjb250ZW50ID0gbm9kZS50b0pTT04oKTtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xyXG59XG5cbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcclxufVxuXG5mdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pIHtcclxuICAgIGNvbnN0IG1pblBvcyA9IDA7XHJcbiAgICBjb25zdCBtYXhQb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemU7XHJcbiAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEZyb20pO1xyXG4gICAgY29uc3QgZW5kID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEVuZCwgLTEpO1xyXG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcclxuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHN0YXJ0LmJvdHRvbSwgZW5kLmJvdHRvbSk7XHJcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcclxuICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xyXG4gICAgY29uc3QgeCA9IGxlZnQ7XHJcbiAgICBjb25zdCB5ID0gdG9wO1xyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICB0b3AsXHJcbiAgICAgICAgYm90dG9tLFxyXG4gICAgICAgIGxlZnQsXHJcbiAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmRhdGEsXHJcbiAgICAgICAgdG9KU09OOiAoKSA9PiBkYXRhLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgbmV3TWFya1R5cGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGxldCBjdXJzb3IgPSBudWxsO1xyXG4gICAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgY3Vyc29yID0gc2VsZWN0aW9uLiRjdXJzb3I7XHJcbiAgICB9XHJcbiAgICBpZiAoY3Vyc29yKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gKF9hID0gc3RhdGUuc3RvcmVkTWFya3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cnNvci5tYXJrcygpO1xyXG4gICAgICAgIC8vIFRoZXJlIGNhbiBiZSBubyBjdXJyZW50IG1hcmtzIHRoYXQgZXhjbHVkZSB0aGUgbmV3IG1hcmtcclxuICAgICAgICByZXR1cm4gKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpXHJcbiAgICAgICAgICAgIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XHJcbiAgICByZXR1cm4gcmFuZ2VzLnNvbWUoKHsgJGZyb20sICR0byB9KSA9PiB7XHJcbiAgICAgICAgbGV0IHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gJGZyb20uZGVwdGggPT09IDBcclxuICAgICAgICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcclxuICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIF9wb3MsIHBhcmVudCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcclxuICAgICAgICAgICAgaWYgKHNvbWVOb2RlU3VwcG9ydHNNYXJrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEFsbG93c01hcmtUeXBlID0gIXBhcmVudCB8fCBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIW5vZGUubWFya3Muc29tZShvdGhlck1hcmsgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKTtcclxuICAgICAgICAgICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gIXNvbWVOb2RlU3VwcG9ydHNNYXJrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFyaztcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBpZiAoZW1wdHkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcclxuICAgICAgICAgICAgdHIuYWRkU3RvcmVkTWFyayh0eXBlLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcclxuICAgICAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbWFyayBvZiB0aGlzIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgd2UgaGF2ZSB0byBtZXJnZSBpdHMgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBhZGQgYSBmcmVzaCBuZXcgbWFya1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb21lSGFzTWFyaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbWFyay50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIHR5cGUpO1xyXG59O1xuXG5jb25zdCBzZXRNZXRhID0gKGtleSwgdmFsdWUpID0+ICh7IHRyIH0pID0+IHtcclxuICAgIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3Qgc2V0Tm9kZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICAvLyBUT0RPOiB1c2UgYSBmYWxsYmFjayBsaWtlIGluc2VydENvbnRlbnQ/XHJcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNoYWluKClcclxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcclxuICAgICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykoc3RhdGUpO1xyXG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgIH0pXHJcbiAgICAgICAgLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKSh1cGRhdGVkU3RhdGUsIGRpc3BhdGNoKTtcclxuICAgIH0pXHJcbiAgICAgICAgLnJ1bigpKTtcclxufTtcblxuY29uc3Qgc2V0Tm9kZVNlbGVjdGlvbiA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCB7IGRvYyB9ID0gdHI7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBmcm9tKTtcclxuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBzZXRUZXh0U2VsZWN0aW9uID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcclxuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tO1xyXG4gICAgICAgIGNvbnN0IG1heFBvcyA9IFRleHRTZWxlY3Rpb24uYXRFbmQoZG9jKS50bztcclxuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcyk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKTtcclxuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCBzaW5rTGlzdEl0ZW0gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIHJldHVybiBzaW5rTGlzdEl0ZW0kMSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xyXG59O1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XHJcbiAgICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICBpZiAobWFya3MpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzID09PSBudWxsIHx8IHNwbGl0dGFibGVNYXJrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XHJcbiAgICAgICAgc3RhdGUudHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgc3BsaXRCbG9jayA9ICh7IGtlZXBNYXJrcyA9IHRydWUgfSA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcclxuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyO1xyXG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XHJcbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcclxuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKTtcclxuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcclxuICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgIGlmIChrZWVwTWFya3MpIHtcclxuICAgICAgICAgICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PT0gMFxyXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XHJcbiAgICAgICAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHRcclxuICAgICAgICAgICAgPyBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcclxuICAgICAgICBpZiAoIXR5cGVzXHJcbiAgICAgICAgICAgICYmICFjYW5cclxuICAgICAgICAgICAgJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICBjYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0eXBlcyA9IGRlZmx0XHJcbiAgICAgICAgICAgICAgICA/IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW4pIHtcclxuICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xyXG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcclxuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZWVwTWFya3MpIHtcclxuICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3Qgc3BsaXRMaXN0SXRlbSA9IHR5cGVPck5hbWUgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLCB9KSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBjb25zdCBub2RlID0gc3RhdGUuc2VsZWN0aW9uLm5vZGU7XHJcbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XHJcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xyXG4gICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcclxuICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcclxuICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxyXG4gICAgICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXHJcbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyXHJcbiAgICAgICAgICAgIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT09IHR5cGVcclxuICAgICAgICAgICAgfHwgJGZyb20uaW5kZXgoLTIpICE9PSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgY29uc3QgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXHJcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxyXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgY29uc3QgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcclxuICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxyXG4gICAgICAgICAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFR5cGUgPSAoKF9hID0gdHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlcykpIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGVBbmRGaWxsKG51bGwsIG5leHRUeXBlKSB8fCB1bmRlZmluZWQpKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XHJcbiAgICAgICAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xyXG4gICAgICAgICAgICBsZXQgc2VsID0gLTE7XHJcbiAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuLmlzVGV4dGJsb2NrICYmIG4uY29udGVudC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsID0gcG9zICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChzZWwgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xyXG4gICAgY29uc3QgbmV3VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLCBncmFuZFBhcmVudC5hdHRycyk7XHJcbiAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKTtcclxuICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xyXG4gICAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxyXG4gICAgICAgID8gW1xyXG4gICAgICAgICAgICB7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9LFxyXG4gICAgICAgICAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH0sXHJcbiAgICAgICAgXVxyXG4gICAgICAgIDogW3sgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH1dO1xyXG4gICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcclxuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICBpZiAoIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xyXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbmNvbnN0IGpvaW5MaXN0QmFja3dhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xyXG4gICAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKTtcclxuICAgIGlmICghbGlzdCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgbGlzdC5wb3MgLSAxKSkuYmVmb3JlKGxpc3QuZGVwdGgpO1xyXG4gICAgaWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpO1xyXG4gICAgY29uc3QgY2FuSm9pbkJhY2t3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSAobm9kZUJlZm9yZSA9PT0gbnVsbCB8fCBub2RlQmVmb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQmVmb3JlLnR5cGUpICYmIGNhbkpvaW4odHIuZG9jLCBsaXN0LnBvcyk7XHJcbiAgICBpZiAoIWNhbkpvaW5CYWNrd2FyZHMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRyLmpvaW4obGlzdC5wb3MpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbmNvbnN0IGpvaW5MaXN0Rm9yd2FyZHMgPSAodHIsIGxpc3RUeXBlKSA9PiB7XHJcbiAgICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xyXG4gICAgaWYgKCFsaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpO1xyXG4gICAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5vZGVBZnRlciA9IHRyLmRvYy5ub2RlQXQoYWZ0ZXIpO1xyXG4gICAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQWZ0ZXIgPT09IG51bGwgfHwgbm9kZUFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcclxuICAgIGlmICghY2FuSm9pbkZvcndhcmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB0ci5qb2luKGFmdGVyKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5jb25zdCB0b2dnbGVMaXN0ID0gKGxpc3RUeXBlT3JOYW1lLCBpdGVtVHlwZU9yTmFtZSwga2VlcE1hcmtzLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IGVkaXRvciwgdHIsIHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4sIGNvbW1hbmRzLCBjYW4sIH0pID0+IHtcclxuICAgIGNvbnN0IHsgZXh0ZW5zaW9ucywgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcclxuICAgIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcclxuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xyXG4gICAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XHJcbiAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICBpZiAoIXJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcclxuICAgIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcclxuICAgICAgICAvLyByZW1vdmUgbGlzdFxyXG4gICAgICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoYW5nZSBsaXN0IHR5cGVcclxuICAgICAgICBpZiAoaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpXHJcbiAgICAgICAgICAgICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudClcclxuICAgICAgICAgICAgJiYgZGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcclxuICAgICAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcclxuICAgICAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcclxuICAgICAgICAgICAgICAgIC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWtlZXBNYXJrcyB8fCAhbWFya3MgfHwgIWRpc3BhdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYWluKClcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcclxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcclxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxyXG4gICAgICAgICAgICAucnVuKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGNoYWluKClcclxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcclxuICAgICAgICAuY29tbWFuZCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcclxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcclxuICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgIH0pXHJcbiAgICAgICAgLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXHJcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcclxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXHJcbiAgICAgICAgLnJ1bigpKTtcclxufTtcblxuY29uc3QgdG9nZ2xlTWFyayA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcclxuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgaXNBY3RpdmUgPSBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgaWYgKGlzQWN0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcyk7XHJcbn07XG5cbmNvbnN0IHRvZ2dsZU5vZGUgPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmIChpc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgYXR0cmlidXRlcyk7XHJcbn07XG5cbmNvbnN0IHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XHJcbiAgICBpZiAoaXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XHJcbn07XG5cbmNvbnN0IHVuZG9JbnB1dFJ1bGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldO1xyXG4gICAgICAgIGxldCB1bmRvYWJsZTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50byk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xuXG5jb25zdCB1bnNldEFsbE1hcmtzID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgaWYgKGVtcHR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzcGF0Y2gpIHtcclxuICAgICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xuXG5jb25zdCB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgY29uc3QgeyAkZnJvbSwgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xyXG4gICAgaWYgKCFkaXNwYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XHJcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICBjb25zdCBhdHRycyA9IChfYSA9ICRmcm9tLm1hcmtzKCkuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRycztcclxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xyXG4gICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICBmcm9tID0gcmFuZ2UuZnJvbTtcclxuICAgICAgICAgICAgdG8gPSByYW5nZS50bztcclxuICAgICAgICB9XHJcbiAgICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3QgdXBkYXRlQXR0cmlidXRlcyA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcclxuICAgIGxldCBtYXJrVHlwZSA9IG51bGw7XHJcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcclxuICAgIGlmICghc2NoZW1hVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcclxuICAgICAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XHJcbiAgICAgICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcclxuICAgICAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xyXG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgbWFya1R5cGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxuY29uc3Qgd3JhcEluID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xyXG4gICAgcmV0dXJuIHdyYXBJbiQxKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbmNvbnN0IHdyYXBJbkxpc3QgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XHJcbiAgICByZXR1cm4gd3JhcEluTGlzdCQxKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XHJcbn07XG5cbnZhciBjb21tYW5kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBibHVyOiBibHVyLFxuICBjbGVhckNvbnRlbnQ6IGNsZWFyQ29udGVudCxcbiAgY2xlYXJOb2RlczogY2xlYXJOb2RlcyxcbiAgY29tbWFuZDogY29tbWFuZCxcbiAgY3JlYXRlUGFyYWdyYXBoTmVhcjogY3JlYXRlUGFyYWdyYXBoTmVhcixcbiAgY3V0OiBjdXQsXG4gIGRlbGV0ZUN1cnJlbnROb2RlOiBkZWxldGVDdXJyZW50Tm9kZSxcbiAgZGVsZXRlTm9kZTogZGVsZXRlTm9kZSxcbiAgZGVsZXRlUmFuZ2U6IGRlbGV0ZVJhbmdlLFxuICBkZWxldGVTZWxlY3Rpb246IGRlbGV0ZVNlbGVjdGlvbixcbiAgZW50ZXI6IGVudGVyLFxuICBleGl0Q29kZTogZXhpdENvZGUsXG4gIGV4dGVuZE1hcmtSYW5nZTogZXh0ZW5kTWFya1JhbmdlLFxuICBmaXJzdDogZmlyc3QsXG4gIGZvY3VzOiBmb2N1cyxcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgaW5zZXJ0Q29udGVudDogaW5zZXJ0Q29udGVudCxcbiAgaW5zZXJ0Q29udGVudEF0OiBpbnNlcnRDb250ZW50QXQsXG4gIGpvaW5VcDogam9pblVwLFxuICBqb2luRG93bjogam9pbkRvd24sXG4gIGpvaW5CYWNrd2FyZDogam9pbkJhY2t3YXJkLFxuICBqb2luRm9yd2FyZDogam9pbkZvcndhcmQsXG4gIGpvaW5JdGVtQmFja3dhcmQ6IGpvaW5JdGVtQmFja3dhcmQsXG4gIGpvaW5JdGVtRm9yd2FyZDogam9pbkl0ZW1Gb3J3YXJkLFxuICBrZXlib2FyZFNob3J0Y3V0OiBrZXlib2FyZFNob3J0Y3V0LFxuICBsaWZ0OiBsaWZ0LFxuICBsaWZ0RW1wdHlCbG9jazogbGlmdEVtcHR5QmxvY2ssXG4gIGxpZnRMaXN0SXRlbTogbGlmdExpc3RJdGVtLFxuICBuZXdsaW5lSW5Db2RlOiBuZXdsaW5lSW5Db2RlLFxuICByZXNldEF0dHJpYnV0ZXM6IHJlc2V0QXR0cmlidXRlcyxcbiAgc2Nyb2xsSW50b1ZpZXc6IHNjcm9sbEludG9WaWV3LFxuICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcbiAgc2VsZWN0Tm9kZUJhY2t3YXJkOiBzZWxlY3ROb2RlQmFja3dhcmQsXG4gIHNlbGVjdE5vZGVGb3J3YXJkOiBzZWxlY3ROb2RlRm9yd2FyZCxcbiAgc2VsZWN0UGFyZW50Tm9kZTogc2VsZWN0UGFyZW50Tm9kZSxcbiAgc2VsZWN0VGV4dGJsb2NrRW5kOiBzZWxlY3RUZXh0YmxvY2tFbmQsXG4gIHNlbGVjdFRleHRibG9ja1N0YXJ0OiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgc2V0Q29udGVudDogc2V0Q29udGVudCxcbiAgc2V0TWFyazogc2V0TWFyayxcbiAgc2V0TWV0YTogc2V0TWV0YSxcbiAgc2V0Tm9kZTogc2V0Tm9kZSxcbiAgc2V0Tm9kZVNlbGVjdGlvbjogc2V0Tm9kZVNlbGVjdGlvbixcbiAgc2V0VGV4dFNlbGVjdGlvbjogc2V0VGV4dFNlbGVjdGlvbixcbiAgc2lua0xpc3RJdGVtOiBzaW5rTGlzdEl0ZW0sXG4gIHNwbGl0QmxvY2s6IHNwbGl0QmxvY2ssXG4gIHNwbGl0TGlzdEl0ZW06IHNwbGl0TGlzdEl0ZW0sXG4gIHRvZ2dsZUxpc3Q6IHRvZ2dsZUxpc3QsXG4gIHRvZ2dsZU1hcms6IHRvZ2dsZU1hcmssXG4gIHRvZ2dsZU5vZGU6IHRvZ2dsZU5vZGUsXG4gIHRvZ2dsZVdyYXA6IHRvZ2dsZVdyYXAsXG4gIHVuZG9JbnB1dFJ1bGU6IHVuZG9JbnB1dFJ1bGUsXG4gIHVuc2V0QWxsTWFya3M6IHVuc2V0QWxsTWFya3MsXG4gIHVuc2V0TWFyazogdW5zZXRNYXJrLFxuICB1cGRhdGVBdHRyaWJ1dGVzOiB1cGRhdGVBdHRyaWJ1dGVzLFxuICB3cmFwSW46IHdyYXBJbixcbiAgd3JhcEluTGlzdDogd3JhcEluTGlzdFxufSk7XG5cbmNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnY29tbWFuZHMnLFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uY29tbWFuZHMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5jb25zdCBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2VkaXRhYmxlJyxcclxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmNvbnN0IEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnZm9jdXNFdmVudHMnLFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdmb2N1c0V2ZW50cycpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6ICh2aWV3LCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50clxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdmb2N1cycsIHsgZXZlbnQgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYmx1cicsIHsgZXZlbnQgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAna2V5bWFwJyxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxyXG4gICAgICAgICAgICAvLyBtYXliZSBjb252ZXJ0IGZpcnN0IHRleHQgYmxvY2sgbm9kZSB0byBkZWZhdWx0IG5vZGVcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0cjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gJGFuY2hvci5wYXJlbnQuaXNUZXh0YmxvY2sgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSAkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXHJcbiAgICAgICAgICAgICAgICAgICAgOiBTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb20gPT09IHBvcztcclxuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgIWlzQXRTdGFydCB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZUN1cnJlbnROb2RlKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKCksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXHJcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLm5ld2xpbmVJbkNvZGUoKSxcclxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY3JlYXRlUGFyYWdyYXBoTmVhcigpLFxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxyXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zcGxpdEJsb2NrKCksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgYmFzZUtleW1hcCA9IHtcclxuICAgICAgICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxyXG4gICAgICAgICAgICAnTW9kLUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKSxcclxuICAgICAgICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXHJcbiAgICAgICAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxyXG4gICAgICAgICAgICAnU2hpZnQtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxyXG4gICAgICAgICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcclxuICAgICAgICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXHJcbiAgICAgICAgICAgICdNb2QtYSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcGNLZXltYXAgPSB7XHJcbiAgICAgICAgICAgIC4uLmJhc2VLZXltYXAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtYWNLZXltYXAgPSB7XHJcbiAgICAgICAgICAgIC4uLmJhc2VLZXltYXAsXHJcbiAgICAgICAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXHJcbiAgICAgICAgICAgICdBbHQtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxyXG4gICAgICAgICAgICAnQ3RybC1kJzogaGFuZGxlRGVsZXRlLFxyXG4gICAgICAgICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxyXG4gICAgICAgICAgICAnQWx0LURlbGV0ZSc6IGhhbmRsZURlbGV0ZSxcclxuICAgICAgICAgICAgJ0FsdC1kJzogaGFuZGxlRGVsZXRlLFxyXG4gICAgICAgICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcclxuICAgICAgICAgICAgJ0N0cmwtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYWNLZXltYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwY0tleW1hcDtcclxuICAgIH0sXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gV2l0aCB0aGlzIHBsdWdpbiB3ZSBjaGVjayBpZiB0aGUgd2hvbGUgZG9jdW1lbnQgd2FzIHNlbGVjdGVkIGFuZCBkZWxldGVkLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXHJcbiAgICAgICAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byBQcm9zZU1pcnJvcidzIGBBbGxTZWxlY3Rpb25gLCB3aGljaCBkb2VzbuKAmXQgd29yayB3ZWxsXHJcbiAgICAgICAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cclxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsZWFyRG9jdW1lbnQnKSxcclxuICAgICAgICAgICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9jQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbi5hdFN0YXJ0KG9sZFN0YXRlLmRvYykuZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxFbmQgPSBTZWxlY3Rpb24uYXRFbmQob2xkU3RhdGUuZG9jKS50bztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbigwLCBuZXdTdGF0ZS5kb2MuY29udGVudC5zaXplLCAnICcsICcgJykubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tbWFuZHMgfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICd0YWJpbmRleCcsXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XHJcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXHJcbiAgICAgICAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG52YXIgZXh0ZW5zaW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIsXG4gIENvbW1hbmRzOiBDb21tYW5kcyxcbiAgRWRpdGFibGU6IEVkaXRhYmxlLFxuICBGb2N1c0V2ZW50czogRm9jdXNFdmVudHMsXG4gIEtleW1hcDogS2V5bWFwLFxuICBUYWJpbmRleDogVGFiaW5kZXhcbn0pO1xuXG5jb25zdCBzdHlsZSA9IGAuUHJvc2VNaXJyb3Ige1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Qcm9zZU1pcnJvciB7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogXCJsaWdhXCIgMDsgLyogdGhlIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIEVkZ2UgKi9cbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0gW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0ge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5Qcm9zZU1pcnJvciBwcmUge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbmltZy5Qcm9zZU1pcnJvci1zZXBhcmF0b3Ige1xuICBkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB3aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gIGhlaWdodDogMXB4ICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl0ge1xuICBvcGFjaXR5OiAwXG59YDtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIG5vbmNlLCBzdWZmaXgpIHtcclxuICAgIGNvbnN0IHRpcHRhcFN0eWxlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfV1gKTtcclxuICAgIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZztcclxuICAgIH1cclxuICAgIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICBpZiAobm9uY2UpIHtcclxuICAgICAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcclxuICAgIH1cclxuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJyk7XHJcbiAgICBzdHlsZU5vZGUuaW5uZXJIVE1MID0gc3R5bGU7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XHJcbiAgICByZXR1cm4gc3R5bGVOb2RlO1xyXG59XG5cbmNsYXNzIEVkaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25TdG9yYWdlID0ge307XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcclxuICAgICAgICAgICAgY29udGVudDogJycsXHJcbiAgICAgICAgICAgIGluamVjdENTUzogdHJ1ZSxcclxuICAgICAgICAgICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZXh0ZW5zaW9uczogW10sXHJcbiAgICAgICAgICAgIGF1dG9mb2N1czogZmFsc2UsXHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlZGl0b3JQcm9wczoge30sXHJcbiAgICAgICAgICAgIHBhcnNlT3B0aW9uczoge30sXHJcbiAgICAgICAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxyXG4gICAgICAgICAgICBvbkJlZm9yZUNyZWF0ZTogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25DcmVhdGU6ICgpID0+IG51bGwsXHJcbiAgICAgICAgICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxyXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25Gb2N1czogKCkgPT4gbnVsbCxcclxuICAgICAgICAgICAgb25CbHVyOiAoKSA9PiBudWxsLFxyXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVTY2hlbWEoKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmVDcmVhdGUnLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5pbmplY3RDU1MoKTtcclxuICAgICAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xyXG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSk7XHJcbiAgICAgICAgdGhpcy5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5vcHRpb25zLm9uU2VsZWN0aW9uVXBkYXRlKTtcclxuICAgICAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcclxuICAgICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKTtcclxuICAgICAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vcHRpb25zLm9uQmx1cik7XHJcbiAgICAgICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xyXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvY3VzKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0b3JhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxyXG4gICAgICovXHJcbiAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxyXG4gICAgICovXHJcbiAgICBjaGFpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXHJcbiAgICAgKi9cclxuICAgIGNhbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0IENTUyBzdHlsZXMuXHJcbiAgICAgKi9cclxuICAgIGluamVjdENTUygpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGVkaXRvciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHNldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXRoaXMudmlldyB8fCAhdGhpcy5zdGF0ZSB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgc2V0RWRpdGFibGUoZWRpdGFibGUsIGVtaXRVcGRhdGUgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSk7XHJcbiAgICAgICAgaWYgKGVtaXRVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGVkaXRvcjogdGhpcywgdHJhbnNhY3Rpb246IHRoaXMuc3RhdGUudHIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7XHJcbiAgICAgICAgLy8gc2luY2UgcGx1Z2lucyBhcmUgYXBwbGllZCBhZnRlciBjcmVhdGluZyB0aGUgdmlld1xyXG4gICAgICAgIC8vIGBlZGl0YWJsZWAgaXMgYWx3YXlzIGB0cnVlYCBmb3Igb25lIHRpY2suXHJcbiAgICAgICAgLy8gdGhhdOKAmXMgd2h5IHdlIGFsc28gaGF2ZSB0byBjaGVjayBmb3IgYG9wdGlvbnMuZWRpdGFibGVgXHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0YWJsZSAmJiB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVkaXRhYmxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgaGFuZGxlUGx1Z2lucykge1xyXG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpXHJcbiAgICAgICAgICAgID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKVxyXG4gICAgICAgICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl07XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KTtcclxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXkgVGhlIHBsdWdpbnMgbmFtZVxyXG4gICAgICovXHJcbiAgICB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLnN0YXRlLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xyXG4gICAgICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID8gT2JqZWN0LnZhbHVlcyhleHRlbnNpb25zKSA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnZXh0ZW5zaW9uJywgJ25vZGUnLCAnbWFyayddLmluY2x1ZGVzKGV4dGVuc2lvbiA9PT0gbnVsbCB8fCBleHRlbnNpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbi50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xyXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciBzY2hlbWEuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNjaGVtYSgpIHtcclxuICAgICAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVWaWV3KCkge1xyXG4gICAgICAgIGNvbnN0IGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCB0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xyXG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXHJcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gYGVkaXRvci52aWV3YCBpcyBub3QgeWV0IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuXHJcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXHJcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcclxuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vZGVWaWV3cygpO1xyXG4gICAgICAgIHRoaXMucHJlcGVuZENsYXNzKCk7XHJcbiAgICAgICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cclxuICAgICAgICAvLyBTbyB3ZeKAmWxsIGhhdmUgYWNjZXNzIHRvIGl0IGZvciB0ZXN0cy5cclxuICAgICAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tO1xyXG4gICAgICAgIGRvbS5lZGl0b3IgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFsbCBub2RlIHZpZXdzLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVOb2RlVmlld3MoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHtcclxuICAgICAgICAgICAgbm9kZVZpZXdzOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIubm9kZVZpZXdzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJlcGVuZENsYXNzKCkge1xyXG4gICAgICAgIHRoaXMudmlldy5kb20uY2xhc3NOYW1lID0gYHRpcHRhcCAke3RoaXMudmlldy5kb20uY2xhc3NOYW1lfWA7XHJcbiAgICB9XHJcbiAgICBjYXB0dXJlVHJhbnNhY3Rpb24oZm4pIHtcclxuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICAgICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdHI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXHJcbiAgICAgICAgLy8gdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBub3QgYmUgZGlzcGF0Y2hlZCBhcyB0aGVyZSBpcyBubyB2aWV3IGFueW1vcmUuXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0ZXAoc3RlcCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pO1xyXG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcclxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpO1xyXG4gICAgICAgIGNvbnN0IGJsdXIgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdibHVyJyk7XHJcbiAgICAgICAgaWYgKGZvY3VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibHVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYmx1cicsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudFVwZGF0ZScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7XHJcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxyXG4gICAgICovXHJcbiAgICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlcyh0aGlzLnN0YXRlLCBuYW1lT3JUeXBlKTtcclxuICAgIH1cclxuICAgIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbDtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlcztcclxuICAgICAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cclxuICAgICAqL1xyXG4gICAgZ2V0SlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cclxuICAgICAqL1xyXG4gICAgZ2V0SFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cclxuICAgICAqL1xyXG4gICAgZ2V0VGV4dChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xyXG4gICAgICAgICAgICBibG9ja1NlcGFyYXRvcixcclxuICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHRoaXMuc2NoZW1hKSxcclxuICAgICAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTm9kZUVtcHR5KHRoaXMuc3RhdGUuZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhcmFjdGVyQ291bnQoKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY1ZpZXcpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcclxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKTtcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xyXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tO1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2UudG87XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hTdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IG1hdGNoU3RhcnQgKyBtYXRjaFsxXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXHJcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXRjaFN0YXJ0LCBlbmQsIG5ld05vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnQoc3RhcnQgLSAxLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZSh0ci5tYXBwaW5nLm1hcChzdGFydCksIHRyLm1hcHBpbmcubWFwKGVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgY2hhbmdlcyB0aGUgdHlwZSBvZiBhIHRleHRibG9jayB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXHJcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cclxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKTtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XHJcbiAgICAgICAgICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgY29uZmlnLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0ZS50clxyXG4gICAgICAgICAgICAgICAgLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcclxuICAgICAgICAgICAgICAgIC5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxuXG4vKipcclxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcclxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb207XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxyXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxyXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXHJcbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxyXG4gKlxyXG4gKiBgdHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcclxuICogd3JhcHBlZCBub2RlLCB0aGUgcnVsZSB3aWxsIHRyeSB0byBqb2luIHRob3NlXHJcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxyXG4gKiByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWcpIHtcclxuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcclxuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcclxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBjaGFpbiwgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcclxuICAgICAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xyXG4gICAgICAgICAgICBjb25zdCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKTtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tSYW5nZSA9ICRzdGFydC5ibG9ja1JhbmdlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICBpZiAoIXdyYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKTtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBjb25maWcuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBjb25maWcudHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgY29uZmlnLnR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JyA/ICdsaXN0SXRlbScgOiAndGFza0xpc3QnO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tIC0gMSkubm9kZUJlZm9yZTtcclxuICAgICAgICAgICAgaWYgKGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXHJcbiAgICAgICAgICAgICAgICAmJiBjYW5Kb2luKHRyLmRvYywgcmFuZ2UuZnJvbSAtIDEpXHJcbiAgICAgICAgICAgICAgICAmJiAoIWNvbmZpZy5qb2luUHJlZGljYXRlIHx8IGNvbmZpZy5qb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKSkge1xyXG4gICAgICAgICAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuY2xhc3MgTWFyayB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXJrJztcclxuICAgICAgICB0aGlzLm5hbWUgPSAnbWFyayc7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcclxuICAgICAgICAgICAgLi4uY29uZmlnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcclxuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZE9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgICB9KSkgfHwge307XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXHJcbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcclxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTWFyayhleHRlbmRlZENvbmZpZyk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcclxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lO1xyXG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb247XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XHJcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xyXG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcclxuICAgICAgICBpZiAoaXNBdEVuZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc0luTWFyaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZU1hcmsgPSBjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92ZU1hcmspIHtcclxuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKTtcclxuICAgICAgICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnbm9kZSc7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uczoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXHJcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXHJcbiAgICAgICAgfSkpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZShjb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxyXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKTtcclxuICAgICAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XHJcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcclxuICAgIH1cclxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGUoZXh0ZW5kZWRDb25maWcpO1xyXG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XHJcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcclxuICAgICAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcclxuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcclxuICAgIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdBbmRyb2lkJyB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbn1cblxuY2xhc3MgTm9kZVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3RvcEV2ZW50OiBudWxsLFxyXG4gICAgICAgICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gcHJvcHMuZXh0ZW5zaW9uO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHByb3BzLm5vZGU7XHJcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zO1xyXG4gICAgICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xyXG4gICAgICAgIHRoaXMubW91bnQoKTtcclxuICAgIH1cclxuICAgIG1vdW50KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGdldCBkb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBvbkRyYWdTdGFydChldmVudCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcclxuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICAvLyBnZXQgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnRcclxuICAgICAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxyXG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDNcclxuICAgICAgICAgICAgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpO1xyXG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgKChfYiA9IHRoaXMuY29udGVudERPTSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRhaW5zKHRhcmdldCkpIHx8ICFkcmFnSGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcclxuICAgICAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gKF9jID0gZXZlbnQub2Zmc2V0WCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9kID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5vZmZzZXRYO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKF9lID0gZXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5vZmZzZXRZO1xyXG4gICAgICAgICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFg7XHJcbiAgICAgICAgICAgIHkgPSBoYW5kbGVCb3gueSAtIGRvbUJveC55ICsgb2Zmc2V0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9nID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc2V0RHJhZ0ltYWdlKHRoaXMuZG9tLCB4LCB5KTtcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHRlbGwgUHJvc2VNaXJyb3IgdGhhdCB3ZSB3YW50IHRvIG1vdmUgdGhlIHdob2xlIG5vZGVcclxuICAgICAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHRoaXMuZ2V0UG9zKCkpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcclxuICAgIH1cclxuICAgIHN0b3BFdmVudChldmVudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgISgoX2EgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyh0YXJnZXQpKTtcclxuICAgICAgICAvLyBhbnkgZXZlbnQgZnJvbSBjaGlsZCBub2RlcyBzaG91bGQgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgIGlmICghaXNJbkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgnZHJhZycpO1xyXG4gICAgICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnO1xyXG4gICAgICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xyXG4gICAgICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3I7XHJcbiAgICAgICAgY29uc3QgeyBpc0RyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZTtcclxuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2NvcHknO1xyXG4gICAgICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSc7XHJcbiAgICAgICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnO1xyXG4gICAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gICAgICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xyXG4gICAgICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcclxuICAgICAgICAvLyB0aGlzIGZpeCBwcmV2ZW50cyB0aGF0XHJcbiAgICAgICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcclxuICAgICAgICBpZiAoaXNEcmFnZ2luZ1xyXG4gICAgICAgICAgICB8fCBpc0Ryb3BFdmVudFxyXG4gICAgICAgICAgICB8fCBpc0NvcHlFdmVudFxyXG4gICAgICAgICAgICB8fCBpc1Bhc3RlRXZlbnRcclxuICAgICAgICAgICAgfHwgaXNDdXRFdmVudFxyXG4gICAgICAgICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcclxuICAgICAgICAvLyBhbmQgc2hvdWxkIGJlIGZ1bGx5IGhhbmRsZWQgYnkgdGhlIG5vZGUgdmlld1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmIHx8IHRoaXMubm9kZS5pc0F0b20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcclxuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcclxuICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2Fu4oCZdCBwcmV2ZW50RGlzcGF0Y2ggb24gZW50ZXJcclxuICAgICAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXHJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjUzNFxyXG4gICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpXHJcbiAgICAgICAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXHJcbiAgICAgICAgICAgICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKVxyXG4gICAgICAgICAgICAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xyXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSxcclxuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgLy8gd2XigJlsbCBjaGVjayBpZiBldmVyeSBjaGFuZ2VkIG5vZGUgaXMgY29udGVudEVkaXRhYmxlXHJcbiAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSB3aWxsIGFsbG93IG11dGF0aW9uIGNvbnRlbnRET00gd2l0aCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XHJcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcclxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlbGV0ZU5vZGUoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0UG9zKCk7XHJcbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxyXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXJrUGFzdGVSdWxlKGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xyXG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxyXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKTtcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIGxldCBtYXJrRW5kID0gcmFuZ2UudG87XHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xyXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxyXG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxufVxuXG4vKipcclxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXHJcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UgfSkge1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKTtcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb25maWcudHlwZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXHJcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cclxuICovXHJcbmZ1bmN0aW9uIHRleHRQYXN0ZVJ1bGUoY29uZmlnKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XHJcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXHJcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBzdGFydCArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcclxuICAgICAgICAgICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cblxuY2xhc3MgVHJhY2tlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBtYXAocG9zaXRpb24pIHtcclxuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwc1xyXG4gICAgICAgICAgICAuc2xpY2UodGhpcy5jdXJyZW50U3RlcClcclxuICAgICAgICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBSZXN1bHQucG9zO1xyXG4gICAgICAgIH0sIHBvc2l0aW9uKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXHJcbiAgICAgICAgICAgIGRlbGV0ZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBDb21tYW5kTWFuYWdlciwgRWRpdG9yLCBFeHRlbnNpb24sIElucHV0UnVsZSwgTWFyaywgTm9kZSwgTm9kZVZpZXcsIFBhc3RlUnVsZSwgVHJhY2tlciwgY2FsbE9yUmV0dXJuLCBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgY3JlYXRlQ2hhaW5hYmxlU3RhdGUsIGNyZWF0ZURvY3VtZW50LCBjcmVhdGVOb2RlRnJvbUNvbnRlbnQsIGNyZWF0ZVN0eWxlVGFnLCBkZWZhdWx0QmxvY2tBdCwgZGVsZXRlUHJvcHMsIGVsZW1lbnRGcm9tU3RyaW5nLCBlc2NhcGVGb3JSZWdFeCwgZXh0ZW5zaW9ucywgZmluZENoaWxkcmVuLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBmaW5kRHVwbGljYXRlcywgZmluZFBhcmVudE5vZGUsIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLCBmcm9tU3RyaW5nLCBnZW5lcmF0ZUhUTUwsIGdlbmVyYXRlSlNPTiwgZ2VuZXJhdGVUZXh0LCBnZXRBdHRyaWJ1dGVzLCBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMsIGdldENoYW5nZWRSYW5nZXMsIGdldERlYnVnSlNPTiwgZ2V0RXh0ZW5zaW9uRmllbGQsIGdldEhUTUxGcm9tRnJhZ21lbnQsIGdldE1hcmtBdHRyaWJ1dGVzLCBnZXRNYXJrUmFuZ2UsIGdldE1hcmtUeXBlLCBnZXRNYXJrc0JldHdlZW4sIGdldE5vZGVBdFBvc2l0aW9uLCBnZXROb2RlQXR0cmlidXRlcywgZ2V0Tm9kZVR5cGUsIGdldFJlbmRlcmVkQXR0cmlidXRlcywgZ2V0U2NoZW1hLCBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucywgZ2V0U2NoZW1hVHlwZUJ5TmFtZSwgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUsIGdldFNwbGl0dGVkQXR0cmlidXRlcywgZ2V0VGV4dCwgZ2V0VGV4dEJldHdlZW4sIGdldFRleHRDb250ZW50RnJvbU5vZGVzLCBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLCBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsIGlucHV0UnVsZXNQbHVnaW4sIGlzQWN0aXZlLCBpc0F0RW5kT2ZOb2RlLCBpc0F0U3RhcnRPZk5vZGUsIGlzRW1wdHlPYmplY3QsIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLCBpc0Z1bmN0aW9uLCBpc0xpc3QsIGlzTWFjT1MsIGlzTWFya0FjdGl2ZSwgaXNOb2RlQWN0aXZlLCBpc05vZGVFbXB0eSwgaXNOb2RlU2VsZWN0aW9uLCBpc051bWJlciwgaXNQbGFpbk9iamVjdCwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1RleHRTZWxlY3Rpb24sIGlzaU9TLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMsIG1lcmdlRGVlcCwgbWluTWF4LCBub2RlSW5wdXRSdWxlLCBub2RlUGFzdGVSdWxlLCBvYmplY3RJbmNsdWRlcywgcGFzdGVSdWxlc1BsdWdpbiwgcG9zVG9ET01SZWN0LCByZW1vdmVEdXBsaWNhdGVzLCByZXNvbHZlRm9jdXNQb3NpdGlvbiwgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQsIHNwbGl0RXh0ZW5zaW9ucywgdGV4dElucHV0UnVsZSwgdGV4dFBhc3RlUnVsZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ Blockquote),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst inputRegex = /^\\s*>\\s$/;\r\nconst Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'blockquote',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    content: 'block+',\r\n    group: 'block',\r\n    defining: true,\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'blockquote' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['blockquote', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setBlockquote: () => ({ commands }) => {\r\n                return commands.wrapIn(this.name);\r\n            },\r\n            toggleBlockquote: () => ({ commands }) => {\r\n                return commands.toggleWrap(this.name);\r\n            },\r\n            unsetBlockquote: () => ({ commands }) => {\r\n                return commands.lift(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\r\n                find: inputRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7O0FBRXhFO0FBQ0EsbUJBQW1CLDhDQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyw4QkFBOEIsNkRBQWU7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBLGFBQWE7QUFDYix1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBLGFBQWE7QUFDYixzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwrREFBaUI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUV3RDtBQUN6RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL2Rpc3QvaW5kZXguanM/YTFkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKj5cXHMkLztcclxuY29uc3QgQmxvY2txdW90ZSA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdibG9ja3F1b3RlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY29udGVudDogJ2Jsb2NrKycsXHJcbiAgICBncm91cDogJ2Jsb2NrJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgdGFnOiAnYmxvY2txdW90ZScgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnYmxvY2txdW90ZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQmxvY2txdW90ZSwgQmxvY2txdW90ZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst starInputRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))$/;\r\nconst starPasteRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))/g;\r\nconst underscoreInputRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))$/;\r\nconst underscorePasteRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))/g;\r\nconst Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'bold',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'strong',\r\n            },\r\n            {\r\n                tag: 'b',\r\n                getAttrs: node => node.style.fontWeight !== 'normal' && null,\r\n            },\r\n            {\r\n                style: 'font-weight',\r\n                getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['strong', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setBold: () => ({ commands }) => {\r\n                return commands.setMark(this.name);\r\n            },\r\n            toggleBold: () => ({ commands }) => {\r\n                return commands.toggleMark(this.name);\r\n            },\r\n            unsetBold: () => ({ commands }) => {\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-b': () => this.editor.commands.toggleBold(),\r\n            'Mod-B': () => this.editor.commands.toggleBold(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: starInputRegex,\r\n                type: this.type,\r\n            }),\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: underscoreInputRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n    addPasteRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: starPasteRegex,\r\n                type: this.type,\r\n            }),\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: underscorePasteRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3REFBd0QsR0FBRztBQUMzRCxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQywwQkFBMEIsNkRBQWU7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGFBQWE7QUFDYixpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGFBQWE7QUFDYixnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTRHO0FBQzdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz9kM2VmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCpcXCopKCg/OlteKl0rKSkoPzpcXCpcXCopKSQvO1xyXG5jb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XFwqXFwqKSgoPzpbXipdKykpKD86XFwqXFwqKSkvZztcclxuY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/Ol9fKSgoPzpbXl9fXSspKSg/Ol9fKSkkLztcclxuY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/Ol9fKSgoPzpbXl9fXSspKSg/Ol9fKSkvZztcclxuY29uc3QgQm9sZCA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdib2xkJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3N0cm9uZycsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2InLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gbm9kZS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0JyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUpICYmIG51bGwsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ3N0cm9uZycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnTW9kLWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXHJcbiAgICAgICAgICAgICdNb2QtQic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBCb2xkLCBCb2xkIGFzIGRlZmF1bHQsIHN0YXJJbnB1dFJlZ2V4LCBzdGFyUGFzdGVSZWdleCwgdW5kZXJzY29yZUlucHV0UmVnZXgsIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   BubbleMenuPlugin: () => (/* binding */ BubbleMenuPlugin),\n/* harmony export */   BubbleMenuView: () => (/* binding */ BubbleMenuView),\n/* harmony export */   \"default\": () => (/* binding */ BubbleMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass BubbleMenuView {\r\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow, }) {\r\n        this.preventHide = false;\r\n        this.shouldShow = ({ view, state, from, to, }) => {\r\n            const { doc, selection } = state;\r\n            const { empty } = selection;\r\n            // Sometime check for `empty` is not enough.\r\n            // Doubleclick an empty paragraph returns a node size of 2.\r\n            // So we check also for an empty text size.\r\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\r\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\r\n            // is called and the bubble menu item is focussed. In this case we should\r\n            // consider the menu as part of the editor and keep showing the menu\r\n            const isChildOfMenu = this.element.contains(document.activeElement);\r\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\r\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        this.mousedownHandler = () => {\r\n            this.preventHide = true;\r\n        };\r\n        this.dragstartHandler = () => {\r\n            this.hide();\r\n        };\r\n        this.focusHandler = () => {\r\n            // we use `setTimeout` to make sure `selection` is already updated\r\n            setTimeout(() => this.update(this.editor.view));\r\n        };\r\n        this.blurHandler = ({ event }) => {\r\n            var _a;\r\n            if (this.preventHide) {\r\n                this.preventHide = false;\r\n                return;\r\n            }\r\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\r\n                return;\r\n            }\r\n            this.hide();\r\n        };\r\n        this.tippyBlurHandler = (event) => {\r\n            this.blurHandler({ event });\r\n        };\r\n        this.handleDebouncedUpdate = (view, oldState) => {\r\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\r\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\r\n            if (!selectionChanged && !docChanged) {\r\n                return;\r\n            }\r\n            if (this.updateDebounceTimer) {\r\n                clearTimeout(this.updateDebounceTimer);\r\n            }\r\n            this.updateDebounceTimer = window.setTimeout(() => {\r\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\r\n            }, this.updateDelay);\r\n        };\r\n        this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\r\n            var _a, _b, _c;\r\n            const { state, composing } = view;\r\n            const { selection } = state;\r\n            const isSame = !selectionChanged && !docChanged;\r\n            if (composing || isSame) {\r\n                return;\r\n            }\r\n            this.createTooltip();\r\n            // support for CellSelections\r\n            const { ranges } = selection;\r\n            const from = Math.min(...ranges.map(range => range.$from.pos));\r\n            const to = Math.max(...ranges.map(range => range.$to.pos));\r\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\r\n                editor: this.editor,\r\n                view,\r\n                state,\r\n                oldState,\r\n                from,\r\n                to,\r\n            });\r\n            if (!shouldShow) {\r\n                this.hide();\r\n                return;\r\n            }\r\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\r\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect)\r\n                    || (() => {\r\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\r\n                            let node = view.nodeDOM(from);\r\n                            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\r\n                            if (nodeViewWrapper) {\r\n                                node = nodeViewWrapper.firstChild;\r\n                            }\r\n                            if (node) {\r\n                                return node.getBoundingClientRect();\r\n                            }\r\n                        }\r\n                        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\r\n                    }),\r\n            });\r\n            this.show();\r\n        };\r\n        this.editor = editor;\r\n        this.element = element;\r\n        this.view = view;\r\n        this.updateDelay = updateDelay;\r\n        if (shouldShow) {\r\n            this.shouldShow = shouldShow;\r\n        }\r\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\r\n        this.view.dom.addEventListener('dragstart', this.dragstartHandler);\r\n        this.editor.on('focus', this.focusHandler);\r\n        this.editor.on('blur', this.blurHandler);\r\n        this.tippyOptions = tippyOptions;\r\n        // Detaches menu content from its current parent\r\n        this.element.remove();\r\n        this.element.style.visibility = 'visible';\r\n    }\r\n    createTooltip() {\r\n        const { element: editorElement } = this.editor.options;\r\n        const editorIsAttached = !!editorElement.parentElement;\r\n        if (this.tippy || !editorIsAttached) {\r\n            return;\r\n        }\r\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\r\n            duration: 0,\r\n            getReferenceClientRect: null,\r\n            content: this.element,\r\n            interactive: true,\r\n            trigger: 'manual',\r\n            placement: 'top',\r\n            hideOnClick: 'toggle',\r\n            ...this.tippyOptions,\r\n        });\r\n        // maybe we have to hide tippy on its own blur event as well\r\n        if (this.tippy.popper.firstChild) {\r\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\r\n        }\r\n    }\r\n    update(view, oldState) {\r\n        const { state } = view;\r\n        const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;\r\n        if (this.updateDelay > 0 && hasValidSelection) {\r\n            this.handleDebouncedUpdate(view, oldState);\r\n            return;\r\n        }\r\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\r\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\r\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\r\n    }\r\n    show() {\r\n        var _a;\r\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\r\n    }\r\n    hide() {\r\n        var _a;\r\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\r\n    }\r\n    destroy() {\r\n        var _a, _b;\r\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\r\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\r\n        }\r\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\r\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\r\n        this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\r\n        this.editor.off('focus', this.focusHandler);\r\n        this.editor.off('blur', this.blurHandler);\r\n    }\r\n}\r\nconst BubbleMenuPlugin = (options) => {\r\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\r\n        view: view => new BubbleMenuView({ view, ...options }),\r\n    });\r\n};\n\nconst BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\r\n    name: 'bubbleMenu',\r\n    addOptions() {\r\n        return {\r\n            element: null,\r\n            tippyOptions: {},\r\n            pluginKey: 'bubbleMenu',\r\n            updateDelay: undefined,\r\n            shouldShow: null,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        if (!this.options.element) {\r\n            return [];\r\n        }\r\n        return [\r\n            BubbleMenuPlugin({\r\n                pluginKey: this.options.pluginKey,\r\n                editor: this.editor,\r\n                element: this.options.element,\r\n                tippyOptions: this.options.tippyOptions,\r\n                updateDelay: this.options.updateDelay,\r\n                shouldShow: this.options.shouldShow,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlGO0FBQ3BDO0FBQ3hCOztBQUU3QjtBQUNBLGtCQUFrQix3Q0FBd0Msa0NBQWtDO0FBQzVGO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRCxvQkFBb0IsaUJBQWlCO0FBQ3JDLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw2REFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQVk7QUFDM0MscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQU07QUFDckIseURBQXlELHVEQUFTO0FBQ2xFLDJDQUEyQyxrQkFBa0I7QUFDN0QsS0FBSztBQUNMOztBQUVBLG1CQUFtQixtREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFOEU7QUFDL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcz81ZDE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiwgaXNOb2RlU2VsZWN0aW9uLCBwb3NUb0RPTVJlY3QsIEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJztcblxuY2xhc3MgQnViYmxlTWVudVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSA9IDI1MCwgc2hvdWxkU2hvdywgfSkge1xyXG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSAoeyB2aWV3LCBzdGF0ZSwgZnJvbSwgdG8sIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cclxuICAgICAgICAgICAgLy8gRG91YmxlY2xpY2sgYW4gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgYSBub2RlIHNpemUgb2YgMi5cclxuICAgICAgICAgICAgLy8gU28gd2UgY2hlY2sgYWxzbyBmb3IgYW4gZW1wdHkgdGV4dCBzaXplLlxyXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGlzVGV4dFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcclxuICAgICAgICAgICAgLy8gaXMgY2FsbGVkIGFuZCB0aGUgYnViYmxlIG1lbnUgaXRlbSBpcyBmb2N1c3NlZC4gSW4gdGhpcyBjYXNlIHdlIHNob3VsZFxyXG4gICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgbWVudSBhcyBwYXJ0IG9mIHRoZSBlZGl0b3IgYW5kIGtlZXAgc2hvd2luZyB0aGUgbWVudVxyXG4gICAgICAgICAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51O1xyXG4gICAgICAgICAgICBpZiAoIWhhc0VkaXRvckZvY3VzIHx8IGVtcHR5IHx8IGlzRW1wdHlUZXh0QmxvY2sgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRyYWdzdGFydEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5mb2N1c0hhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmx1ckhhbmRsZXIgPSAoeyBldmVudCB9KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudEhpZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiAoKF9hID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudGlwcHlCbHVySGFuZGxlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJIYW5kbGVyKHsgZXZlbnQgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSA9ICh2aWV3LCBvbGRTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cGRhdGVEZWxheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIgPSAodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIGNvbXBvc2luZyB9ID0gdmlldztcclxuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgQ2VsbFNlbGVjdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3cgPSAoX2EgPSB0aGlzLnNob3VsZFNob3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICB2aWV3LFxyXG4gICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcclxuICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghc2hvdWxkU2hvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFByb3BzKHtcclxuICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgoX2MgPSB0aGlzLnRpcHB5T3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFJlZmVyZW5jZUNsaWVudFJlY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpZXcubm9kZURPTShmcm9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVmlld1dyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEZWxheSA9IHVwZGF0ZURlbGF5O1xyXG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XHJcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVG9vbHRpcCgpIHtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcclxuICAgICAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxyXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxyXG4gICAgICAgICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXHJcbiAgICAgICAgICAgIC4uLnRoaXMudGlwcHlPcHRpb25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIG1heWJlIHdlIGhhdmUgdG8gaGlkZSB0aXBweSBvbiBpdHMgb3duIGJsdXIgZXZlbnQgYXMgd2VsbFxyXG4gICAgICAgIGlmICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcclxuICAgICAgICBjb25zdCBoYXNWYWxpZFNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MgIT09IHN0YXRlLnNlbGVjdGlvbi4kdG8ucG9zO1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZURlbGF5ID4gMCAmJiBoYXNWYWxpZFNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xyXG4gICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgc2hvdygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3BwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2IgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcclxuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcclxuICAgICAgICBrZXk6IHR5cGVvZiBvcHRpb25zLnBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBuZXcgUGx1Z2luS2V5KG9wdGlvbnMucGx1Z2luS2V5KSA6IG9wdGlvbnMucGx1Z2luS2V5LFxyXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcclxuICAgIH0pO1xyXG59O1xuXG5jb25zdCBCdWJibGVNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnYnViYmxlTWVudScsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgIHRpcHB5T3B0aW9uczoge30sXHJcbiAgICAgICAgICAgIHBsdWdpbktleTogJ2J1YmJsZU1lbnUnLFxyXG4gICAgICAgICAgICB1cGRhdGVEZWxheTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBCdWJibGVNZW51UGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURlbGF5OiB0aGlzLm9wdGlvbnMudXBkYXRlRGVsYXksXHJcbiAgICAgICAgICAgICAgICBzaG91bGRTaG93OiB0aGlzLm9wdGlvbnMuc2hvdWxkU2hvdyxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBCdWJibGVNZW51LCBCdWJibGVNZW51UGx1Z2luLCBCdWJibGVNZW51VmlldywgQnViYmxlTWVudSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   \"default\": () => (/* binding */ BulletList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'listItem',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            bulletListTypeName: 'bulletList',\r\n            orderedListTypeName: 'orderedList',\r\n        };\r\n    },\r\n    content: 'paragraph block*',\r\n    defining: true,\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'li',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Enter: () => this.editor.commands.splitListItem(this.name),\r\n            Tab: () => this.editor.commands.sinkListItem(this.name),\r\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\r\n        };\r\n    },\r\n});\n\nconst TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'textStyle',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'span',\r\n                getAttrs: element => {\r\n                    const hasStyles = element.hasAttribute('style');\r\n                    if (!hasStyles) {\r\n                        return false;\r\n                    }\r\n                    return {};\r\n                },\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['span', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            removeEmptyTextStyle: () => ({ state, commands }) => {\r\n                const attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, this.type);\r\n                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);\r\n                if (hasStyles) {\r\n                    return true;\r\n                }\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n});\n\nconst inputRegex = /^\\s*([-+*])\\s$/;\r\nconst BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'bulletList',\r\n    addOptions() {\r\n        return {\r\n            itemTypeName: 'listItem',\r\n            HTMLAttributes: {},\r\n            keepMarks: false,\r\n            keepAttributes: false,\r\n        };\r\n    },\r\n    group: 'block list',\r\n    content() {\r\n        return `${this.options.itemTypeName}+`;\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'ul' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['ul', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            toggleBulletList: () => ({ commands, chain }) => {\r\n                if (this.options.keepAttributes) {\r\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\r\n                }\r\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\r\n            find: inputRegex,\r\n            type: this.type,\r\n        });\r\n        if (this.options.keepMarks || this.options.keepAttributes) {\r\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\r\n                find: inputRegex,\r\n                type: this.type,\r\n                keepMarks: this.options.keepMarks,\r\n                keepAttributes: this.options.keepAttributes,\r\n                getAttributes: () => { return this.editor.getAttributes(TextStyle.name); },\r\n                editor: this.editor,\r\n            });\r\n        }\r\n        return [\r\n            inputRule,\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlHOztBQUVqRyxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVELGtCQUFrQiw4Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsd0JBQXdCLDZEQUFlO0FBQ3ZDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxtQ0FBbUMsK0RBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBLG1CQUFtQiw4Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtREFBbUQ7QUFDMUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0Q7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcz9iNzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgTWFyaywgZ2V0TWFya0F0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnbGlzdEl0ZW0nLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxyXG4gICAgICAgICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxyXG4gICAgZGVmaW5pbmc6IHRydWUsXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnbGknLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gWydsaScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcclxuICAgICAgICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcclxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ3RleHRTdHlsZScsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1N0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ3NwYW4nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuc29tZSgoWywgdmFsdWVdKSA9PiAhIXZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmNvbnN0IGlucHV0UmVnZXggPSAvXlxccyooWy0rKl0pXFxzJC87XHJcbmNvbnN0IEJ1bGxldExpc3QgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnYnVsbGV0TGlzdCcsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICBrZWVwTWFya3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBncm91cDogJ2Jsb2NrIGxpc3QnLFxyXG4gICAgY29udGVudCgpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeyB0YWc6ICd1bCcgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsndWwnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW0ubmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkpLnJ1bigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2QtU2hpZnQtOCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJ1bGxldExpc3QoKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxyXG4gICAgICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHsgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpOyB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGlucHV0UnVsZSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEJ1bGxldExpc3QsIEJ1bGxldExpc3QgYXMgZGVmYXVsdCwgaW5wdXRSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-bullet-list/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ CodeBlock),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\nconst backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\r\nconst tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\r\nconst CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\r\n    name: 'codeBlock',\r\n    addOptions() {\r\n        return {\r\n            languageClassPrefix: 'language-',\r\n            exitOnTripleEnter: true,\r\n            exitOnArrowDown: true,\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    content: 'text*',\r\n    marks: '',\r\n    group: 'block',\r\n    code: true,\r\n    defining: true,\r\n    addAttributes() {\r\n        return {\r\n            language: {\r\n                default: null,\r\n                parseHTML: element => {\r\n                    var _a;\r\n                    const { languageClassPrefix } = this.options;\r\n                    const classNames = [...(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || [])];\r\n                    const languages = classNames\r\n                        .filter(className => className.startsWith(languageClassPrefix))\r\n                        .map(className => className.replace(languageClassPrefix, ''));\r\n                    const language = languages[0];\r\n                    if (!language) {\r\n                        return null;\r\n                    }\r\n                    return language;\r\n                },\r\n                rendered: false,\r\n            },\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'pre',\r\n                preserveWhitespace: 'full',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ node, HTMLAttributes }) {\r\n        return [\r\n            'pre',\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\r\n            [\r\n                'code',\r\n                {\r\n                    class: node.attrs.language\r\n                        ? this.options.languageClassPrefix + node.attrs.language\r\n                        : null,\r\n                },\r\n                0,\r\n            ],\r\n        ];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setCodeBlock: attributes => ({ commands }) => {\r\n                return commands.setNode(this.name, attributes);\r\n            },\r\n            toggleCodeBlock: attributes => ({ commands }) => {\r\n                return commands.toggleNode(this.name, 'paragraph', attributes);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\r\n            // remove code block when at start of document or code block is empty\r\n            Backspace: () => {\r\n                const { empty, $anchor } = this.editor.state.selection;\r\n                const isAtStart = $anchor.pos === 1;\r\n                if (!empty || $anchor.parent.type.name !== this.name) {\r\n                    return false;\r\n                }\r\n                if (isAtStart || !$anchor.parent.textContent.length) {\r\n                    return this.editor.commands.clearNodes();\r\n                }\r\n                return false;\r\n            },\r\n            // exit node on triple enter\r\n            Enter: ({ editor }) => {\r\n                if (!this.options.exitOnTripleEnter) {\r\n                    return false;\r\n                }\r\n                const { state } = editor;\r\n                const { selection } = state;\r\n                const { $from, empty } = selection;\r\n                if (!empty || $from.parent.type !== this.type) {\r\n                    return false;\r\n                }\r\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\r\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n');\r\n                if (!isAtEnd || !endsWithDoubleNewline) {\r\n                    return false;\r\n                }\r\n                return editor\r\n                    .chain()\r\n                    .command(({ tr }) => {\r\n                    tr.delete($from.pos - 2, $from.pos);\r\n                    return true;\r\n                })\r\n                    .exitCode()\r\n                    .run();\r\n            },\r\n            // exit node on arrow down\r\n            ArrowDown: ({ editor }) => {\r\n                if (!this.options.exitOnArrowDown) {\r\n                    return false;\r\n                }\r\n                const { state } = editor;\r\n                const { selection, doc } = state;\r\n                const { $from, empty } = selection;\r\n                if (!empty || $from.parent.type !== this.type) {\r\n                    return false;\r\n                }\r\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\r\n                if (!isAtEnd) {\r\n                    return false;\r\n                }\r\n                const after = $from.after();\r\n                if (after === undefined) {\r\n                    return false;\r\n                }\r\n                const nodeAfter = doc.nodeAt(after);\r\n                if (nodeAfter) {\r\n                    return false;\r\n                }\r\n                return editor.commands.exitCode();\r\n            },\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\r\n                find: backtickInputRegex,\r\n                type: this.type,\r\n                getAttributes: match => ({\r\n                    language: match[1],\r\n                }),\r\n            }),\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\r\n                find: tildeInputRegex,\r\n                type: this.type,\r\n                getAttributes: match => ({\r\n                    language: match[1],\r\n                }),\r\n            }),\r\n        ];\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            // this plugin creates a code block for pasted content from VS Code\r\n            // we can also detect the copied code language\r\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('codeBlockVSCodeHandler'),\r\n                props: {\r\n                    handlePaste: (view, event) => {\r\n                        if (!event.clipboardData) {\r\n                            return false;\r\n                        }\r\n                        // don’t create a new code block within code blocks\r\n                        if (this.editor.isActive(this.type.name)) {\r\n                            return false;\r\n                        }\r\n                        const text = event.clipboardData.getData('text/plain');\r\n                        const vscode = event.clipboardData.getData('vscode-editor-data');\r\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\r\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\r\n                        if (!text || !language) {\r\n                            return false;\r\n                        }\r\n                        const { tr } = view.state;\r\n                        // create an empty code block\r\n                        tr.replaceSelectionWith(this.type.create({ language }));\r\n                        // put cursor inside the newly created code block\r\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\r\n                        // add text to code block\r\n                        // strip carriage return chars from text pasted as code\r\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\r\n                        tr.insertText(text.replace(/\\r\\n?/g, '\\n'));\r\n                        // store meta information\r\n                        // this is useful for other plugins that depends on the paste event\r\n                        // like the paste rule plugin\r\n                        tr.setMeta('paste', true);\r\n                        view.dispatch(tr);\r\n                        return true;\r\n                    },\r\n                },\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RTtBQUNUOztBQUVwRTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxZQUFZLDZEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksb0VBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixZQUFZLG9FQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQU07QUFDdEIseUJBQXlCLHVEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBLHdDQUF3QywyREFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRStFO0FBQ2hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2svZGlzdC9pbmRleC5qcz9iMDVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuXG5jb25zdCBiYWNrdGlja0lucHV0UmVnZXggPSAvXmBgYChbYS16XSspP1tcXHNcXG5dJC87XHJcbmNvbnN0IHRpbGRlSW5wdXRSZWdleCA9IC9efn5+KFthLXpdKyk/W1xcc1xcbl0kLztcclxuY29uc3QgQ29kZUJsb2NrID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2NvZGVCbG9jaycsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6ICdsYW5ndWFnZS0nLFxyXG4gICAgICAgICAgICBleGl0T25UcmlwbGVFbnRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgZXhpdE9uQXJyb3dEb3duOiB0cnVlLFxyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb250ZW50OiAndGV4dConLFxyXG4gICAgbWFya3M6ICcnLFxyXG4gICAgZ3JvdXA6ICdibG9jaycsXHJcbiAgICBjb2RlOiB0cnVlLFxyXG4gICAgZGVmaW5pbmc6IHRydWUsXHJcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxhbmd1YWdlOiB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsYW5ndWFnZUNsYXNzUHJlZml4IH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oKChfYSA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QpIHx8IFtdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChsYW5ndWFnZUNsYXNzUHJlZml4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnJlcGxhY2UobGFuZ3VhZ2VDbGFzc1ByZWZpeCwgJycpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3ByZScsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ3ByZScsXHJcbiAgICAgICAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2NvZGUnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBub2RlLmF0dHJzLmxhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlQ2xhc3NQcmVmaXggKyBub2RlLmF0dHJzLmxhbmd1YWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0Q29kZUJsb2NrOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZUNvZGVCbG9jazogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2QtQWx0LWMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlQmxvY2soKSxcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNvZGUgYmxvY2sgd2hlbiBhdCBzdGFydCBvZiBkb2N1bWVudCBvciBjb2RlIGJsb2NrIGlzIGVtcHR5XHJcbiAgICAgICAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gJGFuY2hvci5wb3MgPT09IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXRTdGFydCB8fCAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZXhpdCBub2RlIG9uIHRyaXBsZSBlbnRlclxyXG4gICAgICAgICAgICBFbnRlcjogKHsgZWRpdG9yIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPblRyaXBsZUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRzV2l0aERvdWJsZU5ld2xpbmUgPSAkZnJvbS5wYXJlbnQudGV4dENvbnRlbnQuZW5kc1dpdGgoJ1xcblxcbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcclxuICAgICAgICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5leGl0Q29kZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxyXG4gICAgICAgICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25BcnJvd0Rvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5hZnRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBkb2Mubm9kZUF0KGFmdGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogYmFja3RpY2tJbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy8gdGhpcyBwbHVnaW4gY3JlYXRlcyBhIGNvZGUgYmxvY2sgZm9yIHBhc3RlZCBjb250ZW50IGZyb20gVlMgQ29kZVxyXG4gICAgICAgICAgICAvLyB3ZSBjYW4gYWxzbyBkZXRlY3QgdGhlIGNvcGllZCBjb2RlIGxhbmd1YWdlXHJcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjb2RlQmxvY2tWU0NvZGVIYW5kbGVyJyksXHJcbiAgICAgICAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9u4oCZdCBjcmVhdGUgYSBuZXcgY29kZSBibG9jayB3aXRoaW4gY29kZSBibG9ja3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzQWN0aXZlKHRoaXMudHlwZS5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnNjb2RlID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd2c2NvZGUtZWRpdG9yLWRhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnNjb2RlRGF0YSA9IHZzY29kZSA/IEpTT04ucGFyc2UodnNjb2RlKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB2c2NvZGVEYXRhID09PSBudWxsIHx8IHZzY29kZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZzY29kZURhdGEubW9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0IHx8ICFsYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHZpZXcuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb2RlIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRoaXMudHlwZS5jcmVhdGUoeyBsYW5ndWFnZSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCB0ci5zZWxlY3Rpb24uZnJvbSAtIDIpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGV4dCB0byBjb2RlIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGNhcnJpYWdlIHJldHVybiBjaGFycyBmcm9tIHRleHQgcGFzdGVkIGFzIGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itdmlldy9jb21taXQvYTUwYTZiY2NlYjRjZTUyYWM4ZmNjNjE2MjQ4OGQ4ODc1NjEzYWFjZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBtZXRhIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGFzdGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlrZSB0aGUgcGFzdGUgcnVsZSBwbHVnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncGFzdGUnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IENvZGVCbG9jaywgYmFja3RpY2tJbnB1dFJlZ2V4LCBDb2RlQmxvY2sgYXMgZGVmYXVsdCwgdGlsZGVJbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst inputRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))$/;\r\nconst pasteRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))/g;\r\nconst Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'code',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    excludes: '_',\r\n    code: true,\r\n    exitable: true,\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'code' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['code', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setCode: () => ({ commands }) => {\r\n                return commands.setMark(this.name);\r\n            },\r\n            toggleCode: () => ({ commands }) => {\r\n                return commands.toggleMark(this.name);\r\n            },\r\n            unsetCode: () => ({ commands }) => {\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-e': () => this.editor.commands.toggleCode(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: inputRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n    addPasteRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: pasteRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GOztBQUVuRjtBQUNBO0FBQ0EsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHdCQUF3Qiw2REFBZTtBQUN2QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUV3RDtBQUN6RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL2Rpc3QvaW5kZXguanM/NDE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpgKSgoPzpbXmBdKykpKD86YCkpJC87XHJcbmNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OmApKCg/OlteYF0rKSkoPzpgKSkvZztcclxuY29uc3QgQ29kZSA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdjb2RlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZXhjbHVkZXM6ICdfJyxcclxuICAgIGNvZGU6IHRydWUsXHJcbiAgICBleGl0YWJsZTogdHJ1ZSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7IHRhZzogJ2NvZGUnIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgQ29kZSwgQ29kZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'doc',\r\n    topNode: true,\r\n    content: 'block+',\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7O0FBRXBDLGlCQUFpQiw4Q0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV3QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9kaXN0L2luZGV4LmpzP2Q4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2RvYycsXHJcbiAgICB0b3BOb2RlOiB0cnVlLFxyXG4gICAgY29udGVudDogJ2Jsb2NrKycsXHJcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudCwgRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   \"default\": () => (/* binding */ Dropcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"./node_modules/@tiptap/pm/dropcursor/dist/index.js\");\n\n\n\nconst Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\r\n    name: 'dropCursor',\r\n    addOptions() {\r\n        return {\r\n            color: 'currentColor',\r\n            width: 1,\r\n            class: undefined,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDVTs7QUFFbkQsbUJBQW1CLG1EQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGlFQUFVO0FBQ3RCO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTRDO0FBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcz83NTllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJztcblxuY29uc3QgRHJvcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2Ryb3BDdXJzb3InLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2xvcjogJ2N1cnJlbnRDb2xvcicsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgICAgICBjbGFzczogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGRyb3BDdXJzb3IodGhpcy5vcHRpb25zKSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IERyb3BjdXJzb3IsIERyb3BjdXJzb3IgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-dropcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   FloatingMenuPlugin: () => (/* binding */ FloatingMenuPlugin),\n/* harmony export */   FloatingMenuView: () => (/* binding */ FloatingMenuView),\n/* harmony export */   \"default\": () => (/* binding */ FloatingMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tippy.js */ \"./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass FloatingMenuView {\r\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow, }) {\r\n        this.preventHide = false;\r\n        this.shouldShow = ({ view, state }) => {\r\n            const { selection } = state;\r\n            const { $anchor, empty } = selection;\r\n            const isRootDepth = $anchor.depth === 1;\r\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;\r\n            if (!view.hasFocus()\r\n                || !empty\r\n                || !isRootDepth\r\n                || !isEmptyTextBlock\r\n                || !this.editor.isEditable) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        this.mousedownHandler = () => {\r\n            this.preventHide = true;\r\n        };\r\n        this.focusHandler = () => {\r\n            // we use `setTimeout` to make sure `selection` is already updated\r\n            setTimeout(() => this.update(this.editor.view));\r\n        };\r\n        this.blurHandler = ({ event }) => {\r\n            var _a;\r\n            if (this.preventHide) {\r\n                this.preventHide = false;\r\n                return;\r\n            }\r\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\r\n                return;\r\n            }\r\n            this.hide();\r\n        };\r\n        this.tippyBlurHandler = (event) => {\r\n            this.blurHandler({ event });\r\n        };\r\n        this.editor = editor;\r\n        this.element = element;\r\n        this.view = view;\r\n        if (shouldShow) {\r\n            this.shouldShow = shouldShow;\r\n        }\r\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\r\n        this.editor.on('focus', this.focusHandler);\r\n        this.editor.on('blur', this.blurHandler);\r\n        this.tippyOptions = tippyOptions;\r\n        // Detaches menu content from its current parent\r\n        this.element.remove();\r\n        this.element.style.visibility = 'visible';\r\n    }\r\n    createTooltip() {\r\n        const { element: editorElement } = this.editor.options;\r\n        const editorIsAttached = !!editorElement.parentElement;\r\n        if (this.tippy || !editorIsAttached) {\r\n            return;\r\n        }\r\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(editorElement, {\r\n            duration: 0,\r\n            getReferenceClientRect: null,\r\n            content: this.element,\r\n            interactive: true,\r\n            trigger: 'manual',\r\n            placement: 'right',\r\n            hideOnClick: 'toggle',\r\n            ...this.tippyOptions,\r\n        });\r\n        // maybe we have to hide tippy on its own blur event as well\r\n        if (this.tippy.popper.firstChild) {\r\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\r\n        }\r\n    }\r\n    update(view, oldState) {\r\n        var _a, _b, _c;\r\n        const { state } = view;\r\n        const { doc, selection } = state;\r\n        const { from, to } = selection;\r\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\r\n        if (isSame) {\r\n            return;\r\n        }\r\n        this.createTooltip();\r\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\r\n            editor: this.editor,\r\n            view,\r\n            state,\r\n            oldState,\r\n        });\r\n        if (!shouldShow) {\r\n            this.hide();\r\n            return;\r\n        }\r\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\r\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect)(view, from, to)),\r\n        });\r\n        this.show();\r\n    }\r\n    show() {\r\n        var _a;\r\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\r\n    }\r\n    hide() {\r\n        var _a;\r\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\r\n    }\r\n    destroy() {\r\n        var _a, _b;\r\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\r\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\r\n        }\r\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\r\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\r\n        this.editor.off('focus', this.focusHandler);\r\n        this.editor.off('blur', this.blurHandler);\r\n    }\r\n}\r\nconst FloatingMenuPlugin = (options) => {\r\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\r\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\r\n        view: view => new FloatingMenuView({ view, ...options }),\r\n    });\r\n};\n\nconst FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension.create({\r\n    name: 'floatingMenu',\r\n    addOptions() {\r\n        return {\r\n            element: null,\r\n            tippyOptions: {},\r\n            pluginKey: 'floatingMenu',\r\n            shouldShow: null,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        if (!this.options.element) {\r\n            return [];\r\n        }\r\n        return [\r\n            FloatingMenuPlugin({\r\n                pluginKey: this.options.pluginKey,\r\n                editor: this.editor,\r\n                element: this.options.element,\r\n                tippyOptions: this.options.tippyOptions,\r\n                shouldShow: this.options.shouldShow,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDRjtBQUN4Qjs7QUFFN0I7QUFDQSxrQkFBa0Isd0NBQXdDLGVBQWU7QUFDekU7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQyxvQkFBb0IsWUFBWTtBQUNoQyxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksMERBQVk7QUFDcEosU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQU07QUFDckIseURBQXlELHVEQUFTO0FBQ2xFLDZDQUE2QyxrQkFBa0I7QUFDL0QsS0FBSztBQUNMOztBQUVBLHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVzRjtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51L2Rpc3QvaW5kZXguanM/NjVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb3NUb0RPTVJlY3QsIEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJztcblxuY2xhc3MgRmxvYXRpbmdNZW51VmlldyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IGVkaXRvciwgZWxlbWVudCwgdmlldywgdGlwcHlPcHRpb25zID0ge30sIHNob3VsZFNob3csIH0pIHtcclxuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgJGFuY2hvciwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgaXNSb290RGVwdGggPSAkYW5jaG9yLmRlcHRoID09PSAxO1xyXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gJGFuY2hvci5wYXJlbnQuaXNUZXh0YmxvY2sgJiYgISRhbmNob3IucGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgaWYgKCF2aWV3Lmhhc0ZvY3VzKClcclxuICAgICAgICAgICAgICAgIHx8ICFlbXB0eVxyXG4gICAgICAgICAgICAgICAgfHwgIWlzUm9vdERlcHRoXHJcbiAgICAgICAgICAgICAgICB8fCAhaXNFbXB0eVRleHRCbG9ja1xyXG4gICAgICAgICAgICAgICAgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZvY3VzSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2ZW50SGlkZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50aXBweUJsdXJIYW5kbGVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICBpZiAoc2hvdWxkU2hvdykge1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XHJcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVG9vbHRpcCgpIHtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcclxuICAgICAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxyXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXHJcbiAgICAgICAgICAgIGhpZGVPbkNsaWNrOiAndG9nZ2xlJyxcclxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbWF5YmUgd2UgaGF2ZSB0byBoaWRlIHRpcHB5IG9uIGl0cyBvd24gYmx1ciBldmVudCBhcyB3ZWxsXHJcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodmlldywgb2xkU3RhdGUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3O1xyXG4gICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcclxuICAgICAgICBjb25zdCBpc1NhbWUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5kb2MuZXEoZG9jKSAmJiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcclxuICAgICAgICBpZiAoaXNTYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKCk7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkU2hvdyA9IChfYSA9IHRoaXMuc2hvdWxkU2hvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xyXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICAgICB2aWV3LFxyXG4gICAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgICAgb2xkU3RhdGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFzaG91bGRTaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XHJcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgoX2MgPSB0aGlzLnRpcHB5T3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFJlZmVyZW5jZUNsaWVudFJlY3QpIHx8ICgoKSA9PiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93KCk7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBGbG9hdGluZ01lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xyXG4gICAgICAgIGtleTogdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBQbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXHJcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgRmxvYXRpbmdNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgRmxvYXRpbmdNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAnZmxvYXRpbmdNZW51JyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcclxuICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB7fSxcclxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnZmxvYXRpbmdNZW51JyxcclxuICAgICAgICAgICAgc2hvdWxkU2hvdzogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgRmxvYXRpbmdNZW51UGx1Z2luKHtcclxuICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcclxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEZsb2F0aW5nTWVudSwgRmxvYXRpbmdNZW51UGx1Z2luLCBGbG9hdGluZ01lbnVWaWV3LCBGbG9hdGluZ01lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-floating-menu/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n\nconst Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\r\n    name: 'gapCursor',\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)(),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        var _a;\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\r\n        };\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwRTtBQUN6Qjs7QUFFakQsa0JBQWtCLG1EQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVM7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBWSxDQUFDLCtEQUFpQjtBQUNoRTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUUwQztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz8yNzUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiwgY2FsbE9yUmV0dXJuLCBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2dhcGN1cnNvcic7XG5cbmNvbnN0IEdhcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2dhcEN1cnNvcicsXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZ2FwQ3Vyc29yKCksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcclxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWxsb3dHYXBDdXJzb3I6IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEdhcGN1cnNvciwgR2FwY3Vyc29yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-gapcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ HardBreak)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'hardBreak',\r\n    addOptions() {\r\n        return {\r\n            keepMarks: true,\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    inline: true,\r\n    group: 'inline',\r\n    selectable: false,\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'br' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['br', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\r\n    },\r\n    renderText() {\r\n        return '\\n';\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setHardBreak: () => ({ commands, chain, state, editor, }) => {\r\n                return commands.first([\r\n                    () => commands.exitCode(),\r\n                    () => commands.command(() => {\r\n                        const { selection, storedMarks } = state;\r\n                        if (selection.$from.parent.type.spec.isolating) {\r\n                            return false;\r\n                        }\r\n                        const { keepMarks } = this.options;\r\n                        const { splittableMarks } = editor.extensionManager;\r\n                        const marks = storedMarks\r\n                            || (selection.$to.parentOffset && selection.$from.marks());\r\n                        return chain()\r\n                            .insertContent({ type: this.name })\r\n                            .command(({ tr, dispatch }) => {\r\n                            if (dispatch && marks && keepMarks) {\r\n                                const filteredMarks = marks\r\n                                    .filter(mark => splittableMarks.includes(mark.type.name));\r\n                                tr.ensureMarks(filteredMarks);\r\n                            }\r\n                            return true;\r\n                        })\r\n                            .run();\r\n                    }),\r\n                ]);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Enter': () => this.editor.commands.setHardBreak(),\r\n            'Shift-Enter': () => this.editor.commands.setHardBreak(),\r\n        };\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDs7QUFFckQsa0JBQWtCLDhDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QyxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFMEM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzPzM0NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2hhcmRCcmVhaycsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtlZXBNYXJrczogdHJ1ZSxcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgaW5saW5lOiB0cnVlLFxyXG4gICAgZ3JvdXA6ICdpbmxpbmUnLFxyXG4gICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgeyB0YWc6ICdicicgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnYnInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xyXG4gICAgfSxcclxuICAgIHJlbmRlclRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuICdcXG4nO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluLCBzdGF0ZSwgZWRpdG9yLCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xyXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcclxuICAgICAgICAgICAgJ1NoaWZ0LUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBIYXJkQnJlYWssIEhhcmRCcmVhayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ Heading)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'heading',\r\n    addOptions() {\r\n        return {\r\n            levels: [1, 2, 3, 4, 5, 6],\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    content: 'inline*',\r\n    group: 'block',\r\n    defining: true,\r\n    addAttributes() {\r\n        return {\r\n            level: {\r\n                default: 1,\r\n                rendered: false,\r\n            },\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return this.options.levels\r\n            .map((level) => ({\r\n            tag: `h${level}`,\r\n            attrs: { level },\r\n        }));\r\n    },\r\n    renderHTML({ node, HTMLAttributes }) {\r\n        const hasLevel = this.options.levels.includes(node.attrs.level);\r\n        const level = hasLevel\r\n            ? node.attrs.level\r\n            : this.options.levels[0];\r\n        return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setHeading: attributes => ({ commands }) => {\r\n                if (!this.options.levels.includes(attributes.level)) {\r\n                    return false;\r\n                }\r\n                return commands.setNode(this.name, attributes);\r\n            },\r\n            toggleHeading: attributes => ({ commands }) => {\r\n                if (!this.options.levels.includes(attributes.level)) {\r\n                    return false;\r\n                }\r\n                return commands.toggleNode(this.name, 'paragraph', attributes);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return this.options.levels.reduce((items, level) => ({\r\n            ...items,\r\n            ...{\r\n                [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\r\n            },\r\n        }), {});\r\n    },\r\n    addInputRules() {\r\n        return this.options.levels.map(level => {\r\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\r\n                find: new RegExp(`^(#{1,${level}})\\\\s$`),\r\n                type: this.type,\r\n                getAttributes: {\r\n                    level,\r\n                },\r\n            });\r\n        });\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTs7QUFFN0UsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IscUJBQXFCLE9BQU87QUFDNUIsU0FBUztBQUNULEtBQUs7QUFDTCxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU0sR0FBRyw2REFBZTtBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sK0NBQStDLE9BQU87QUFDeEYsYUFBYTtBQUNiLFNBQVMsS0FBSztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFzQjtBQUN6QyxzQ0FBc0MsSUFBSSxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVzQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nL2Rpc3QvaW5kZXguanM/YWFmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBIZWFkaW5nID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2hlYWRpbmcnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZXZlbHM6IFsxLCAyLCAzLCA0LCA1LCA2XSxcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY29udGVudDogJ2lubGluZSonLFxyXG4gICAgZ3JvdXA6ICdibG9jaycsXHJcbiAgICBkZWZpbmluZzogdHJ1ZSxcclxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGV2ZWw6IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHNcclxuICAgICAgICAgICAgLm1hcCgobGV2ZWwpID0+ICh7XHJcbiAgICAgICAgICAgIHRhZzogYGgke2xldmVsfWAsXHJcbiAgICAgICAgICAgIGF0dHJzOiB7IGxldmVsIH0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgY29uc3QgaGFzTGV2ZWwgPSB0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKG5vZGUuYXR0cnMubGV2ZWwpO1xyXG4gICAgICAgIGNvbnN0IGxldmVsID0gaGFzTGV2ZWxcclxuICAgICAgICAgICAgPyBub2RlLmF0dHJzLmxldmVsXHJcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmxldmVsc1swXTtcclxuICAgICAgICByZXR1cm4gW2BoJHtsZXZlbH1gLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdG9nZ2xlSGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZSgoaXRlbXMsIGxldmVsKSA9PiAoe1xyXG4gICAgICAgICAgICAuLi5pdGVtcyxcclxuICAgICAgICAgICAgLi4ue1xyXG4gICAgICAgICAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSwge30pO1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKGxldmVsID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjezEsJHtsZXZlbH19KVxcXFxzJGApLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgSGVhZGluZywgSGVhZGluZyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n\nconst History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\r\n    name: 'history',\r\n    addOptions() {\r\n        return {\r\n            depth: 100,\r\n            newGroupDelay: 500,\r\n        };\r\n    },\r\n    addCommands() {\r\n        return {\r\n            undo: () => ({ state, dispatch }) => {\r\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\r\n            },\r\n            redo: () => ({ state, dispatch }) => {\r\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\r\n            },\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options),\r\n        ];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-z': () => this.editor.commands.undo(),\r\n            'Mod-Z': () => this.editor.commands.undo(),\r\n            'Mod-y': () => this.editor.commands.redo(),\r\n            'Mod-Y': () => this.editor.commands.redo(),\r\n            'Shift-Mod-z': () => this.editor.commands.redo(),\r\n            'Shift-Mod-Z': () => this.editor.commands.redo(),\r\n            // Russian keyboard layouts\r\n            'Mod-я': () => this.editor.commands.undo(),\r\n            'Shift-Mod-я': () => this.editor.commands.redo(),\r\n        };\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDZ0I7O0FBRXpELGdCQUFnQixtREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsdUJBQXVCLHdEQUFJO0FBQzNCLGFBQWE7QUFDYiwyQkFBMkIsaUJBQWlCO0FBQzVDLHVCQUF1Qix3REFBSTtBQUMzQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQU87QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRXNDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnkvZGlzdC9pbmRleC5qcz8xNmRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5IH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5JztcblxuY29uc3QgSGlzdG9yeSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2hpc3RvcnknLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZXB0aDogMTAwLFxyXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDAsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1bmRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVkbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWRvKHN0YXRlLCBkaXNwYXRjaCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgaGlzdG9yeSh0aGlzLm9wdGlvbnMpLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxyXG4gICAgICAgICAgICAnTW9kLVonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXHJcbiAgICAgICAgICAgICdNb2QteSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcclxuICAgICAgICAgICAgJ01vZC1ZJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxyXG4gICAgICAgICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXHJcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtWic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcclxuICAgICAgICAgICAgLy8gUnVzc2lhbiBrZXlib2FyZCBsYXlvdXRzXHJcbiAgICAgICAgICAgICdNb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXHJcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5leHBvcnQgeyBIaXN0b3J5LCBIaXN0b3J5IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-history/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ HorizontalRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\nconst HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\r\n    name: 'horizontalRule',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [{ tag: 'hr' }];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['hr', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setHorizontalRule: () => ({ chain, state }) => {\r\n                const { $to: $originTo } = state.selection;\r\n                const currentChain = chain();\r\n                if ($originTo.parentOffset === 0) {\r\n                    currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });\r\n                }\r\n                else {\r\n                    currentChain.insertContent({ type: this.name });\r\n                }\r\n                return (currentChain\r\n                    // set cursor after horizontal rule\r\n                    .command(({ tr, dispatch }) => {\r\n                    var _a;\r\n                    if (dispatch) {\r\n                        const { $to } = tr.selection;\r\n                        const posAfter = $to.end();\r\n                        if ($to.nodeAfter) {\r\n                            if ($to.nodeAfter.isTextblock) {\r\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\r\n                            }\r\n                            else if ($to.nodeAfter.isBlock) {\r\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\r\n                            }\r\n                            else {\r\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // add node after horizontal rule if it’s the end of the document\r\n                            const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\r\n                            if (node) {\r\n                                tr.insert(posAfter, node);\r\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\r\n                            }\r\n                        }\r\n                        tr.scrollIntoView();\r\n                    }\r\n                    return true;\r\n                })\r\n                    .run());\r\n            },\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\r\n                find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRTtBQUNKOztBQUVoRSx1QkFBdUIsOENBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxtRkFBbUYsaUJBQWlCO0FBQ3BHO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkRBQWE7QUFDN0Q7QUFDQTtBQUNBLGdEQUFnRCwyREFBYTtBQUM3RDtBQUNBO0FBQ0EsZ0RBQWdELDJEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVvRDtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvZGlzdC9pbmRleC5qcz80ZTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgbm9kZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbmNvbnN0IEhvcml6b250YWxSdWxlID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2hvcml6b250YWxSdWxlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ3JvdXA6ICdibG9jaycsXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt7IHRhZzogJ2hyJyB9XTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2hyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRIb3Jpem9udGFsUnVsZTogKCkgPT4gKHsgY2hhaW4sIHN0YXRlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgJHRvOiAkb3JpZ2luVG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJG9yaWdpblRvLnBhcmVudE9mZnNldCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50QXQoTWF0aC5tYXgoJG9yaWdpblRvLnBvcyAtIDIsIDApLCB7IHR5cGU6IHRoaXMubmFtZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50Q2hhaW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yIGFmdGVyIGhvcml6b250YWwgcnVsZVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7ICR0byB9ID0gdHIuc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyLmlzVGV4dGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcyArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCR0by5ub2RlQWZ0ZXIuaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBub2RlIGFmdGVyIGhvcml6b250YWwgcnVsZSBpZiBpdOKAmXMgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAoX2EgPSAkdG8ucGFyZW50LnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydChwb3NBZnRlciwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zQWZ0ZXIgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5vZGVJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogL14oPzotLS184oCULXxfX19cXHN8XFwqXFwqXFwqXFxzKSQvLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEhvcml6b250YWxSdWxlLCBIb3Jpem9udGFsUnVsZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst starInputRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))$/;\r\nconst starPasteRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))/g;\r\nconst underscoreInputRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))$/;\r\nconst underscorePasteRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))/g;\r\nconst Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'italic',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'em',\r\n            },\r\n            {\r\n                tag: 'i',\r\n                getAttrs: node => node.style.fontStyle !== 'normal' && null,\r\n            },\r\n            {\r\n                style: 'font-style=italic',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['em', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setItalic: () => ({ commands }) => {\r\n                return commands.setMark(this.name);\r\n            },\r\n            toggleItalic: () => ({ commands }) => {\r\n                return commands.toggleMark(this.name);\r\n            },\r\n            unsetItalic: () => ({ commands }) => {\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-i': () => this.editor.commands.toggleItalic(),\r\n            'Mod-I': () => this.editor.commands.toggleItalic(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: starInputRegex,\r\n                type: this.type,\r\n            }),\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: underscoreInputRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n    addPasteRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: starPasteRegex,\r\n                type: this.type,\r\n            }),\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: underscorePasteRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHNCQUFzQiw2REFBZTtBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsYUFBYTtBQUNiLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0EsYUFBYTtBQUNiLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFZ0g7QUFDakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanM/NmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBzdGFySW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86XFwqKSgoPzpbXipdKykpKD86XFwqKSkkLztcclxuY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKikoKD86W14qXSspKSg/OlxcKikpL2c7XHJcbmNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfKSgoPzpbXl9dKykpKD86XykpJC87XHJcbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfKSgoPzpbXl9dKykpKD86XykpL2c7XHJcbmNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdpdGFsaWMnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAnZW0nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdpJyxcclxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBub2RlID0+IG5vZGUuc3R5bGUuZm9udFN0eWxlICE9PSAnbm9ybWFsJyAmJiBudWxsLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9aXRhbGljJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnZW0nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZENvbW1hbmRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1pJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXHJcbiAgICAgICAgICAgICdNb2QtSSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XHJcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IEl0YWxpYywgSXRhbGljIGFzIGRlZmF1bHQsIHN0YXJJbnB1dFJlZ2V4LCBzdGFyUGFzdGVSZWdleCwgdW5kZXJzY29yZUlucHV0UmVnZXgsIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   \"default\": () => (/* binding */ ListItem)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'listItem',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            bulletListTypeName: 'bulletList',\r\n            orderedListTypeName: 'orderedList',\r\n        };\r\n    },\r\n    content: 'paragraph block*',\r\n    defining: true,\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'li',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Enter: () => this.editor.commands.splitListItem(this.name),\r\n            Tab: () => this.editor.commands.sinkListItem(this.name),\r\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\r\n        };\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEOztBQUVyRCxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUV3QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vZGlzdC9pbmRleC5qcz81MjVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ2xpc3RJdGVtJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcclxuICAgICAgICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcclxuICAgIGRlZmluaW5nOiB0cnVlLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2xpJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-list-item/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ OrderedList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'listItem',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            bulletListTypeName: 'bulletList',\r\n            orderedListTypeName: 'orderedList',\r\n        };\r\n    },\r\n    content: 'paragraph block*',\r\n    defining: true,\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'li',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Enter: () => this.editor.commands.splitListItem(this.name),\r\n            Tab: () => this.editor.commands.sinkListItem(this.name),\r\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\r\n        };\r\n    },\r\n});\n\nconst TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'textStyle',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'span',\r\n                getAttrs: element => {\r\n                    const hasStyles = element.hasAttribute('style');\r\n                    if (!hasStyles) {\r\n                        return false;\r\n                    }\r\n                    return {};\r\n                },\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['span', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            removeEmptyTextStyle: () => ({ state, commands }) => {\r\n                const attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, this.type);\r\n                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);\r\n                if (hasStyles) {\r\n                    return true;\r\n                }\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n});\n\nconst inputRegex = /^(\\d+)\\.\\s$/;\r\nconst OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'orderedList',\r\n    addOptions() {\r\n        return {\r\n            itemTypeName: 'listItem',\r\n            HTMLAttributes: {},\r\n            keepMarks: false,\r\n            keepAttributes: false,\r\n        };\r\n    },\r\n    group: 'block list',\r\n    content() {\r\n        return `${this.options.itemTypeName}+`;\r\n    },\r\n    addAttributes() {\r\n        return {\r\n            start: {\r\n                default: 1,\r\n                parseHTML: element => {\r\n                    return element.hasAttribute('start')\r\n                        ? parseInt(element.getAttribute('start') || '', 10)\r\n                        : 1;\r\n                },\r\n            },\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 'ol',\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\r\n        return start === 1\r\n            ? ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0]\r\n            : ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            toggleOrderedList: () => ({ commands, chain }) => {\r\n                if (this.options.keepAttributes) {\r\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\r\n                }\r\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\r\n        };\r\n    },\r\n    addInputRules() {\r\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\r\n            find: inputRegex,\r\n            type: this.type,\r\n            getAttributes: match => ({ start: +match[1] }),\r\n            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\r\n        });\r\n        if (this.options.keepMarks || this.options.keepAttributes) {\r\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\r\n                find: inputRegex,\r\n                type: this.type,\r\n                keepMarks: this.options.keepMarks,\r\n                keepAttributes: this.options.keepAttributes,\r\n                getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyle.name) }),\r\n                joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\r\n                editor: this.editor,\r\n            });\r\n        }\r\n        return [\r\n            inputRule,\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRzs7QUFFakcsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLDZEQUFlO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRCxrQkFBa0IsOENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHdCQUF3Qiw2REFBZTtBQUN2QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsbUNBQW1DLCtEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQSxvQkFBb0IsOENBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQSxxQkFBcUIsNkRBQWU7QUFDcEMscUJBQXFCLDZEQUFlO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QiwrREFBaUI7QUFDekM7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsK0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdFQUFnRTtBQUMzRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTBEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdC9kaXN0L2luZGV4LmpzP2UyYzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCBNYXJrLCBnZXRNYXJrQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdsaXN0SXRlbScsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXHJcbiAgICAgICAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXHJcbiAgICBkZWZpbmluZzogdHJ1ZSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdsaScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxyXG4gICAgICAgICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxyXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xuXG5jb25zdCBUZXh0U3R5bGUgPSBNYXJrLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAndGV4dFN0eWxlJyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1N0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuY29uc3QgaW5wdXRSZWdleCA9IC9eKFxcZCspXFwuXFxzJC87XHJcbmNvbnN0IE9yZGVyZWRMaXN0ID0gTm9kZS5jcmVhdGUoe1xyXG4gICAgbmFtZTogJ29yZGVyZWRMaXN0JyxcclxuICAgIGFkZE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgIGtlZXBNYXJrczogZmFsc2UsXHJcbiAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdyb3VwOiAnYmxvY2sgbGlzdCcsXHJcbiAgICBjb250ZW50KCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xyXG4gICAgfSxcclxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEsXHJcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3RhcnQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdGFydCcpIHx8ICcnLCAxMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHBhcnNlSFRNTCgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6ICdvbCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzO1xyXG4gICAgICAgIHJldHVybiBzdGFydCA9PT0gMVxyXG4gICAgICAgICAgICA/IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0KSwgMF1cclxuICAgICAgICAgICAgOiBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbS5uYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSkucnVuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1TaGlmdC03JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlT3JkZXJlZExpc3QoKSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZElucHV0UnVsZXMoKSB7XHJcbiAgICAgICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxyXG4gICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxyXG4gICAgICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xyXG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcclxuICAgICAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoeyBzdGFydDogK21hdGNoWzFdLCAuLi50aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSB9KSxcclxuICAgICAgICAgICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGlucHV0UnVsZSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IE9yZGVyZWRMaXN0LCBPcmRlcmVkTGlzdCBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-ordered-list/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ Paragraph)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'paragraph',\r\n    priority: 1000,\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    group: 'block',\r\n    content: 'inline*',\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'p' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['p', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setParagraph: () => ({ commands }) => {\r\n                return commands.setNode(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-Alt-0': () => this.editor.commands.setParagraph(),\r\n        };\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEOztBQUVyRCxrQkFBa0IsOENBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxxQkFBcUIsNkRBQWU7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUUwQztBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvZGlzdC9pbmRleC5qcz8xNzhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdwYXJhZ3JhcGgnLFxyXG4gICAgcHJpb3JpdHk6IDEwMDAsXHJcbiAgICBhZGRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdyb3VwOiAnYmxvY2snLFxyXG4gICAgY29udGVudDogJ2lubGluZSonLFxyXG4gICAgcGFyc2VIVE1MKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgdGFnOiAncCcgfSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XHJcbiAgICB9LFxyXG4gICAgYWRkQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ01vZC1BbHQtMCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgUGFyYWdyYXBoLCBQYXJhZ3JhcGggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst inputRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))$/;\r\nconst pasteRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))/g;\r\nconst Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\r\n    name: 'strike',\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n        };\r\n    },\r\n    parseHTML() {\r\n        return [\r\n            {\r\n                tag: 's',\r\n            },\r\n            {\r\n                tag: 'del',\r\n            },\r\n            {\r\n                tag: 'strike',\r\n            },\r\n            {\r\n                style: 'text-decoration',\r\n                consuming: false,\r\n                getAttrs: style => (style.includes('line-through') ? {} : false),\r\n            },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['s', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            setStrike: () => ({ commands }) => {\r\n                return commands.setMark(this.name);\r\n            },\r\n            toggleStrike: () => ({ commands }) => {\r\n                return commands.toggleMark(this.name);\r\n            },\r\n            unsetStrike: () => ({ commands }) => {\r\n                return commands.unsetMark(this.name);\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        const shortcuts = {};\r\n        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isMacOS)()) {\r\n            shortcuts['Mod-Shift-s'] = () => this.editor.commands.toggleStrike();\r\n        }\r\n        else {\r\n            shortcuts['Ctrl-Shift-s'] = () => this.editor.commands.toggleStrike();\r\n        }\r\n        return shortcuts;\r\n    },\r\n    addInputRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\r\n                find: inputRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n    addPasteRules() {\r\n        return [\r\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\r\n                find: pasteRegex,\r\n                type: this.type,\r\n            }),\r\n        ];\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEY7O0FBRTVGO0FBQ0E7QUFDQSxlQUFlLDhDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHFCQUFxQiw2REFBZTtBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsYUFBYTtBQUNiLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0EsYUFBYTtBQUNiLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEQ7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanM/MWIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIGlzTWFjT1MsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzp+fikoKD86W15+XSspKSg/On5+KSkkLztcclxuY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86fn4pKCg/Oltefl0rKSkoPzp+fikpL2c7XHJcbmNvbnN0IFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcclxuICAgIG5hbWU6ICdzdHJpa2UnLFxyXG4gICAgYWRkT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwYXJzZUhUTUwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFnOiAncycsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ2RlbCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhZzogJ3N0cmlrZScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dC1kZWNvcmF0aW9uJyxcclxuICAgICAgICAgICAgICAgIGNvbnN1bWluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKHN0eWxlLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKSA/IHt9IDogZmFsc2UpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcclxuICAgICAgICByZXR1cm4gWydzJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcclxuICAgIH0sXHJcbiAgICBhZGRDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xyXG4gICAgICAgIGNvbnN0IHNob3J0Y3V0cyA9IHt9O1xyXG4gICAgICAgIGlmIChpc01hY09TKCkpIHtcclxuICAgICAgICAgICAgc2hvcnRjdXRzWydNb2QtU2hpZnQtcyddID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzaG9ydGN1dHNbJ0N0cmwtU2hpZnQtcyddID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaG9ydGN1dHM7XHJcbiAgICB9LFxyXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcclxuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG59KTtcblxuZXhwb3J0IHsgU3RyaWtlLCBTdHJpa2UgYXMgZGVmYXVsdCwgaW5wdXRSZWdleCwgcGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\r\n    name: 'text',\r\n    group: 'inline',\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQzs7QUFFcEMsYUFBYSw4Q0FBSTtBQUNqQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFZ0M7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzPzQ0YjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XHJcbiAgICBuYW1lOiAndGV4dCcsXHJcbiAgICBncm91cDogJ2lubGluZScsXHJcbn0pO1xuXG5leHBvcnQgeyBUZXh0LCBUZXh0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3FDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vY29tbWFuZHMvZGlzdC9pbmRleC5qcz85NjVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/commands/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUN1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Ryb3BjdXJzb3IvZGlzdC9pbmRleC5qcz8zNDU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRyb3BjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/dropcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2dhcGN1cnNvci9kaXN0L2luZGV4LmpzPzkzMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/gapcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ29DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vaGlzdG9yeS9kaXN0L2luZGV4LmpzPzg1M2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGlzdG9yeS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWhpc3RvcnlcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/history/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2tleW1hcC9kaXN0L2luZGV4LmpzP2Y5M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/keymap/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzPzA0MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/model/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5qcz9lZTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjaGVtYS1saXN0L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itc2NoZW1hLWxpc3RcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/schema-list/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3N0YXRlL2Rpc3QvaW5kZXguanM/NzgyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/state/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS90cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vdHJhbnNmb3JtL2Rpc3QvaW5kZXguanM/NDY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc2Zvcm0vaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/transform/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard),\n/* harmony export */   __serializeForClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ2lDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vdmlldy9kaXN0L2luZGV4LmpzPzk5OTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmlldy9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/pm/view/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ StarterKit)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"./node_modules/@tiptap/extension-bullet-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"./node_modules/@tiptap/extension-list-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"./node_modules/@tiptap/extension-ordered-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"./node_modules/@tiptap/extension-text/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\r\n    name: 'starterKit',\r\n    addExtensions() {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\r\n        const extensions = [];\r\n        if (this.options.blockquote !== false) {\r\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));\r\n        }\r\n        if (this.options.bold !== false) {\r\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));\r\n        }\r\n        if (this.options.bulletList !== false) {\r\n            extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));\r\n        }\r\n        if (this.options.code !== false) {\r\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));\r\n        }\r\n        if (this.options.codeBlock !== false) {\r\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));\r\n        }\r\n        if (this.options.document !== false) {\r\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));\r\n        }\r\n        if (this.options.dropcursor !== false) {\r\n            extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));\r\n        }\r\n        if (this.options.gapcursor !== false) {\r\n            extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));\r\n        }\r\n        if (this.options.hardBreak !== false) {\r\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));\r\n        }\r\n        if (this.options.heading !== false) {\r\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));\r\n        }\r\n        if (this.options.history !== false) {\r\n            extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));\r\n        }\r\n        if (this.options.horizontalRule !== false) {\r\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));\r\n        }\r\n        if (this.options.italic !== false) {\r\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));\r\n        }\r\n        if (this.options.listItem !== false) {\r\n            extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));\r\n        }\r\n        if (this.options.orderedList !== false) {\r\n            extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));\r\n        }\r\n        if (this.options.paragraph !== false) {\r\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));\r\n        }\r\n        if (this.options.strike !== false) {\r\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));\r\n        }\r\n        if (this.options.text !== false) {\r\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));\r\n        }\r\n        return extensions;\r\n    },\r\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNpQjtBQUNaO0FBQ2E7QUFDYjtBQUNXO0FBQ0g7QUFDSTtBQUNGO0FBQ0M7QUFDTDtBQUNBO0FBQ2U7QUFDakI7QUFDSztBQUNNO0FBQ0w7QUFDTjtBQUNKOztBQUU5QyxtQkFBbUIsb0RBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvRUFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLHdEQUFJO0FBQ2hDO0FBQ0E7QUFDQSw0QkFBNEIscUVBQVU7QUFDdEM7QUFDQTtBQUNBLDRCQUE0Qix3REFBSTtBQUNoQztBQUNBO0FBQ0EsNEJBQTRCLG1FQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQVE7QUFDcEM7QUFDQTtBQUNBLDRCQUE0QixvRUFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLGtFQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQVM7QUFDckM7QUFDQTtBQUNBLDRCQUE0Qiw4REFBTztBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLCtEQUFPO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIsOEVBQWM7QUFDMUM7QUFDQTtBQUNBLDRCQUE0Qiw2REFBTTtBQUNsQztBQUNBO0FBQ0EsNEJBQTRCLGtFQUFRO0FBQ3BDO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQVc7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixtRUFBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLDZEQUFNO0FBQ2xDO0FBQ0E7QUFDQSw0QkFBNEIseURBQUk7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUU0QztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanM/M2I5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgQmxvY2txdW90ZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUnO1xuaW1wb3J0IHsgQm9sZCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQnO1xuaW1wb3J0IHsgQnVsbGV0TGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0JztcbmltcG9ydCB7IENvZGUgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1jb2RlJztcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2snO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudCc7XG5pbXBvcnQgeyBEcm9wY3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvcic7XG5pbXBvcnQgeyBHYXBjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3InO1xuaW1wb3J0IHsgSGFyZEJyZWFrIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhayc7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGVhZGluZyc7XG5pbXBvcnQgeyBIaXN0b3J5IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeSc7XG5pbXBvcnQgeyBIb3Jpem9udGFsUnVsZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZSc7XG5pbXBvcnQgeyBJdGFsaWMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMnO1xuaW1wb3J0IHsgTGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0nO1xuaW1wb3J0IHsgT3JkZXJlZExpc3QgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3QnO1xuaW1wb3J0IHsgUGFyYWdyYXBoIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoJztcbmltcG9ydCB7IFN0cmlrZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZSc7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dCc7XG5cbmNvbnN0IFN0YXJ0ZXJLaXQgPSBFeHRlbnNpb24uY3JlYXRlKHtcclxuICAgIG5hbWU6ICdzdGFydGVyS2l0JyxcclxuICAgIGFkZEV4dGVuc2lvbnMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3Q7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJsb2NrcXVvdGUuY29uZmlndXJlKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsb2NrcXVvdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQm9sZC5jb25maWd1cmUoKF9iID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYm9sZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChCdWxsZXRMaXN0LmNvbmZpZ3VyZSgoX2MgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5idWxsZXRMaXN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKChfZCA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNvZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlQmxvY2sgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlQmxvY2suY29uZmlndXJlKChfZSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNvZGVCbG9jaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goRG9jdW1lbnQuY29uZmlndXJlKChfZiA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRvY3VtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGN1cnNvciAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKChfZyA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmRyb3BjdXJzb3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChHYXBjdXJzb3IuY29uZmlndXJlKChfaCA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmdhcGN1cnNvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhhcmRCcmVhay5jb25maWd1cmUoKF9qID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouaGFyZEJyZWFrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKChfayA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmhlYWRpbmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaXN0b3J5ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGlzdG9yeS5jb25maWd1cmUoKF9sID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuaGlzdG9yeSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSG9yaXpvbnRhbFJ1bGUuY29uZmlndXJlKChfbSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmhvcml6b250YWxSdWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXRhbGljICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSgoX28gPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5pdGFsaWMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXN0SXRlbSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSgoX3AgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC5saXN0SXRlbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goT3JkZXJlZExpc3QuY29uZmlndXJlKChfcSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLm9yZGVyZWRMaXN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWdyYXBoICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSgoX3IgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfci5wYXJhZ3JhcGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpa2UgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChTdHJpa2UuY29uZmlndXJlKChfcyA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zLnN0cmlrZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChUZXh0LmNvbmZpZ3VyZSgoX3QgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdC50ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25zO1xyXG4gICAgfSxcclxufSk7XG5cbmV4cG9ydCB7IFN0YXJ0ZXJLaXQsIFN0YXJ0ZXJLaXQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@tiptap/vue-2/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/vue-2/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension),\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.PasteRule),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Tracker),\n/* harmony export */   VueNodeViewRenderer: () => (/* binding */ VueNodeViewRenderer),\n/* harmony export */   VueRenderer: () => (/* binding */ VueRenderer),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.callOrReturn),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.createDocument),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isActive),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodePasteRule),\n/* harmony export */   nodeViewProps: () => (/* binding */ nodeViewProps),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.resolveFocusPosition),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var vue_ts_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-ts-types */ \"./node_modules/vue-ts-types/dist/index.js\");\n\n\n\n\n\n\n\nconst BubbleMenu = {\r\n    name: 'BubbleMenu',\r\n    props: {\r\n        pluginKey: {\r\n            type: [String, Object],\r\n            default: 'bubbleMenu',\r\n        },\r\n        editor: {\r\n            type: Object,\r\n            required: true,\r\n        },\r\n        updateDelay: {\r\n            type: Number,\r\n        },\r\n        tippyOptions: {\r\n            type: Object,\r\n            default: () => ({}),\r\n        },\r\n        shouldShow: {\r\n            type: Function,\r\n            default: null,\r\n        },\r\n    },\r\n    watch: {\r\n        editor: {\r\n            immediate: true,\r\n            handler(editor) {\r\n                if (!editor) {\r\n                    return;\r\n                }\r\n                this.$nextTick(() => {\r\n                    editor.registerPlugin((0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_2__.BubbleMenuPlugin)({\r\n                        updateDelay: this.updateDelay,\r\n                        editor,\r\n                        element: this.$el,\r\n                        pluginKey: this.pluginKey,\r\n                        shouldShow: this.shouldShow,\r\n                        tippyOptions: this.tippyOptions,\r\n                    }));\r\n                });\r\n            },\r\n        },\r\n    },\r\n    render(createElement) {\r\n        return createElement('div', { style: { visibility: 'hidden' } }, this.$slots.default);\r\n    },\r\n    beforeDestroy() {\r\n        this.editor.unregisterPlugin(this.pluginKey);\r\n    },\r\n};\n\nclass Editor extends _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Editor {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.contentComponent = null;\r\n    }\r\n}\n\nconst EditorContent = {\r\n    name: 'EditorContent',\r\n    props: {\r\n        editor: {\r\n            default: null,\r\n            type: Object,\r\n        },\r\n    },\r\n    watch: {\r\n        editor: {\r\n            immediate: true,\r\n            handler(editor) {\r\n                if (editor && editor.options.element) {\r\n                    this.$nextTick(() => {\r\n                        const element = this.$el;\r\n                        if (!element || !editor.options.element.firstChild) {\r\n                            return;\r\n                        }\r\n                        element.append(...editor.options.element.childNodes);\r\n                        editor.contentComponent = this;\r\n                        editor.setOptions({\r\n                            element,\r\n                        });\r\n                        editor.createNodeViews();\r\n                    });\r\n                }\r\n            },\r\n        },\r\n    },\r\n    render(createElement) {\r\n        return createElement('div');\r\n    },\r\n    beforeDestroy() {\r\n        const { editor } = this;\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        if (!editor.isDestroyed) {\r\n            editor.view.setProps({\r\n                nodeViews: {},\r\n            });\r\n        }\r\n        editor.contentComponent = null;\r\n        if (!editor.options.element.firstChild) {\r\n            return;\r\n        }\r\n        const newElement = document.createElement('div');\r\n        newElement.append(...editor.options.element.childNodes);\r\n        editor.setOptions({\r\n            element: newElement,\r\n        });\r\n    },\r\n};\n\nconst FloatingMenu = {\r\n    name: 'FloatingMenu',\r\n    props: {\r\n        pluginKey: {\r\n            type: [String, Object],\r\n            default: 'floatingMenu',\r\n        },\r\n        editor: {\r\n            type: Object,\r\n            required: true,\r\n        },\r\n        tippyOptions: {\r\n            type: Object,\r\n            default: () => ({}),\r\n        },\r\n        shouldShow: {\r\n            type: Function,\r\n            default: null,\r\n        },\r\n    },\r\n    watch: {\r\n        editor: {\r\n            immediate: true,\r\n            handler(editor) {\r\n                if (!editor) {\r\n                    return;\r\n                }\r\n                this.$nextTick(() => {\r\n                    editor.registerPlugin((0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_3__.FloatingMenuPlugin)({\r\n                        pluginKey: this.pluginKey,\r\n                        editor,\r\n                        element: this.$el,\r\n                        tippyOptions: this.tippyOptions,\r\n                        shouldShow: this.shouldShow,\r\n                    }));\r\n                });\r\n            },\r\n        },\r\n    },\r\n    render(createElement) {\r\n        return createElement('div', { style: { visibility: 'hidden' } }, this.$slots.default);\r\n    },\r\n    beforeDestroy() {\r\n        this.editor.unregisterPlugin(this.pluginKey);\r\n    },\r\n};\n\nconst NodeViewContent = {\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: 'div',\r\n        },\r\n    },\r\n    render(createElement) {\r\n        return createElement(this.as, {\r\n            style: {\r\n                whiteSpace: 'pre-wrap',\r\n            },\r\n            attrs: {\r\n                'data-node-view-content': '',\r\n            },\r\n        });\r\n    },\r\n};\n\nconst NodeViewWrapper = {\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: 'div',\r\n        },\r\n    },\r\n    inject: ['onDragStart', 'decorationClasses'],\r\n    render(createElement) {\r\n        return createElement(this.as, {\r\n            class: this.decorationClasses.value,\r\n            style: {\r\n                whiteSpace: 'normal',\r\n            },\r\n            attrs: {\r\n                'data-node-view-wrapper': '',\r\n            },\r\n            on: {\r\n                dragstart: this.onDragStart,\r\n            },\r\n        }, this.$slots.default);\r\n    },\r\n};\n\nclass VueRenderer {\r\n    constructor(component, props) {\r\n        const Component = (typeof component === 'function') ? component : vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"].extend(component);\r\n        this.ref = new Component(props).$mount();\r\n    }\r\n    get element() {\r\n        return this.ref.$el;\r\n    }\r\n    updateProps(props = {}) {\r\n        var _a, _b, _c;\r\n        if (!this.ref.$props) {\r\n            return;\r\n        }\r\n        // prevents `Avoid mutating a prop directly` error message\r\n        // Fix: `VueNodeViewRenderer` change vue Constructor `config.silent` not working\r\n        const currentVueConstructor = (_c = (_b = (_a = this.ref.$props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.$options._base) !== null && _c !== void 0 ? _c : vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; // eslint-disable-line\r\n        const originalSilent = currentVueConstructor.config.silent;\r\n        currentVueConstructor.config.silent = true;\r\n        Object\r\n            .entries(props)\r\n            .forEach(([key, value]) => {\r\n            this.ref.$props[key] = value;\r\n        });\r\n        currentVueConstructor.config.silent = originalSilent;\r\n    }\r\n    destroy() {\r\n        this.ref.$destroy();\r\n    }\r\n}\n\nconst nodeViewProps = {\r\n    editor: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.objectProp)().required,\r\n    node: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.objectProp)().required,\r\n    decorations: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.objectProp)().required,\r\n    selected: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.booleanProp)().required,\r\n    extension: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.objectProp)().required,\r\n    getPos: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.functionProp)().required,\r\n    updateAttributes: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.functionProp)().required,\r\n    deleteNode: (0,vue_ts_types__WEBPACK_IMPORTED_MODULE_1__.functionProp)().required,\r\n};\r\nclass VueNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.NodeView {\r\n    mount() {\r\n        var _a, _b;\r\n        const props = {\r\n            editor: this.editor,\r\n            node: this.node,\r\n            decorations: this.decorations,\r\n            selected: false,\r\n            extension: this.extension,\r\n            getPos: () => this.getPos(),\r\n            updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\r\n            deleteNode: () => this.deleteNode(),\r\n        };\r\n        const onDragStart = this.onDragStart.bind(this);\r\n        this.decorationClasses = vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"].observable({\r\n            value: this.getDecorationClasses(),\r\n        });\r\n        // @ts-ignore\r\n        const vue = (_b = (_a = this.editor.contentComponent) === null || _a === void 0 ? void 0 : _a.$options._base) !== null && _b !== void 0 ? _b : vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; // eslint-disable-line\r\n        const Component = vue.extend(this.component).extend({\r\n            props: Object.keys(props),\r\n            provide: () => {\r\n                return {\r\n                    onDragStart,\r\n                    decorationClasses: this.decorationClasses,\r\n                };\r\n            },\r\n        });\r\n        this.renderer = new VueRenderer(Component, {\r\n            parent: this.editor.contentComponent,\r\n            propsData: props,\r\n        });\r\n    }\r\n    get dom() {\r\n        if (!this.renderer.element.hasAttribute('data-node-view-wrapper')) {\r\n            throw Error('Please use the NodeViewWrapper component for your node view.');\r\n        }\r\n        return this.renderer.element;\r\n    }\r\n    get contentDOM() {\r\n        if (this.node.isLeaf) {\r\n            return null;\r\n        }\r\n        const contentElement = this.dom.querySelector('[data-node-view-content]');\r\n        return (contentElement || this.dom);\r\n    }\r\n    update(node, decorations) {\r\n        const updateProps = (props) => {\r\n            this.decorationClasses.value = this.getDecorationClasses();\r\n            this.renderer.updateProps(props);\r\n        };\r\n        if (typeof this.options.update === 'function') {\r\n            const oldNode = this.node;\r\n            const oldDecorations = this.decorations;\r\n            this.node = node;\r\n            this.decorations = decorations;\r\n            return this.options.update({\r\n                oldNode,\r\n                oldDecorations,\r\n                newNode: node,\r\n                newDecorations: decorations,\r\n                updateProps: () => updateProps({ node, decorations }),\r\n            });\r\n        }\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        if (node === this.node && this.decorations === decorations) {\r\n            return true;\r\n        }\r\n        this.node = node;\r\n        this.decorations = decorations;\r\n        updateProps({ node, decorations });\r\n        return true;\r\n    }\r\n    selectNode() {\r\n        this.renderer.updateProps({\r\n            selected: true,\r\n        });\r\n    }\r\n    deselectNode() {\r\n        this.renderer.updateProps({\r\n            selected: false,\r\n        });\r\n    }\r\n    getDecorationClasses() {\r\n        return (this.decorations\r\n            // @ts-ignore\r\n            .map(item => item.type.attrs.class)\r\n            .flat()\r\n            .join(' '));\r\n    }\r\n    destroy() {\r\n        this.renderer.destroy();\r\n    }\r\n}\r\nfunction VueNodeViewRenderer(component, options) {\r\n    return (props) => {\r\n        // try to get the parent component\r\n        // this is important for vue devtools to show the component hierarchy correctly\r\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\r\n        if (!props.editor.contentComponent) {\r\n            return {};\r\n        }\r\n        return new VueNodeView(component, props, options);\r\n    };\r\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRpcHRhcC92dWUtMi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDTDtBQUMvQjtBQUN3QztBQUMvQztBQUMrQzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrRUFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHNDQUFzQyxTQUFTLHdCQUF3QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxxQkFBcUIsZ0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtRkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0MsU0FBUyx3QkFBd0I7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLDJDQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbU9BQW1PLDJDQUFHLEVBQUU7QUFDeE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksd0RBQVU7QUFDdEIsVUFBVSx3REFBVTtBQUNwQixpQkFBaUIsd0RBQVU7QUFDM0IsY0FBYyx5REFBVztBQUN6QixlQUFlLHdEQUFVO0FBQ3pCLFlBQVksMERBQVk7QUFDeEIsc0JBQXNCLDBEQUFZO0FBQ2xDLGdCQUFnQiwwREFBWTtBQUM1QjtBQUNBLDBCQUEwQixrREFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUFHO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUpBQXVKLDJDQUFHLEVBQUU7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThJO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvdnVlLTIvZGlzdC9pbmRleC5qcz8zZThhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudSc7XG5pbXBvcnQgeyBFZGl0b3IgYXMgRWRpdG9yJDEsIE5vZGVWaWV3IH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ01lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51JztcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCB7IG9iamVjdFByb3AsIGJvb2xlYW5Qcm9wLCBmdW5jdGlvblByb3AgfSBmcm9tICd2dWUtdHMtdHlwZXMnO1xuXG5jb25zdCBCdWJibGVNZW51ID0ge1xyXG4gICAgbmFtZTogJ0J1YmJsZU1lbnUnLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBwbHVnaW5LZXk6IHtcclxuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ2J1YmJsZU1lbnUnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWRpdG9yOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVEZWxheToge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aXBweU9wdGlvbnM6IHtcclxuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiAoe30pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdWxkU2hvdzoge1xyXG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcclxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIHdhdGNoOiB7XHJcbiAgICAgICAgZWRpdG9yOiB7XHJcbiAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgaGFuZGxlcihlZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZWdpc3RlclBsdWdpbihCdWJibGVNZW51UGx1Z2luKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMudXBkYXRlRGVsYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy4kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5wbHVnaW5LZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMuc2hvdWxkU2hvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlwcHlPcHRpb25zOiB0aGlzLnRpcHB5T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4odGhpcy5wbHVnaW5LZXkpO1xyXG4gICAgfSxcclxufTtcblxuY2xhc3MgRWRpdG9yIGV4dGVuZHMgRWRpdG9yJDEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVkaXRvckNvbnRlbnQgPSB7XHJcbiAgICBuYW1lOiAnRWRpdG9yQ29udGVudCcsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGVkaXRvcjoge1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB3YXRjaDoge1xyXG4gICAgICAgIGVkaXRvcjoge1xyXG4gICAgICAgICAgICBpbW1lZGlhdGU6IHRydWUsXHJcbiAgICAgICAgICAgIGhhbmRsZXIoZWRpdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yICYmIGVkaXRvci5vcHRpb25zLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLiRlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlZGl0b3Iub3B0aW9ucy5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY3JlYXRlTm9kZVZpZXdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghZWRpdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgZWRpdG9yLnZpZXcuc2V0UHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgbm9kZVZpZXdzOiB7fSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVkaXRvci5jb250ZW50Q29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoIWVkaXRvci5vcHRpb25zLmVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBuZXdFbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgIGVkaXRvci5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgZWxlbWVudDogbmV3RWxlbWVudCxcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbn07XG5cbmNvbnN0IEZsb2F0aW5nTWVudSA9IHtcclxuICAgIG5hbWU6ICdGbG9hdGluZ01lbnUnLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBwbHVnaW5LZXk6IHtcclxuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ2Zsb2F0aW5nTWVudScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlZGl0b3I6IHtcclxuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpcHB5T3B0aW9uczoge1xyXG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG91bGRTaG93OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgd2F0Y2g6IHtcclxuICAgICAgICBlZGl0b3I6IHtcclxuICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBoYW5kbGVyKGVkaXRvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlZ2lzdGVyUGx1Z2luKEZsb2F0aW5nTWVudVBsdWdpbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5wbHVnaW5LZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy4kZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy50aXBweU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMuc2hvdWxkU2hvdyxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4odGhpcy5wbHVnaW5LZXkpO1xyXG4gICAgfSxcclxufTtcblxuY29uc3QgTm9kZVZpZXdDb250ZW50ID0ge1xyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBhczoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkaXYnLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0aGlzLmFzLCB7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICAgICAgJ2RhdGEtbm9kZS12aWV3LWNvbnRlbnQnOiAnJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbn07XG5cbmNvbnN0IE5vZGVWaWV3V3JhcHBlciA9IHtcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgYXM6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGl2JyxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGluamVjdDogWydvbkRyYWdTdGFydCcsICdkZWNvcmF0aW9uQ2xhc3NlcyddLFxyXG4gICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0aGlzLmFzLCB7XHJcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmRlY29yYXRpb25DbGFzc2VzLnZhbHVlLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vcm1hbCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAnZGF0YS1ub2RlLXZpZXctd3JhcHBlcic6ICcnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbjoge1xyXG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xyXG4gICAgfSxcclxufTtcblxuY2xhc3MgVnVlUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9ICh0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSA/IGNvbXBvbmVudCA6IFZ1ZS5leHRlbmQoY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLnJlZiA9IG5ldyBDb21wb25lbnQocHJvcHMpLiRtb3VudCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVsZW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLiRlbDtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByb3BzKHByb3BzID0ge30pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAoIXRoaXMucmVmLiRwcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHByZXZlbnRzIGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHlgIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAvLyBGaXg6IGBWdWVOb2RlVmlld1JlbmRlcmVyYCBjaGFuZ2UgdnVlIENvbnN0cnVjdG9yIGBjb25maWcuc2lsZW50YCBub3Qgd29ya2luZ1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRWdWVDb25zdHJ1Y3RvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMucmVmLiRwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50Q29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuJG9wdGlvbnMuX2Jhc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFZ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2lsZW50ID0gY3VycmVudFZ1ZUNvbnN0cnVjdG9yLmNvbmZpZy5zaWxlbnQ7XHJcbiAgICAgICAgY3VycmVudFZ1ZUNvbnN0cnVjdG9yLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xyXG4gICAgICAgIE9iamVjdFxyXG4gICAgICAgICAgICAuZW50cmllcyhwcm9wcylcclxuICAgICAgICAgICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlZi4kcHJvcHNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN1cnJlbnRWdWVDb25zdHJ1Y3Rvci5jb25maWcuc2lsZW50ID0gb3JpZ2luYWxTaWxlbnQ7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucmVmLiRkZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgbm9kZVZpZXdQcm9wcyA9IHtcclxuICAgIGVkaXRvcjogb2JqZWN0UHJvcCgpLnJlcXVpcmVkLFxyXG4gICAgbm9kZTogb2JqZWN0UHJvcCgpLnJlcXVpcmVkLFxyXG4gICAgZGVjb3JhdGlvbnM6IG9iamVjdFByb3AoKS5yZXF1aXJlZCxcclxuICAgIHNlbGVjdGVkOiBib29sZWFuUHJvcCgpLnJlcXVpcmVkLFxyXG4gICAgZXh0ZW5zaW9uOiBvYmplY3RQcm9wKCkucmVxdWlyZWQsXHJcbiAgICBnZXRQb3M6IGZ1bmN0aW9uUHJvcCgpLnJlcXVpcmVkLFxyXG4gICAgdXBkYXRlQXR0cmlidXRlczogZnVuY3Rpb25Qcm9wKCkucmVxdWlyZWQsXHJcbiAgICBkZWxldGVOb2RlOiBmdW5jdGlvblByb3AoKS5yZXF1aXJlZCxcclxufTtcclxuY2xhc3MgVnVlTm9kZVZpZXcgZXh0ZW5kcyBOb2RlVmlldyB7XHJcbiAgICBtb3VudCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xyXG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXHJcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiB0aGlzLmRlY29yYXRpb25zLFxyXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbjogdGhpcy5leHRlbnNpb24sXHJcbiAgICAgICAgICAgIGdldFBvczogKCkgPT4gdGhpcy5nZXRQb3MoKSxcclxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxyXG4gICAgICAgICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbkNsYXNzZXMgPSBWdWUub2JzZXJ2YWJsZSh7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldERlY29yYXRpb25DbGFzc2VzKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IHZ1ZSA9IChfYiA9IChfYSA9IHRoaXMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS4kb3B0aW9ucy5fYmFzZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gdnVlLmV4dGVuZCh0aGlzLmNvbXBvbmVudCkuZXh0ZW5kKHtcclxuICAgICAgICAgICAgcHJvcHM6IE9iamVjdC5rZXlzKHByb3BzKSxcclxuICAgICAgICAgICAgcHJvdmlkZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uQ2xhc3NlczogdGhpcy5kZWNvcmF0aW9uQ2xhc3NlcyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBWdWVSZW5kZXJlcihDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLmVkaXRvci5jb250ZW50Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBwcm9wc0RhdGE6IHByb3BzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRvbSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbm9kZS12aWV3LXdyYXBwZXInKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGVudERPTSgpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSB0aGlzLmRvbS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctY29udGVudF0nKTtcclxuICAgICAgICByZXR1cm4gKGNvbnRlbnRFbGVtZW50IHx8IHRoaXMuZG9tKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZVByb3BzID0gKHByb3BzKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbkNsYXNzZXMudmFsdWUgPSB0aGlzLmdldERlY29yYXRpb25DbGFzc2VzKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZERlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBvbGROb2RlLFxyXG4gICAgICAgICAgICAgICAgb2xkRGVjb3JhdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgbmV3RGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHVwZGF0ZVByb3BzKHsgbm9kZSwgZGVjb3JhdGlvbnMgfSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSB0aGlzLm5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLm5vZGUgJiYgdGhpcy5kZWNvcmF0aW9ucyA9PT0gZGVjb3JhdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xyXG4gICAgICAgIHVwZGF0ZVByb3BzKHsgbm9kZSwgZGVjb3JhdGlvbnMgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBzZWxlY3ROb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoe1xyXG4gICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVjb3JhdGlvbkNsYXNzZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmRlY29yYXRpb25zXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgLm1hcChpdGVtID0+IGl0ZW0udHlwZS5hdHRycy5jbGFzcylcclxuICAgICAgICAgICAgLmZsYXQoKVxyXG4gICAgICAgICAgICAuam9pbignICcpKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gVnVlTm9kZVZpZXdSZW5kZXJlcihjb21wb25lbnQsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiAocHJvcHMpID0+IHtcclxuICAgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIHZ1ZSBkZXZ0b29scyB0byBzaG93IHRoZSBjb21wb25lbnQgaGllcmFyY2h5IGNvcnJlY3RseVxyXG4gICAgICAgIC8vIG1heWJlIGl04oCZcyBgdW5kZWZpbmVkYCBiZWNhdXNlIDxlZGl0b3ItY29udGVudD4gaXNu4oCZdCByZW5kZXJlZCB5ZXRcclxuICAgICAgICBpZiAoIXByb3BzLmVkaXRvci5jb250ZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWdWVOb2RlVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcclxuICAgIH07XHJcbn1cblxuZXhwb3J0IHsgQnViYmxlTWVudSwgRWRpdG9yLCBFZGl0b3JDb250ZW50LCBGbG9hdGluZ01lbnUsIE5vZGVWaWV3Q29udGVudCwgTm9kZVZpZXdXcmFwcGVyLCBWdWVOb2RlVmlld1JlbmRlcmVyLCBWdWVSZW5kZXJlciwgbm9kZVZpZXdQcm9wcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tiptap/vue-2/dist/index.js\n");

/***/ }),

/***/ "./node_modules/orderedmap/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/orderedmap/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrderedMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzP2NhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gOjotIFBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGFuIG9yZGVyZWQgbWFwcGluZyBmcm9tXG4vLyBzdHJpbmdzIHRvIHZhbHVlcywgd2l0aCBzb21lIGNvbnZlbmllbnQgdXBkYXRlIG1ldGhvZHMuXG5mdW5jdGlvbiBPcmRlcmVkTWFwKGNvbnRlbnQpIHtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbn1cblxuT3JkZXJlZE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcmRlcmVkTWFwLFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSA9PT0ga2V5KSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiA/YW55XG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSBzdG9yZWQgdW5kZXIgYGtleWAsIG9yIHJldHVybiB1bmRlZmluZWQgd2hlblxuICAvLyBubyBzdWNoIGtleSBleGlzdHMuXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50W2ZvdW5kICsgMV1cbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnksID9zdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcmVwbGFjaW5nIHRoZSB2YWx1ZSBvZiBga2V5YCB3aXRoIGEgbmV3XG4gIC8vIHZhbHVlLCBvciBhZGRpbmcgYSBiaW5kaW5nIHRvIHRoZSBlbmQgb2YgdGhlIG1hcC4gSWYgYG5ld0tleWAgaXNcbiAgLy8gZ2l2ZW4sIHRoZSBrZXkgb2YgdGhlIGJpbmRpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoYXQga2V5LlxuICB1cGRhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5ld0tleSkge1xuICAgIHZhciBzZWxmID0gbmV3S2V5ICYmIG5ld0tleSAhPSBrZXkgPyB0aGlzLnJlbW92ZShuZXdLZXkpIDogdGhpcztcbiAgICB2YXIgZm91bmQgPSBzZWxmLmZpbmQoa2V5KSwgY29udGVudCA9IHNlbGYuY29udGVudC5zbGljZSgpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkge1xuICAgICAgY29udGVudC5wdXNoKG5ld0tleSB8fCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFtmb3VuZCArIDFdID0gdmFsdWU7XG4gICAgICBpZiAobmV3S2V5KSBjb250ZW50W2ZvdW5kXSA9IG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykg4oaSIE9yZGVyZWRNYXBcbiAgLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGtleSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLlxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkgcmV0dXJuIHRoaXNcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kLCAyKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIHN0YXJ0IG9mIHRoZSBtYXAuXG4gIGFkZFRvU3RhcnQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoW2tleSwgdmFsdWVdLmNvbmNhdCh0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgZW5kIG9mIHRoZSBtYXAuXG4gIGFkZFRvRW5kOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIGtleSBhZnRlciB0aGUgZ2l2ZW4ga2V5LiBJZiBgcGxhY2VgIGlzIG5vdCBmb3VuZCwgdGhlIG5ld1xuICAvLyBrZXkgaXMgYWRkZWQgdG8gdGhlIGVuZC5cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbihwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB3aXRob3V0ID0gdGhpcy5yZW1vdmUoa2V5KSwgY29udGVudCA9IHdpdGhvdXQuY29udGVudC5zbGljZSgpO1xuICAgIHZhciBmb3VuZCA9IHdpdGhvdXQuZmluZChwbGFjZSk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQgPT0gLTEgPyBjb250ZW50Lmxlbmd0aCA6IGZvdW5kLCAwLCBrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSlcbiAgLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW5cbiAgLy8gb3JkZXIuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGYodGhpcy5jb250ZW50W2ldLCB0aGlzLmNvbnRlbnRbaSArIDFdKTtcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBwcmVwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGJlZm9yZSB0aGUga2V5cyBpbiBgbWFwYC5cbiAgcHJlcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAobWFwLmNvbnRlbnQuY29uY2F0KHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBhcHBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYWZ0ZXIgdGhlIGtleXMgaW4gYG1hcGAuXG4gIGFwcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQuY29uY2F0KG1hcC5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgLlxuICBzdWJ0cmFjdDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZW1vdmUobWFwLmNvbnRlbnRbaV0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiAoKSDihpIgT2JqZWN0XG4gIC8vIFR1cm4gb3JkZXJlZCBtYXAgaW50byBhIHBsYWluIG9iamVjdC5cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXN1bHRba2V5XSA9IHZhbHVlOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgT3JkZXJlZE1hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/orderedmap/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before it—if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == \"start\" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock)\n            return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection)\n                tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd);\n            let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : undefined;\n            let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n                if (deflt)\n                    types = [{ type: deflt }];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr\n            .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n            .join($pos.pos)\n            .scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    if (before.type.spec.isolating || after.type.spec.isolating)\n        return false;\n    if (joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt))\n                tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, node => {\n            if (can)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null) {\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let has = false, tr = state.tr;\n                for (let i = 0; !has && i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (has) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STtBQUN4RjtBQUNzQzs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWE7QUFDcEQsc0JBQXNCLGtFQUFXLCtDQUErQyxvREFBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQVM7QUFDdEUsc0JBQXNCLDREQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQVcsaUNBQWlDLG9EQUFLO0FBQ2hFO0FBQ0Esd0JBQXdCLDhEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBYTtBQUMvQjtBQUNBO0FBQ0EsdUNBQXVDLDREQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNERBQWE7QUFDckQsc0JBQXNCLGtFQUFXLCtDQUErQyxvREFBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsd0RBQVM7QUFDdkUsc0JBQXNCLDREQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNERBQWE7QUFDL0I7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNERBQWE7QUFDckU7QUFDQSxxQ0FBcUMsOERBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDLHFDQUFxQyw4REFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIseURBQXlELGlFQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDLHVCQUF1QiwyREFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLHVDQUF1Qyw0REFBYTtBQUNwRCx3Q0FBd0MsK0RBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQWEsK0JBQStCLDJEQUFZO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GLHNCQUFzQiwrREFBUTtBQUM5QixrQ0FBa0MsK0RBQVEsa0RBQWtELGFBQWE7QUFDekc7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkRBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw4REFBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1REFBUTtBQUNoRSwwQ0FBMEMsUUFBUTtBQUNsRCx1QkFBdUIsdURBQVE7QUFDL0IsbUJBQW1CLHVEQUFRO0FBQzNCLHVDQUF1QyxvRUFBaUIsdUNBQXVDLG9EQUFLO0FBQ3BHO0FBQ0EsZ0JBQWdCLDhEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQVM7QUFDNUIsdUZBQXVGLGlFQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQyw4Q0FBOEMsUUFBUTtBQUN0RCwwQkFBMEIsdURBQVE7QUFDbEMsMkNBQTJDLG9FQUFpQix1SEFBdUgsb0RBQUs7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNERBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLCtEQUErRCxtRUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFrRDtBQUMxRSxrQkFBa0IsU0FBUyxXQUFXLFNBQVMsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Qsc0JBQXNCLFNBQVMsV0FBVyxTQUFTLFlBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRCwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRCwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLG9GQUFvRixXQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQsZ0JBQWdCLDhEQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwYiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzPzYyNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oJGNvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oJGNvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCk7XG4gICAgICAgICAgICBsZXQgdHlwZXMgPSBzcGxpdFR5cGUgPyBbc3BsaXRUeXBlXSA6IGF0RW5kICYmIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdClcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbeyB0eXBlOiBkZWZsdCB9XTtcbiAgICAgICAgICAgICAgICBjYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgIC5jbGVhckluY29tcGF0aWJsZSgkcG9zLnBvcywgYmVmb3JlLnR5cGUsIGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpXG4gICAgICAgICAgICAuam9pbigkcG9zLnBvcylcbiAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luQXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-commands/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            parentLeft = rect.left - parent.scrollLeft;\n            parentTop = rect.top - parent.scrollTop;\n        }\n        this.element.style.left = (rect.left - parentLeft) + \"px\";\n        this.element.style.top = (rect.top - parentTop) + \"px\";\n        this.element.style.width = (rect.right - rect.left) + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUNPOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGVBQWUscURBQU07QUFDckIsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYSxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnRUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcz84NzJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8qKlxuQ3JlYXRlIGEgcGx1Z2luIHRoYXQsIHdoZW4gYWRkZWQgdG8gYSBQcm9zZU1pcnJvciBpbnN0YW5jZSxcbmNhdXNlcyBhIGRlY29yYXRpb24gdG8gc2hvdyB1cCBhdCB0aGUgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZ1xuaXMgZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG5cbk5vZGVzIG1heSBhZGQgYSBgZGlzYWJsZURyb3BDdXJzb3JgIHByb3BlcnR5IHRvIHRoZWlyIHNwZWMgdG9cbmNvbnRyb2wgdGhlIHNob3dpbmcgb2YgYSBkcm9wIGN1cnNvciBpbnNpZGUgdGhlbS4gVGhpcyBtYXkgYmUgYVxuYm9vbGVhbiBvciBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgdmlldyBhbmQgYVxucG9zaXRpb24sIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucyk7IH1cbiAgICB9KTtcbn1cbmNsYXNzIERyb3BDdXJzb3JWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IChfYSA9IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IChvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIik7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBvcHRpb25zLmNsYXNzO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IChlKSA9PiB7IHRoaXNbbmFtZV0oZSk7IH07XG4gICAgICAgICAgICBlZGl0b3JWaWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgaGFuZGxlciB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKCh7IG5hbWUsIGhhbmRsZXIgfSkgPT4gdGhpcy5lZGl0b3JWaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpKTtcbiAgICB9XG4gICAgdXBkYXRlKGVkaXRvclZpZXcsIHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgPiBlZGl0b3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAocG9zID09IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcztcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGxldCAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IGlzQmxvY2sgPSAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCwgcmVjdDtcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgPyBiZWZvcmUubm9kZVNpemUgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IGJlZm9yZSA/IG5vZGVSZWN0LmJvdHRvbSA6IG5vZGVSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IG5vZGVSZWN0LmxlZnQsIHJpZ2h0OiBub2RlUmVjdC5yaWdodCwgdG9wOiB0b3AgLSB0aGlzLndpZHRoIC8gMiwgYm90dG9tOiB0b3AgKyB0aGlzLndpZHRoIC8gMiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aGlzLmVkaXRvclZpZXcuY29vcmRzQXRQb3ModGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogY29vcmRzLmxlZnQgLSB0aGlzLndpZHRoIC8gMiwgcmlnaHQ6IGNvb3Jkcy5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsIHRvcDogY29vcmRzLnRvcCwgYm90dG9tOiBjb29yZHMuYm90dG9tIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZWRpdG9yVmlldy5kb20ub2Zmc2V0UGFyZW50O1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3M7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB6LWluZGV4OiA1MDsgcG9pbnRlci1ldmVudHM6IG5vbmU7XCI7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1ibG9ja1wiLCBpc0Jsb2NrKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWlubGluZVwiLCAhaXNCbG9jayk7XG4gICAgICAgIGxldCBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PSBkb2N1bWVudC5ib2R5ICYmIGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICBwYXJlbnRMZWZ0ID0gLXBhZ2VYT2Zmc2V0O1xuICAgICAgICAgICAgcGFyZW50VG9wID0gLXBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwYXJlbnRMZWZ0ID0gcmVjdC5sZWZ0IC0gcGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSByZWN0LnRvcCAtIHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAocmVjdC50b3AgLSBwYXJlbnRUb3ApICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVtb3ZhbCh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0Q3Vyc29yKG51bGwpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZWRpdGFibGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmVkaXRvclZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgICAgIGxldCBub2RlID0gcG9zICYmIHBvcy5pbnNpZGUgPj0gMCAmJiB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgbGV0IGRpc2FibGVEcm9wQ3Vyc29yID0gbm9kZSAmJiBub2RlLnR5cGUuc3BlYy5kaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdHlwZW9mIGRpc2FibGVEcm9wQ3Vyc29yID09IFwiZnVuY3Rpb25cIiA/IGRpc2FibGVEcm9wQ3Vyc29yKHRoaXMuZWRpdG9yVmlldywgcG9zLCBldmVudCkgOiBkaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgICAgaWYgKHBvcyAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBwb3MucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZyAmJiB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnQgPSBkcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCg1MDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFnZW5kKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy5lZGl0b3JWaWV3LmRvbSB8fCAhdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZHJvcEN1cnNvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-dropcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* binding */ GapCursor),\n/* harmony export */   gapCursor: () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() { return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9EO0FBQ2dDO0FBQ2hDO0FBQ1M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQVM7QUFDdEU7QUFDQSxnQkFBZ0IsT0FBTyxvREFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3REFBd0QsNERBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLGtFQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUNBQXlDO0FBQy9FLDRDQUE0Qyw0REFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVE7QUFDdkIsb0NBQW9DLFFBQVE7QUFDNUMsZUFBZSx1REFBUTtBQUN2Qiw2REFBNkQsb0RBQUs7QUFDbEUsb0JBQW9CLDREQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFhLG9CQUFvQix3REFBVSxzQ0FBc0Msa0JBQWtCO0FBQzlHOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz9kZWIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgdGhlIG5vZGUgYmVmb3JlIChvciBpdHMgZmlyc3QgYW5jZXN0b3IpIGlzIGNsb3NlZFxuICAgICAgICBmb3IgKGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTs7IGJlZm9yZSA9IGJlZm9yZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYmVmb3JlLmNoaWxkQ291bnQgPT0gMCAmJiAhYmVmb3JlLmlubGluZUNvbnRlbnQpIHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBzdGFydCBvZiBkb2N1bWVudFxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYWZ0ZXIuY2hpbGRDb3VudCA9PSAwICYmICFhZnRlci5pbmxpbmVDb250ZW50KSB8fCBhZnRlci5pc0F0b20gfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5DcmVhdGUgYSBnYXAgY3Vyc29yIHBsdWdpbi4gV2hlbiBlbmFibGVkLCB0aGlzIHdpbGwgY2FwdHVyZSBjbGlja3Ncbm5lYXIgYW5kIGFycm93LWtleS1tb3Rpb24gcGFzdCBwbGFjZXMgdGhhdCBkb24ndCBoYXZlIGEgbm9ybWFsbHlcbnNlbGVjdGFibGUgcG9zaXRpb24gbmVhcmJ5LCBhbmQgY3JlYXRlIGEgZ2FwIGN1cnNvciBzZWxlY3Rpb24gZm9yXG50aGVtLiBUaGUgY3Vyc29yIGlzIGRyYXduIGFzIGFuIGVsZW1lbnQgd2l0aCBjbGFzc1xuYFByb3NlTWlycm9yLWdhcGN1cnNvcmAuIFlvdSBjYW4gZWl0aGVyIGluY2x1ZGVcbmBzdHlsZS9nYXBjdXJzb3IuY3NzYCBmcm9tIHRoZSBwYWNrYWdlJ3MgZGlyZWN0b3J5IG9yIGFkZCB5b3VyIG93blxuc3R5bGVzIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiovXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHsgYmVmb3JlaW5wdXQ6IGJlZm9yZWlucHV0IH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgICBcIkFycm93UmlnaHRcIjogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IChkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpIDogKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0ICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICAgICAgaWYgKCEkZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZpZXcsIHBvcywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIUdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgaWYgKGNsaWNrUG9zICYmIGNsaWNrUG9zLmluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCwgd2hlbiBhIGNvbXBvc2l0aW9uIHN0YXJ0cyB3aGlsZSBhIGdhcCBjdXJzb3Jcbi8vIGlzIGFjdGl2ZSwgcXVpY2tseSBjcmVhdGVzIGFuIGlubGluZSBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRpb24gdG9cbi8vIGhhcHBlbiBpbiwgdG8gYXZvaWQgaXQgYmVpbmcgYWJvcnRlZCBieSB0aGUgRE9NIHNlbGVjdGlvbiBiZWluZ1xuLy8gbW92ZWQgaW50byBhIHZhbGlkIHBvc2l0aW9uLlxuZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gICAgaWYgKCFpbnNlcnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZnJhZyA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSBpbnNlcnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGZyYWcgPSBGcmFnbWVudC5mcm9tKGluc2VydFtpXS5jcmVhdGVBbmRGaWxsKG51bGwsIGZyYWcpKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBTbGljZShmcmFnLCAwLCAwKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwgeyBrZXk6IFwiZ2FwY3Vyc29yXCIgfSldKTtcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-gapcursor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* binding */ closeHistory),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth)\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"./node_modules/rope-sequence/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ007O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQkFBMEIscURBQVk7QUFDdEM7QUFDQTtBQUNBLDBCQUEwQixxREFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQyw0QkFBNEIsd0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5qcz83NmQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIOKAlCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgZGlzcGF0Y2gsIHJlZG8pIHtcbiAgICBsZXQgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKTtcbiAgICBsZXQgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gICAgbGV0IHBvcCA9IChyZWRvID8gaGlzdG9yeS51bmRvbmUgOiBoaXN0b3J5LmRvbmUpLnBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBpZiAoIXBvcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWxlY3Rpb24gPSBwb3Auc2VsZWN0aW9uLnJlc29sdmUocG9wLnRyYW5zZm9ybS5kb2MpO1xuICAgIGxldCBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpO1xuICAgIGxldCBuZXdIaXN0ID0gbmV3IEhpc3RvcnlTdGF0ZShyZWRvID8gYWRkZWQgOiBwb3AucmVtYWluaW5nLCByZWRvID8gcG9wLnJlbWFpbmluZyA6IGFkZGVkLCBudWxsLCAwLCAtMSk7XG4gICAgZGlzcGF0Y2gocG9wLnRyYW5zZm9ybS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zZXRNZXRhKGhpc3RvcnlLZXksIHsgcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0IH0pLnNjcm9sbEludG9WaWV3KCkpO1xufVxubGV0IGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZSwgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBudWxsO1xuLy8gQ2hlY2sgd2hldGhlciBhbnkgcGx1Z2luIGluIHRoZSBnaXZlbiBzdGF0ZSBoYXMgYVxuLy8gYGhpc3RvcnlQcmVzZXJ2ZUl0ZW1zYCBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0XG4vLyBwcmVzZXJ2ZSBzdGVwcyBleGFjdGx5IGFzIHRoZXkgY2FtZSBpbiwgc28gdGhhdCB0aGV5IGNhbiBiZVxuLy8gcmViYXNlZC5cbmZ1bmN0aW9uIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSB7XG4gICAgbGV0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICAgIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocGx1Z2luc1tpXS5zcGVjLmhpc3RvcnlQcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zO1xufVxuLyoqXG5TZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG5mcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxucmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbiovXG5mdW5jdGlvbiBjbG9zZUhpc3RvcnkodHIpIHtcbiAgICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpO1xufVxuY29uc3QgaGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJoaXN0b3J5XCIpO1xuY29uc3QgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcbi8qKlxuUmV0dXJucyBhIHBsdWdpbiB0aGF0IGVuYWJsZXMgdGhlIHVuZG8gaGlzdG9yeSBmb3IgYW4gZWRpdG9yLiBUaGVcbnBsdWdpbiB3aWxsIHRyYWNrIHVuZG8gYW5kIHJlZG8gc3RhY2tzLCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuW2B1bmRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkudW5kbykgYW5kIFtgcmVkb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG8pIGNvbW1hbmRzLlxuXG5Zb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG5wcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxudG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZyA9IHsgZGVwdGg6IGNvbmZpZy5kZXB0aCB8fCAxMDAsXG4gICAgICAgIG5ld0dyb3VwRGVsYXk6IGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMCB9O1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBoaXN0b3J5S2V5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShCcmFuY2guZW1wdHksIEJyYW5jaC5lbXB0eSwgbnVsbCwgMCwgLTEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseVRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCB0ciwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlaW5wdXQodmlldywgZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRUeXBlID0gZS5pbnB1dFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHVuZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKCFoaXN0IHx8IGhpc3QudW5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgdW5kbywgdW5kb0RlcHRoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-history/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* binding */ keydownHandler),\n/* harmony export */   keymap: () => (/* binding */ keymap)\n/* harmony export */ });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != \" \") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n                (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there's a modifier\n                // active or the character produced isn't ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNEOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTSxHQUFHLFNBQVMsMkNBQTJDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1rZXltYXAvZGlzdC9pbmRleC5qcz8zY2I2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleU5hbWUsIGJhc2UgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgbGV0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyksIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAobWFjKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShtYXApIHtcbiAgICBsZXQgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgIGNvcHlbbm9ybWFsaXplS2V5TmFtZShwcm9wKV0gPSBtYXBbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0ID0gdHJ1ZSkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbi8qKlxuQ3JlYXRlIGEga2V5bWFwIHBsdWdpbiBmb3IgdGhlIGdpdmVuIHNldCBvZiBiaW5kaW5ncy5cblxuQmluZGluZ3Mgc2hvdWxkIG1hcCBrZXkgbmFtZXMgdG8gW2NvbW1hbmRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcyktc3R5bGVcbmZ1bmN0aW9ucywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBgKEVkaXRvclN0YXRlLCBkaXNwYXRjaCxcbkVkaXRvclZpZXcpYCBhcmd1bWVudHMsIGFuZCBzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0aGV5J3ZlIGhhbmRsZWRcbnRoZSBrZXkuIE5vdGUgdGhhdCB0aGUgdmlldyBhcmd1bWVudCBpc24ndCBwYXJ0IG9mIHRoZSBjb21tYW5kXG5wcm90b2NvbCwgYnV0IGNhbiBiZSB1c2VkIGFzIGFuIGVzY2FwZSBoYXRjaCBpZiBhIGJpbmRpbmcgbmVlZHMgdG9cbmRpcmVjdGx5IGludGVyYWN0IHdpdGggdGhlIFVJLlxuXG5LZXkgbmFtZXMgbWF5IGJlIHN0cmluZ3MgbGlrZSBgXCJTaGlmdC1DdHJsLUVudGVyXCJg4oCUYSBrZXlcbmlkZW50aWZpZXIgcHJlZml4ZWQgd2l0aCB6ZXJvIG9yIG1vcmUgbW9kaWZpZXJzLiBLZXkgaWRlbnRpZmllcnNcbmFyZSBiYXNlZCBvbiB0aGUgc3RyaW5ncyB0aGF0IGNhbiBhcHBlYXIgaW5cbltgS2V5RXZlbnQua2V5YF0oaHR0cHM6ZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleSkuXG5Vc2UgbG93ZXJjYXNlIGxldHRlcnMgdG8gcmVmZXIgdG8gbGV0dGVyIGtleXMgKG9yIHVwcGVyY2FzZSBsZXR0ZXJzXG5pZiB5b3Ugd2FudCBzaGlmdCB0byBiZSBoZWxkKS4gWW91IG1heSB1c2UgYFwiU3BhY2VcImAgYXMgYW4gYWxpYXNcbmZvciB0aGUgYFwiIFwiYCBuYW1lLlxuXG5Nb2RpZmllcnMgY2FuIGJlIGdpdmVuIGluIGFueSBvcmRlci4gYFNoaWZ0LWAgKG9yIGBzLWApLCBgQWx0LWAgKG9yXG5gYS1gKSwgYEN0cmwtYCAob3IgYGMtYCBvciBgQ29udHJvbC1gKSBhbmQgYENtZC1gIChvciBgbS1gIG9yXG5gTWV0YS1gKSBhcmUgcmVjb2duaXplZC4gRm9yIGNoYXJhY3RlcnMgdGhhdCBhcmUgY3JlYXRlZCBieSBob2xkaW5nXG5zaGlmdCwgdGhlIGBTaGlmdC1gIHByZWZpeCBpcyBpbXBsaWVkLCBhbmQgc2hvdWxkIG5vdCBiZSBhZGRlZFxuZXhwbGljaXRseS5cblxuWW91IGNhbiB1c2UgYE1vZC1gIGFzIGEgc2hvcnRoYW5kIGZvciBgQ21kLWAgb24gTWFjIGFuZCBgQ3RybC1gIG9uXG5vdGhlciBwbGF0Zm9ybXMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcCBwbHVnaW5zIHRvIGFuIGVkaXRvci4gVGhlIG9yZGVyIGluXG53aGljaCB0aGV5IGFwcGVhciBkZXRlcm1pbmVzIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIGVhcmx5IGluXG50aGUgYXJyYXkgZ2V0IHRvIGRpc3BhdGNoIGZpcnN0KS5cbiovXG5mdW5jdGlvbiBrZXltYXAoYmluZGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7IHByb3BzOiB7IGhhbmRsZUtleURvd246IGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB9IH0pO1xufVxuLyoqXG5HaXZlbiBhIHNldCBvZiBiaW5kaW5ncyAodXNpbmcgdGhlIHNhbWUgZm9ybWF0IGFzXG5bYGtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNrZXltYXAua2V5bWFwKSksIHJldHVybiBhIFtrZXlkb3duXG5oYW5kbGVyXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVLZXlEb3duKSB0aGF0IGhhbmRsZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykge1xuICAgIGxldCBtYXAgPSBub3JtYWxpemUoYmluZGluZ3MpO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmlldywgZXZlbnQpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KSwgYmFzZU5hbWUsIGRpcmVjdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQpXTtcbiAgICAgICAgaWYgKGRpcmVjdCAmJiBkaXJlY3Qodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQSBjaGFyYWN0ZXIga2V5XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAxICYmIG5hbWUgIT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG5hbWUgd2FzIGFscmVhZHkgbW9kaWZpZWQgYnkgc2hpZnQsIHRyeSBsb29raW5nXG4gICAgICAgICAgICAgICAgLy8gaXQgdXAgd2l0aG91dCBpdHMgc2hpZnQgbW9kaWZpZXJcbiAgICAgICAgICAgICAgICBsZXQgbm9TaGlmdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsIGZhbHNlKV07XG4gICAgICAgICAgICAgICAgaWYgKG5vU2hpZnQgJiYgbm9TaGlmdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IG5hbWUuY2hhckNvZGVBdCgwKSA+IDEyNykgJiZcbiAgICAgICAgICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGZhbGxpbmcgYmFjayB0byB0aGUga2V5Q29kZSB3aGVuIHRoZXJlJ3MgYSBtb2RpZmllclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2ZSBvciB0aGUgY2hhcmFjdGVyIHByb2R1Y2VkIGlzbid0IEFTQ0lJLCBhbmQgb3VyIHRhYmxlXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjZXMgYSBkaWZmZXJlbnQgbmFtZSBmcm9tIHRoZSB0aGUga2V5Q29kZS4gU2VlICM2NjgsXG4gICAgICAgICAgICAgICAgLy8gIzEwNjBcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUNvZGUgPSBtYXBbbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCldO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQ29kZSAmJiBmcm9tQ29kZSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGtleWRvd25IYW5kbGVyLCBrZXltYXAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-keymap/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* binding */ ContentMatch),\n/* harmony export */   DOMParser: () => (/* binding */ DOMParser),\n/* harmony export */   DOMSerializer: () => (/* binding */ DOMSerializer),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkType: () => (/* binding */ MarkType),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeRange: () => (/* binding */ NodeRange),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ReplaceError: () => (/* binding */ ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* binding */ ResolvedPos),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Slice: () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"./node_modules/orderedmap/dist/index.js\");\n\n\nfunction findDiffStart(a, b, pos) {\n    for (let i = 0;; i++) {\n        if (i == a.childCount || i == b.childCount)\n            return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for (let j = 0; childA.text[j] == childB.text[j]; j++)\n                pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null)\n                return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for (let iA = a.childCount, iB = b.childCount;;) {\n        if (iA == 0 || iB == 0)\n            return iA == iB ? null : { a: posA, b: posB };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return { a: posA, b: posB };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n                same++;\n                posA--;\n                posB--;\n            }\n            return { a: posA, b: posB };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner)\n                return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/\nclass Fragment {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    content, size) {\n        this.content = content;\n        this.size = size || 0;\n        if (size == null)\n            for (let i = 0; i < content.length; i++)\n                this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */\n    nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for (let i = 0, pos = 0; pos < to; i++) {\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        let text = \"\", separated = true;\n        this.nodesBetween(from, to, (node, pos) => {\n            if (node.isText) {\n                text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n                separated = !blockSeparator;\n            }\n            else if (node.isLeaf) {\n                if (leafText) {\n                    text += typeof leafText === \"function\" ? leafText(node) : leafText;\n                }\n                else if (node.type.spec.leafText) {\n                    text += node.type.spec.leafText(node);\n                }\n                separated = !blockSeparator;\n            }\n            else if (!separated && node.isBlock) {\n                text += blockSeparator;\n                separated = true;\n            }\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n    append(other) {\n        if (!other.size)\n            return this;\n        if (!this.size)\n            return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for (; i < other.content.length; i++)\n            content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n    cut(from, to = this.size) {\n        if (from == 0 && to == this.size)\n            return this;\n        let result = [], size = 0;\n        if (to > from)\n            for (let i = 0, pos = 0; pos < to; i++) {\n                let child = this.content[i], end = pos + child.nodeSize;\n                if (end > from) {\n                    if (pos < from || end > to) {\n                        if (child.isText)\n                            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                        else\n                            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                    }\n                    result.push(child);\n                    size += child.nodeSize;\n                }\n                pos = end;\n            }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */\n    cutByIndex(from, to) {\n        if (from == to)\n            return Fragment.empty;\n        if (from == 0 && to == this.content.length)\n            return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n    replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node)\n            return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n    addToStart(node) {\n        return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n    addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n    eq(other) {\n        if (this.content.length != other.content.length)\n            return false;\n        for (let i = 0; i < this.content.length; i++)\n            if (!this.content[i].eq(other.content[i]))\n                return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n    get firstChild() { return this.content.length ? this.content[0] : null; }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n    get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null; }\n    /**\n    The number of child nodes in this fragment.\n    */\n    get childCount() { return this.content.length; }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n    child(index) {\n        let found = this.content[index];\n        if (!found)\n            throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n        for (let i = 0, p = 0; i < this.content.length; i++) {\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n    findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n    findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. (Not public.)\n    */\n    findIndex(pos, round = -1) {\n        if (pos == 0)\n            return retIndex(0, pos);\n        if (pos == this.size)\n            return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0)\n            throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for (let i = 0, curPos = 0;; i++) {\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos || round > 0)\n                    return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n    toString() { return \"<\" + this.toStringInner() + \">\"; }\n    /**\n    @internal\n    */\n    toStringInner() { return this.content.join(\", \"); }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n    toJSON() {\n        return this.content.length ? this.content.map(n => n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n    static fromJSON(schema, value) {\n        if (!value)\n            return Fragment.empty;\n        if (!Array.isArray(value))\n            throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n    static fromArray(array) {\n        if (!array.length)\n            return Fragment.empty;\n        let joined, size = 0;\n        for (let i = 0; i < array.length; i++) {\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined)\n                    joined = array.slice(0, i);\n                joined[joined.length - 1] = node\n                    .withText(joined[joined.length - 1].text + node.text);\n            }\n            else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n    static from(nodes) {\n        if (!nodes)\n            return Fragment.empty;\n        if (nodes instanceof Fragment)\n            return nodes;\n        if (Array.isArray(nodes))\n            return this.fromArray(nodes);\n        if (nodes.attrs)\n            return new Fragment([nodes], nodes.nodeSize);\n        throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n            (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/\nFragment.empty = new Fragment([], 0);\nconst found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\n\nfunction compareDeep(a, b) {\n    if (a === b)\n        return true;\n    if (!(a && typeof a == \"object\") ||\n        !(b && typeof b == \"object\"))\n        return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array)\n        return false;\n    if (array) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!compareDeep(a[i], b[i]))\n                return false;\n    }\n    else {\n        for (let p in a)\n            if (!(p in b) || !compareDeep(a[p], b[p]))\n                return false;\n        for (let p in b)\n            if (!(p in a))\n                return false;\n    }\n    return true;\n}\n\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/\nclass Mark {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of this mark.\n    */\n    type, \n    /**\n    The attributes associated with this mark.\n    */\n    attrs) {\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */\n    addToSet(set) {\n        let copy, placed = false;\n        for (let i = 0; i < set.length; i++) {\n            let other = set[i];\n            if (this.eq(other))\n                return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy)\n                    copy = set.slice(0, i);\n            }\n            else if (other.type.excludes(this.type)) {\n                return set;\n            }\n            else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy)\n                        copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy)\n                    copy.push(other);\n            }\n        }\n        if (!copy)\n            copy = set.slice();\n        if (!placed)\n            copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n    removeFromSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n    eq(other) {\n        return this == other ||\n            (this.type == other.type && compareDeep(this.attrs, other.attrs));\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError(\"Invalid input for Mark.fromJSON\");\n        let type = schema.marks[json.type];\n        if (!type)\n            throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        return type.create(json.attrs);\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n    static sameSet(a, b) {\n        if (a == b)\n            return true;\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!a[i].eq(b[i]))\n                return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n    static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0)\n            return Mark.none;\n        if (marks instanceof Mark)\n            return [marks];\n        let copy = marks.slice();\n        copy.sort((a, b) => a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/\nMark.none = [];\n\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/\nclass ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/\n/**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/\nclass Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */\n    constructor(\n    /**\n    The slice's content.\n    */\n    content, \n    /**\n    The open depth at the start of the fragment.\n    */\n    openStart, \n    /**\n    The open depth at the end.\n    */\n    openEnd) {\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */\n    get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n    insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n    removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n    eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n    toJSON() {\n        if (!this.content.size)\n            return null;\n        let json = { content: this.content.toJSON() };\n        if (this.openStart > 0)\n            json.openStart = this.openStart;\n        if (this.openEnd > 0)\n            json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n            throw new RangeError(\"Invalid input for Slice.fromJSON\");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n    static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n            openStart++;\n        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n            openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText)\n            throw new RangeError(\"Removing non-flat range\");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo)\n        throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert))\n            return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth)\n        throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n        throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    }\n    else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    }\n    else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    }\n    else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type))\n        throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n        target[last] = child.withText(target[last].text + child.text);\n    else\n        target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        }\n        else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for (let i = startIndex; i < endIndex; i++)\n        addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset)\n        addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    }\n    else {\n        if (openStart)\n            addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd)\n            addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for (let i = extra - 1; i >= 0; i--)\n        node = $along.node(i).copy(Fragment.from(node));\n    return { start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra) };\n}\n\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/\nclass ResolvedPos {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position that was resolved.\n    */\n    pos, \n    /**\n    @internal\n    */\n    path, \n    /**\n    The offset this position has into its parent node.\n    */\n    parentOffset) {\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */\n    resolveDepth(val) {\n        if (val == null)\n            return this.depth;\n        if (val < 0)\n            return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n    get parent() { return this.node(this.depth); }\n    /**\n    The root node in which the position was resolved.\n    */\n    get doc() { return this.node(0); }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n    node(depth) { return this.path[this.resolveDepth(depth) * 3]; }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n    index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1]; }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n    indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n    start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n    end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n    before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError(\"There is no position before the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n    after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError(\"There is no position after the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n    get textOffset() { return this.pos - this.path[this.path.length - 1]; }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n    get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount)\n            return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n    get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff)\n            return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n    posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for (let i = 0; i < index; i++)\n            pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n    marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0)\n            return Mark.none;\n        // When inside a text node, just return the text node's marks\n        if (this.textOffset)\n            return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */\n    marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline)\n            return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n    sharedDepth(pos) {\n        for (let depth = this.depth; depth > 0; depth--)\n            if (this.start(depth) <= pos && this.end(depth) >= pos)\n                return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n    blockRange(other = this, pred) {\n        if (other.pos < this.pos)\n            return other.blockRange(this);\n        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n                return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n    sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n    max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n    min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let str = \"\";\n        for (let i = 1; i <= this.depth; i++)\n            str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n        return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n    static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size))\n            throw new RangeError(\"Position \" + pos + \" out of range\");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for (let node = doc;;) {\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem)\n                break;\n            node = node.child(index);\n            if (node.isText)\n                break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n    static resolveCached(doc, pos) {\n        for (let i = 0; i < resolveCache.length; i++) {\n            let cached = resolveCache[i];\n            if (cached.pos == pos && cached.doc == doc)\n                return cached;\n        }\n        let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n        return result;\n    }\n}\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/\nclass NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */\n    constructor(\n    /**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object's `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */\n    $from, \n    /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */\n    $to, \n    /**\n    The depth of the node that this range points into.\n    */\n    depth) {\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */\n    get start() { return this.$from.before(this.depth + 1); }\n    /**\n    The position at the end of the range.\n    */\n    get end() { return this.$to.after(this.depth + 1); }\n    /**\n    The parent node that the range points into.\n    */\n    get parent() { return this.$from.node(this.depth); }\n    /**\n    The start index of the range in the parent node.\n    */\n    get startIndex() { return this.$from.index(this.depth); }\n    /**\n    The end index of the range in the parent node.\n    */\n    get endIndex() { return this.$to.indexAfter(this.depth); }\n}\n\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](/docs/guide/#doc) for more information.\n*/\nclass Node {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of node that this is.\n    */\n    type, \n    /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */\n    attrs, \n    // A fragment holding the node's children.\n    content, \n    /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */\n    marks = Mark.none) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n    get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size; }\n    /**\n    The number of children that the node has.\n    */\n    get childCount() { return this.content.childCount; }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n    child(index) { return this.content.child(index); }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) { return this.content.maybeChild(index); }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) { this.content.forEach(f); }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */\n    nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n    get textContent() {\n        return (this.isLeaf && this.type.spec.leafText)\n            ? this.type.spec.leafText(this)\n            : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */\n    get firstChild() { return this.content.firstChild; }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */\n    get lastChild() { return this.content.lastChild; }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n    eq(other) {\n        return this == other || (this.sameMarkup(other) && this.content.eq(other.content));\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n    sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */\n    hasMarkup(type, attrs, marks) {\n        return this.type == type &&\n            compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n            Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n    copy(content = null) {\n        if (content == this.content)\n            return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */\n    mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n    cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size)\n            return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n    slice(from, to = this.content.size, includeParents = false) {\n        if (from == to)\n            return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n    replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n    nodeAt(pos) {\n        for (let node = this;;) {\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node)\n                return null;\n            if (offset == pos || node.isText)\n                return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return { node: this.content.maybeChild(index), index, offset };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childBefore(pos) {\n        if (pos == 0)\n            return { node: null, index: 0, offset: 0 };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos)\n            return { node: this.content.child(index), index, offset };\n        let node = this.content.child(index - 1);\n        return { node, index: index - 1, offset: offset - node.nodeSize };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n    resolve(pos) { return ResolvedPos.resolveCached(this, pos); }\n    /**\n    @internal\n    */\n    resolveNoCache(pos) { return ResolvedPos.resolve(this, pos); }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n    rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from)\n            this.nodesBetween(from, to, node => {\n                if (type.isInSet(node.marks))\n                    found = true;\n                return !found;\n            });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n    get isBlock() { return this.type.isBlock; }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n    get isTextblock() { return this.type.isTextblock; }\n    /**\n    True when this node allows inline content.\n    */\n    get inlineContent() { return this.type.inlineContent; }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n    get isInline() { return this.type.isInline; }\n    /**\n    True when this is a text node.\n    */\n    get isText() { return this.type.isText; }\n    /**\n    True when this is a leaf node.\n    */\n    get isLeaf() { return this.type.isLeaf; }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n    get isAtom() { return this.type.isAtom; }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size)\n            name += \"(\" + this.content.toStringInner() + \")\";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n    contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match)\n            throw new Error(\"Called contentMatchAt on a node with invalid content\");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd)\n            return false;\n        for (let i = start; i < end; i++)\n            if (!this.type.allowsMarks(replacement.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */\n    canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks))\n            return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n    canAppend(other) {\n        if (other.content.size)\n            return this.canReplace(this.childCount, this.childCount, other.content);\n        else\n            return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise error when they do not.\n    */\n    check() {\n        this.type.checkContent(this.content);\n        let copy = Mark.none;\n        for (let i = 0; i < this.marks.length; i++)\n            copy = this.marks[i].addToSet(copy);\n        if (!Mark.sameSet(copy, this.marks))\n            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`);\n        this.content.forEach(node => node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size)\n            obj.content = this.content.toJSON();\n        if (this.marks.length)\n            obj.marks = this.marks.map(n => n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError(\"Invalid input for Node.fromJSON\");\n        let marks = null;\n        if (json.marks) {\n            if (!Array.isArray(json.marks))\n                throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == \"text\") {\n            if (typeof json.text != \"string\")\n                throw new RangeError(\"Invalid text node in JSON\");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        return schema.nodeType(json.type).create(json.attrs, content, marks);\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks) {\n        super(type, attrs, null, marks);\n        if (!content)\n            throw new RangeError(\"Empty text nodes are not allowed\");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() { return this.text; }\n    textBetween(from, to) { return this.text.slice(from, to); }\n    get nodeSize() { return this.text.length; }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text)\n            return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length)\n            return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for (let i = marks.length - 1; i >= 0; i--)\n        str = marks[i].type.name + \"(\" + str + \")\";\n    return str;\n}\n\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/\nclass ContentMatch {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    True when this match state represents a valid end of the node.\n    */\n    validEnd) {\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */\n        this.next = [];\n        /**\n        @internal\n        */\n        this.wrapCache = [];\n    }\n    /**\n    @internal\n    */\n    static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null)\n            return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next)\n            stream.err(\"Unexpected trailing text\");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    matchType(type) {\n        for (let i = 0; i < this.next.length; i++)\n            if (this.next[i].type == type)\n                return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n    matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for (let i = start; cur && i < end; i++)\n            cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */\n    get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n    get defaultType() {\n        for (let i = 0; i < this.next.length; i++) {\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs()))\n                return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */\n    compatible(other) {\n        for (let i = 0; i < this.next.length; i++)\n            for (let j = 0; j < other.next.length; j++)\n                if (this.next[i].type == other.next[j].type)\n                    return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n    fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [this];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd))\n                return Fragment.from(types.map(tp => tp.createAndFill()));\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found)\n                        return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n    findWrapping(target) {\n        for (let i = 0; i < this.wrapCache.length; i += 2)\n            if (this.wrapCache[i] == target)\n                return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */\n    computeWrapping(target) {\n        let seen = Object.create(null), active = [{ match: this, type: null, via: null }];\n        while (active.length) {\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for (let obj = current; obj.type; obj = obj.via)\n                    result.push(obj.type);\n                return result.reverse();\n            }\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({ match: type.contentMatch, type, via: current });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n    get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n    edge(n) {\n        if (n >= this.next.length)\n            throw new RangeError(`There's no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for (let i = 0; i < m.next.length; i++)\n                if (seen.indexOf(m.next[i].next) == -1)\n                    scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i) => {\n            let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n            for (let i = 0; i < m.next.length; i++)\n                out += (i ? \", \" : \"\") + m.next[i].type.name + \"->\" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join(\"\\n\");\n    }\n}\n/**\n@internal\n*/\nContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes) {\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == \"\")\n            this.tokens.pop();\n        if (this.tokens[0] == \"\")\n            this.tokens.shift();\n    }\n    get next() { return this.tokens[this.pos]; }\n    eat(tok) { return this.next == tok && (this.pos++ || true); }\n    err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\"); }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    } while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for (;;) {\n        if (stream.eat(\"+\"))\n            expr = { type: \"plus\", expr };\n        else if (stream.eat(\"*\"))\n            expr = { type: \"star\", expr };\n        else if (stream.eat(\"?\"))\n            expr = { type: \"opt\", expr };\n        else if (stream.eat(\"{\"))\n            expr = parseExprRange(stream, expr);\n        else\n            break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next))\n        stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n        if (stream.next != \"}\")\n            max = parseNum(stream);\n        else\n            max = -1;\n    }\n    if (!stream.eat(\"}\"))\n        stream.err(\"Unclosed braced range\");\n    return { type: \"range\", min, max, expr };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type)\n        return [type];\n    let result = [];\n    for (let typeName in types) {\n        let type = types[typeName];\n        if (type.groups.indexOf(name) > -1)\n            result.push(type);\n    }\n    if (result.length == 0)\n        stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(\")\"))\n            stream.err(\"Missing closing paren\");\n        return expr;\n    }\n    else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map(type => {\n            if (stream.inline == null)\n                stream.inline = type.isInline;\n            else if (stream.inline != type.isInline)\n                stream.err(\"Mixing inline and block content\");\n            return { type: \"name\", value: type };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n    }\n    else {\n        stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n}\n/**\nConstruct an NFA from an expression as returned by the parser. The\nNFA is represented as an array of states, which are themselves\narrays of edges, which are `{term, to}` objects. The first state is\nthe entry state and the last node is the success state.\n\nNote that unlike typical NFAs, the edge ordering in this one is\nsignificant, in that it is used to contruct filler content when\nnecessary.\n*/\nfunction nfa(expr) {\n    let nfa = [[]];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() { return nfa.push([]) - 1; }\n    function edge(from, to, term) {\n        let edge = { term, to };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach(edge => edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == \"choice\") {\n            return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), []);\n        }\n        else if (expr.type == \"seq\") {\n            for (let i = 0;; i++) {\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1)\n                    return next;\n                connect(next, from = node());\n            }\n        }\n        else if (expr.type == \"star\") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == \"plus\") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == \"opt\") {\n            return [edge(from)].concat(compile(expr.expr, from));\n        }\n        else if (expr.type == \"range\") {\n            let cur = from;\n            for (let i = 0; i < expr.min; i++) {\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            }\n            else {\n                for (let i = expr.min; i < expr.max; i++) {\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [edge(cur)];\n        }\n        else if (expr.type == \"name\") {\n            return [edge(from, undefined, expr.value)];\n        }\n        else {\n            throw new Error(\"Unknown expr type\");\n        }\n    }\n}\nfunction cmp(a, b) { return b - a; }\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term)\n            return scan(edges[0].to);\n        result.push(node);\n        for (let i = 0; i < edges.length; i++) {\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1)\n                scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach(node => {\n            nfa[node].forEach(({ term, to }) => {\n                if (!term)\n                    return;\n                let set;\n                for (let i = 0; i < out.length; i++)\n                    if (out[i][0] == term)\n                        set = out[i][1];\n                nullFrom(nfa, to).forEach(node => {\n                    if (!set)\n                        out.push([term, set = []]);\n                    if (set.indexOf(node) == -1)\n                        set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for (let i = 0; i < out.length; i++) {\n            let states = out[i][1].sort(cmp);\n            state.next.push({ type: out[i][0], next: labeled[states.join(\",\")] || explore(states) });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for (let i = 0, work = [match]; i < work.length; i++) {\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for (let j = 0; j < state.next.length; j++) {\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs()))\n                dead = false;\n            if (work.indexOf(next) == -1)\n                work.push(next);\n        }\n        if (dead)\n            stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for (let attrName in attrs) {\n        let attr = attrs[attrName];\n        if (!attr.hasDefault)\n            return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for (let name in attrs) {\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault)\n                given = attr.default;\n            else\n                throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction initAttrs(attrs) {\n    let result = Object.create(null);\n    if (attrs)\n        for (let name in attrs)\n            result[name] = new Attribute(attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name the node type has in this schema.\n    */\n    name, \n    /**\n    A link back to the `Schema` the node type belongs to.\n    */\n    schema, \n    /**\n    The spec that this type is based on\n    */\n    spec) {\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */\n        this.markSet = null;\n        this.groups = spec.group ? spec.group.split(\" \") : [];\n        this.attrs = initAttrs(spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == \"text\");\n        this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */\n    get isInline() { return !this.isBlock; }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n    get isTextblock() { return this.isBlock && this.inlineContent; }\n    /**\n    True for node types that allow no content.\n    */\n    get isLeaf() { return this.contentMatch == ContentMatch.empty; }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n    get isAtom() { return this.isLeaf || !!this.spec.atom; }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n    get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n    hasRequiredAttrs() {\n        for (let n in this.attrs)\n            if (this.attrs[n].isRequired)\n                return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n    compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n    computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs)\n            return this.defaultAttrs;\n        else\n            return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n    create(attrs = null, content, marks) {\n        if (this.isText)\n            throw new Error(\"NodeType.create can't construct text nodes\");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */\n    createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n    createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before)\n                return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after)\n            return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type with the given attributes.\n    */\n    validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd)\n            return false;\n        for (let i = 0; i < content.childCount; i++)\n            if (!this.allowsMarks(content.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n    checkContent(content) {\n        if (!this.validContent(content))\n            throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n    allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n    allowsMarks(marks) {\n        if (this.markSet == null)\n            return true;\n        for (let i = 0; i < marks.length; i++)\n            if (!this.allowsMarkType(marks[i].type))\n                return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n    allowedMarks(marks) {\n        if (this.markSet == null)\n            return marks;\n        let copy;\n        for (let i = 0; i < marks.length; i++) {\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy)\n                    copy = marks.slice(0, i);\n            }\n            else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */\n    static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || \"doc\";\n        if (!result[topType])\n            throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n        if (!result.text)\n            throw new RangeError(\"Every schema needs a 'text' type\");\n        for (let _ in result.text.attrs)\n            throw new RangeError(\"The text node type should not have attributes\");\n        return result;\n    }\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(options) {\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n        this.default = options.default;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/\nclass MarkType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the mark type.\n    */\n    name, \n    /**\n    @internal\n    */\n    rank, \n    /**\n    The schema that this mark type instance is part of.\n    */\n    schema, \n    /**\n    The spec on which the type is based.\n    */\n    spec) {\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */\n    create(attrs = null) {\n        if (!attrs && this.instance)\n            return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n    static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    removeFromSet(set) {\n        for (var i = 0; i < set.length; i++)\n            if (set[i].type == this) {\n                set = set.slice(0, i).concat(set.slice(i + 1));\n                i--;\n            }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (set[i].type == this)\n                return set[i];\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n    excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/\nclass Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */\n    constructor(spec) {\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */\n        this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for (let prop in spec)\n            instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes),\n            instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}),\n            this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for (let prop in this.nodes) {\n            if (prop in this.marks)\n                throw new RangeError(prop + \" can not be both a node and a mark\");\n            let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] ||\n                (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            type.markSet = markExpr == \"_\" ? null :\n                markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n                    markExpr == \"\" || !type.inlineContent ? [] : null;\n        }\n        for (let prop in this.marks) {\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n        }\n        this.nodeFromJSON = this.nodeFromJSON.bind(this);\n        this.markFromJSON = this.markFromJSON.bind(this);\n        this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */\n    node(type, attrs = null, content, marks) {\n        if (typeof type == \"string\")\n            type = this.nodeType(type);\n        else if (!(type instanceof NodeType))\n            throw new RangeError(\"Invalid node type: \" + type);\n        else if (type.schema != this)\n            throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n    text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n    mark(type, attrs) {\n        if (typeof type == \"string\")\n            type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    Deserialize a node from its JSON representation. This method is\n    bound.\n    */\n    nodeFromJSON(json) {\n        return Node.fromJSON(this, json);\n    }\n    /**\n    Deserialize a mark from its JSON representation. This method is\n    bound.\n    */\n    markFromJSON(json) {\n        return Mark.fromJSON(this, json);\n    }\n    /**\n    @internal\n    */\n    nodeType(name) {\n        let found = this.nodes[name];\n        if (!found)\n            throw new RangeError(\"Unknown node type: \" + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for (let i = 0; i < marks.length; i++) {\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        }\n        else {\n            for (let prop in schema.marks) {\n                let mark = schema.marks[prop];\n                if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n                    found.push(ok = mark);\n            }\n        }\n        if (!ok)\n            throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n    return found;\n}\n\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/\nclass DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */\n    constructor(\n    /**\n    The schema into which the parser parses.\n    */\n    schema, \n    /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */\n    rules) {\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */\n        this.tags = [];\n        /**\n        @internal\n        */\n        this.styles = [];\n        rules.forEach(rule => {\n            if (rule.tag)\n                this.tags.push(rule);\n            else if (rule.style)\n                this.styles.push(rule);\n        });\n        // Only normalize list elements when lists in the schema can't directly contain themselves\n        this.normalizeLists = !this.tags.some(r => {\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n                return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */\n    parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n    parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n    matchTag(dom, context, after) {\n        for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) &&\n                (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n                (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false)\n                        continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */\n    matchStyle(prop, value, context, after) {\n        for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 ||\n                rule.context && !context.matchesContext(rule.context) ||\n                // Test that the style string either precisely matches the prop,\n                // or has an '=' sign after the prop, followed by the given\n                // value.\n                style.length > prop.length &&\n                    (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n                continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false)\n                    continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */\n    static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for (; i < result.length; i++) {\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority)\n                    break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for (let name in schema.marks) {\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.mark || rule.ignore || rule.clearMark))\n                        rule.mark = name;\n                });\n        }\n        for (let name in schema.nodes) {\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.node || rule.ignore || rule.mark))\n                        rule.node = name;\n                });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).\n    */\n    static fromSchema(schema) {\n        return schema.cached.domParser ||\n            (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true, article: true, aside: true, blockquote: true, canvas: true,\n    dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n    footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n    h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n    output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\nconst ignoreTags = {\n    head: true, noscript: true, object: true, script: true, style: true, title: true\n};\nconst listTags = { ol: true, ul: true };\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null)\n        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n            (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, \n    // Marks applied to this node itself\n    marks, \n    // Marks that can't apply here, but will be used in children if possible\n    pendingMarks, solid, match, options) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.pendingMarks = pendingMarks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node's children\n        this.activeMarks = Mark.none;\n        // Nested Marks with same type\n        this.stashMarks = [];\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type)\n                return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            }\n            else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length)\n                    this.content.pop();\n                else\n                    this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match)\n            content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    popFromStashMark(mark) {\n        for (let i = this.stashMarks.length - 1; i >= 0; i--)\n            if (mark.eq(this.stashMarks[i]))\n                return this.stashMarks.splice(i, 1)[0];\n    }\n    applyPending(nextType) {\n        for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n            let mark = pending[i];\n            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n                !mark.isInSet(this.activeMarks)) {\n                this.activeMarks = mark.addToSet(this.activeMarks);\n                this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n            }\n        }\n    }\n    inlineContext(node) {\n        if (this.type)\n            return this.type.inlineContent;\n        if (this.content.length)\n            return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(\n    // The parser we are using.\n    parser, \n    // The options passed to this parse.\n    options, isOpen) {\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode)\n            topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen)\n            topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n        else\n            topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n        this.nodes = [topContext];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom) {\n        if (dom.nodeType == 3)\n            this.addTextNode(dom);\n        else if (dom.nodeType == 1)\n            this.addElement(dom);\n    }\n    withStyleRules(dom, f) {\n        let style = dom.getAttribute(\"style\");\n        if (!style)\n            return f();\n        let marks = this.readStyles(parseStyles(style));\n        if (!marks)\n            return; // A style with ignore: true\n        let [addMarks, removeMarks] = marks, top = this.top;\n        for (let i = 0; i < removeMarks.length; i++)\n            this.removePendingMark(removeMarks[i], top);\n        for (let i = 0; i < addMarks.length; i++)\n            this.addPendingMark(addMarks[i]);\n        f();\n        for (let i = 0; i < addMarks.length; i++)\n            this.removePendingMark(addMarks[i], top);\n        for (let i = 0; i < removeMarks.length; i++)\n            this.addPendingMark(removeMarks[i]);\n    }\n    addTextNode(dom) {\n        let value = dom.nodeValue;\n        let top = this.top;\n        if (top.options & OPT_PRESERVE_WS_FULL ||\n            top.inlineContext(dom) ||\n            /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!(top.options & OPT_PRESERVE_WS)) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore ||\n                        (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n                        (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n                        value = value.slice(1);\n                }\n            }\n            else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n                value = value.replace(/\\r?\\n|\\r/g, \" \");\n            }\n            else {\n                value = value.replace(/\\r\\n?/g, \"\\n\");\n            }\n            if (value)\n                this.insertNode(this.parser.schema.text(value));\n            this.findInText(dom);\n        }\n        else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, matchAfter) {\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n            normalizeList(dom);\n        let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n            (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom);\n        }\n        else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent)\n                this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType)\n                dom = rule.skip;\n            let sync, top = this.top, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type)\n                    this.needsBlock = true;\n            }\n            else if (!dom.firstChild) {\n                this.leafFallback(dom);\n                return;\n            }\n            if (rule && rule.skip)\n                this.addAll(dom);\n            else\n                this.withStyleRules(dom, () => this.addAll(dom));\n            if (sync)\n                this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        }\n        else {\n            this.withStyleRules(dom, () => {\n                this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);\n            });\n        }\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom) {\n        if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n            this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n            this.findPlace(this.parser.schema.text(\"-\"));\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an array of marks, or null to indicate some of the styles\n    // had a rule with `ignore` set.\n    readStyles(styles) {\n        let add = Mark.none, remove = Mark.none;\n        for (let i = 0; i < styles.length; i += 2) {\n            for (let after = undefined;;) {\n                let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n                if (!rule)\n                    break;\n                if (rule.ignore)\n                    return null;\n                if (rule.clearMark) {\n                    this.top.pendingMarks.concat(this.top.activeMarks).forEach(m => {\n                        if (rule.clearMark(m))\n                            remove = m.addToSet(remove);\n                    });\n                }\n                else {\n                    add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);\n                }\n                if (rule.consuming === false)\n                    after = rule;\n                else\n                    break;\n            }\n        }\n        return [add, remove];\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, continueAfter) {\n        let sync, nodeType, mark;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);\n            }\n            else if (!this.insertNode(nodeType.create(rule.attrs))) {\n                this.leafFallback(dom);\n            }\n        }\n        else {\n            let markType = this.parser.schema.marks[rule.mark];\n            mark = markType.create(rule.attrs);\n            this.addPendingMark(mark);\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        }\n        else if (continueAfter) {\n            this.addElement(dom, continueAfter);\n        }\n        else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node));\n        }\n        else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == \"string\")\n                contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == \"function\")\n                contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement)\n                contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM);\n        }\n        if (sync && this.sync(startIn))\n            this.open--;\n        if (mark)\n            this.removePendingMark(mark, startIn);\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n            this.findAtPoint(parent, index);\n            this.addDOM(dom);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node) {\n        let route, sync;\n        for (let depth = this.open; depth >= 0; depth--) {\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length)) {\n                route = found;\n                sync = cx;\n                if (!found.length)\n                    break;\n            }\n            if (cx.solid)\n                break;\n        }\n        if (!route)\n            return false;\n        this.sync(sync);\n        for (let i = 0; i < route.length; i++)\n            this.enterInner(route[i], null, false);\n        return true;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block)\n                this.enterInner(block);\n        }\n        if (this.findPlace(node)) {\n            this.closeExtra();\n            let top = this.top;\n            top.applyPending(node.type);\n            if (top.match)\n                top.match = top.match.matchType(node.type);\n            let marks = top.activeMarks;\n            for (let i = 0; i < node.marks.length; i++)\n                if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n                    marks = node.marks[i].addToSet(marks);\n            top.content.push(node.mark(marks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, preserveWS) {\n        let ok = this.findPlace(type.create(attrs));\n        if (ok)\n            this.enterInner(type, attrs, true, preserveWS);\n        return ok;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs = null, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.applyPending(type);\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0)\n            options |= OPT_OPEN_LEFT;\n        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n        this.open++;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for (; i > this.open; i--)\n                this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n    }\n    sync(to) {\n        for (let i = this.open; i >= 0; i--)\n            if (this.nodes[i] == to) {\n                this.open = i;\n                return true;\n            }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for (let i = this.open; i >= 0; i--) {\n            let content = this.nodes[i].content;\n            for (let j = content.length - 1; j >= 0; j--)\n                pos += content[j].nodeSize;\n            if (i)\n                pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == parent && this.find[i].offset == offset)\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findInside(parent) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                    let pos = content.compareDocumentPosition(this.find[i].node);\n                    if (pos & (before ? 2 : 4))\n                        this.find[i].pos = this.currentPos;\n                }\n            }\n    }\n    findInText(textNode) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == textNode)\n                    this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n            }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf(\"|\") > -1)\n            return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split(\"/\");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth) => {\n            for (; i >= 0; i--) {\n                let part = parts[i];\n                if (part == \"\") {\n                    if (i == parts.length - 1 || i == 0)\n                        continue;\n                    for (; depth >= minDepth; depth--)\n                        if (match(i - 1, depth))\n                            return true;\n                    return false;\n                }\n                else {\n                    let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n                        : option && depth >= minDepth ? option.node(depth - minDepth).type\n                            : null;\n                    if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n                        return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context)\n            for (let d = $context.depth; d >= 0; d--) {\n                let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n                if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n                    return deflt;\n            }\n        for (let name in this.parser.schema.nodes) {\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs)\n                return type;\n        }\n    }\n    addPendingMark(mark) {\n        let found = findSameMarkInSet(mark, this.top.pendingMarks);\n        if (found)\n            this.top.stashMarks.push(found);\n        this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n    }\n    removePendingMark(mark, upto) {\n        for (let depth = this.open; depth >= 0; depth--) {\n            let level = this.nodes[depth];\n            let found = level.pendingMarks.lastIndexOf(mark);\n            if (found > -1) {\n                level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n            }\n            else {\n                level.activeMarks = mark.removeFromSet(level.activeMarks);\n                let stashMark = level.popFromStashMark(mark);\n                if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n                    level.activeMarks = stashMark.addToSet(level.activeMarks);\n            }\n            if (level == upto)\n                break;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        }\n        else if (name == \"li\") {\n            prevItem = child;\n        }\n        else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n    let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n    while (m = re.exec(style))\n        result.push(m[1], m[2].trim());\n    return result;\n}\nfunction copy(obj) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for (let name in nodes) {\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType))\n            continue;\n        let seen = [], scan = (match) => {\n            seen.push(match);\n            for (let i = 0; i < match.edgeCount; i++) {\n                let { type, next } = match.edge(i);\n                if (type == nodeType)\n                    return true;\n                if (seen.indexOf(next) < 0 && scan(next))\n                    return true;\n            }\n        };\n        if (scan(parent.contentMatch))\n            return true;\n    }\n}\nfunction findSameMarkInSet(mark, set) {\n    for (let i = 0; i < set.length; i++) {\n        if (mark.eq(set[i]))\n            return set[i];\n    }\n}\n\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/\nclass DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */\n    constructor(\n    /**\n    The node serialization functions.\n    */\n    nodes, \n    /**\n    The mark serialization functions.\n    */\n    marks) {\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */\n    serializeFragment(fragment, options = {}, target) {\n        if (!target)\n            target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach(node => {\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while (keep < active.length && rendered < node.marks.length) {\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n                        break;\n                    keep++;\n                    rendered++;\n                }\n                while (keep < active.length)\n                    top = active.pop()[1];\n                while (rendered < node.marks.length) {\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([add, top]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */\n    serializeNodeInner(node, options) {\n        let { dom, contentDOM } = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n        if (contentDOM) {\n            if (node.isLeaf)\n                throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n    serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for (let i = node.marks.length - 1; i >= 0; i--) {\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */\n    serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n    }\n    /**\n    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If\n    the spec has a hole (zero) in it, `contentDOM` will point at the\n    node with the hole.\n    */\n    static renderSpec(doc, structure, xmlNS = null) {\n        if (typeof structure == \"string\")\n            return { dom: doc.createTextNode(structure) };\n        if (structure.nodeType != null)\n            return { dom: structure };\n        if (structure.dom && structure.dom.nodeType != null)\n            return structure;\n        let tagName = structure[0], space = tagName.indexOf(\" \");\n        if (space > 0) {\n            xmlNS = tagName.slice(0, space);\n            tagName = tagName.slice(space + 1);\n        }\n        let contentDOM;\n        let dom = (xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName));\n        let attrs = structure[1], start = 1;\n        if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n            start = 2;\n            for (let name in attrs)\n                if (attrs[name] != null) {\n                    let space = name.indexOf(\" \");\n                    if (space > 0)\n                        dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n                    else\n                        dom.setAttribute(name, attrs[name]);\n                }\n        }\n        for (let i = start; i < structure.length; i++) {\n            let child = structure[i];\n            if (child === 0) {\n                if (i < structure.length - 1 || i > start)\n                    throw new RangeError(\"Content hole must be the only child of its parent node\");\n                return { dom, contentDOM: dom };\n            }\n            else {\n                let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc, child, xmlNS);\n                dom.appendChild(inner);\n                if (innerContent) {\n                    if (contentDOM)\n                        throw new RangeError(\"Multiple content holes\");\n                    contentDOM = innerContent;\n                }\n            }\n        }\n        return { dom, contentDOM };\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */\n    static fromSchema(schema) {\n        return schema.cached.domSerializer ||\n            (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n    static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text)\n            result.text = node => node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */\n    static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for (let name in obj) {\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM)\n            result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUssdUJBQXVCLEtBQUs7QUFDOUUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBNkQ7QUFDdkc7QUFDQSx5Q0FBeUMsNkRBQTZEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csUUFBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0EseUVBQXlFLGVBQWUsSUFBSSxpQ0FBaUM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QyxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRCxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSxrQ0FBa0MsOENBQThDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQSw4QkFBOEIscUVBQXFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVUsSUFBSSxnQ0FBZ0M7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQVU7QUFDdkMsaUNBQWlDLGtEQUFVLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0pBQW9KLFlBQVk7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanM/YTY0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT3JkZXJlZE1hcCBmcm9tICdvcmRlcmVkbWFwJztcblxuZnVuY3Rpb24gZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3M7XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICAgIGZvciAobGV0IGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICAgICAgICByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDogeyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgbGV0IHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgcG9zQS0tO1xuICAgICAgICAgICAgICAgIHBvc0ItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgIH1cbn1cblxuLyoqXG5BIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cblxuTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG5pbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxuKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGVudCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgICAgIGlmIChzaXplID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyBiZXR3ZWVuIHRoZSBnaXZlbiB0d29cbiAgICBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbiAgICBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIG5vZGVTdGFydCA9IDAsIHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gYHBvc2Agd2lsbCBiZVxuICAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuXG4gICAgYGZhbHNlYCB0byBwcmV2ZW50IHRyYXZlcnNhbCBvZiBhIGdpdmVuIG5vZGUncyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuICAgIFtgTm9kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKS5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiLCBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9ICFibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlYWZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIGxlYWZUZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBsZWFmVGV4dChub2RlKSA6IGxlYWZUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUuc3BlYy5sZWFmVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2VwYXJhdGVkICYmIG5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgY29tYmluZWQgY29udGVudCBvZiB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBvdGhlci5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsIGZpcnN0ID0gb3RoZXIuZmlyc3RDaGlsZCwgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLCBpID0gMDtcbiAgICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0ICsgZmlyc3QudGV4dCk7XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHN1Yi1mcmFnbWVudCBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIE1hdGgubWluKGNoaWxkLnRleHQubGVuZ3RoLCB0byAtIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MgLSAxKSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHBvcyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChyZXN1bHQsIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1dEJ5SW5kZXgoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW4gd2hpY2ggdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4IGlzXG4gICAgcmVwbGFjZWQgYnkgdGhlIGdpdmVuIG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICAgIGNvcHlbaW5kZXhdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IHByZXBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9TdGFydChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IGFwcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb0VuZChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LmNvbmNhdChub2RlKSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBmcmFnbWVudCB0byBhbm90aGVyIG9uZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFswXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbGFzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZSBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2luZGV4XSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcCA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICAgICAgcCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCB0aGlzIGZyYWdtZW50IGFuZCBhbm90aGVyXG4gICAgZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmUgdGhlIHNhbWUuXG4gICAgKi9cbiAgICBmaW5kRGlmZlN0YXJ0KG90aGVyLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZlN0YXJ0KHRoaXMsIG90aGVyLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiwgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCwgYXQgd2hpY2ggdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgZ2l2ZW4gZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmVcbiAgICB0aGUgc2FtZS4gU2luY2UgdGhpcyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB0aGUgc2FtZSBpbiBib3RoXG4gICAgbm9kZXMsIGFuIG9iamVjdCB3aXRoIHR3byBzZXBhcmF0ZSBwb3NpdGlvbnMgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBmaW5kRGlmZkVuZChvdGhlciwgcG9zID0gdGhpcy5zaXplLCBvdGhlclBvcyA9IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZXggYW5kIGlubmVyIG9mZnNldCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcmVsYXRpdmVcbiAgICBwb3NpdGlvbiBpbiB0aGlzIGZyYWdtZW50LiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGJlIHJldXNlZFxuICAgIChvdmVyd3JpdHRlbikgdGhlIG5leHQgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiAoTm90IHB1YmxpYy4pXG4gICAgKi9cbiAgICBmaW5kSW5kZXgocG9zLCByb3VuZCA9IC0xKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCgwLCBwb3MpO1xuICAgICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpO1xuICAgICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IG91dHNpZGUgb2YgZnJhZ21lbnQgKCR7dGhpc30pYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXJQb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZChpKSwgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID09IHBvcyB8fCByb3VuZCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpICsgMSwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSwgY3VyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBkZWJ1Z2dpbmcgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIFwiPFwiICsgdGhpcy50b1N0cmluZ0lubmVyKCkgKyBcIj5cIjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmdJbm5lcigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIik7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKG4gPT4gbi50b0pTT04oKSkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIGZyYWdtZW50IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBGcmFnbWVudC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIGZyYWdtZW50IGZyb20gYW4gYXJyYXkgb2Ygbm9kZXMuIEVuc3VyZXMgdGhhdCBhZGphY2VudFxuICAgIHRleHQgbm9kZXMgd2l0aCB0aGUgc2FtZSBtYXJrcyBhcmUgam9pbmVkIHRvZ2V0aGVyLlxuICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICBpZiAoIWFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgbGV0IGpvaW5lZCwgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gYXJyYXlbaV07XG4gICAgICAgICAgICBzaXplICs9IG5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmVkKVxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoam9pbmVkIHx8IGFycmF5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICAgIHNldCBvZiBub2Rlcy4gRm9yIGBudWxsYCwgaXQgcmV0dXJucyB0aGUgZW1wdHkgZnJhZ21lbnQuIEZvciBhXG4gICAgZnJhZ21lbnQsIHRoZSBmcmFnbWVudCBpdHNlbGYuIEZvciBhIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMsIGFcbiAgICBmcmFnbWVudCBjb250YWluaW5nIHRob3NlIG5vZGVzLlxuICAgICovXG4gICAgc3RhdGljIGZyb20obm9kZXMpIHtcbiAgICAgICAgaWYgKCFub2RlcylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShub2Rlcyk7XG4gICAgICAgIGlmIChub2Rlcy5hdHRycylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVzXSwgbm9kZXMubm9kZVNpemUpO1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICtcbiAgICAgICAgICAgIChub2Rlcy5ub2Rlc0JldHdlZW4gPyBcIiAobG9va3MgbGlrZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBwcm9zZW1pcnJvci1tb2RlbCB3ZXJlIGxvYWRlZClcIiA6IFwiXCIpKTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGZyYWdtZW50LiBJbnRlbmRlZCB0byBiZSByZXVzZWQgd2hlbmV2ZXIgYSBub2RlIGRvZXNuJ3RcbmNvbnRhaW4gYW55dGhpbmcgKHJhdGhlciB0aGFuIGFsbG9jYXRpbmcgYSBuZXcgZW1wdHkgZnJhZ21lbnQgZm9yXG5lYWNoIGxlYWYgbm9kZSkuXG4qL1xuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xuY29uc3QgZm91bmQgPSB7IGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbmZ1bmN0aW9uIHJldEluZGV4KGluZGV4LCBvZmZzZXQpIHtcbiAgICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICAgIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEZWVwKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiKSB8fFxuICAgICAgICAhKGIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFjb21wYXJlRGVlcChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgICAgICBpZiAoIShwIGluIGIpIHx8ICFjb21wYXJlRGVlcChhW3BdLCBiW3BdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5BIG1hcmsgaXMgYSBwaWVjZSBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGUsXG5zdWNoIGFzIGl0IGJlaW5nIGVtcGhhc2l6ZWQsIGluIGNvZGUgZm9udCwgb3IgYSBsaW5rLiBJdCBoYXMgYVxudHlwZSBhbmQgb3B0aW9uYWxseSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgcHJvdmlkZSBmdXJ0aGVyXG5pbmZvcm1hdGlvbiAoc3VjaCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rKS4gTWFya3MgYXJlIGNyZWF0ZWRcbnRocm91Z2ggYSBgU2NoZW1hYCwgd2hpY2ggY29udHJvbHMgd2hpY2ggdHlwZXMgZXhpc3QgYW5kIHdoaWNoXG5hdHRyaWJ1dGVzIHRoZXkgaGF2ZS5cbiovXG5jbGFzcyBNYXJrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICBhdHRycykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgc2V0IG9mIG1hcmtzLCBjcmVhdGUgYSBuZXcgc2V0IHdoaWNoIGNvbnRhaW5zIHRoaXMgb25lIGFzXG4gICAgd2VsbCwgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLiBJZiB0aGlzIG1hcmsgaXMgYWxyZWFkeSBpbiB0aGUgc2V0LFxuICAgIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLiBJZiBhbnkgbWFya3MgdGhhdCBhcmUgc2V0IHRvIGJlXG4gICAgW2V4Y2x1c2l2ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSB3aXRoIHRoaXMgbWFyayBhcmUgcHJlc2VudCxcbiAgICB0aG9zZSBhcmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGNvcHksIHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG90aGVyID0gc2V0W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgpO1xuICAgICAgICBpZiAoIXBsYWNlZClcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSB0aGlzIG1hcmsgZnJvbSB0aGUgZ2l2ZW4gc2V0LCByZXR1cm5pbmcgYSBuZXcgc2V0LiBJZiB0aGlzXG4gICAgbWFyayBpcyBub3QgaW4gdGhlIHNldCwgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaXMgaW4gdGhlIGdpdmVuIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGhhcyB0aGUgc2FtZSB0eXBlIGFuZCBhdHRyaWJ1dGVzIGFzXG4gICAgYW5vdGhlciBtYXJrLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgbWFyayB0byBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gSlNPTi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBNYXJrLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlICR7anNvbi50eXBlfSBpbiB0aGlzIHNjaGVtYWApO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoanNvbi5hdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gc2V0cyBvZiBtYXJrcyBhcmUgaWRlbnRpY2FsLlxuICAgICovXG4gICAgc3RhdGljIHNhbWVTZXQoYSwgYikge1xuICAgICAgICBpZiAoYSA9PSBiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHByb3Blcmx5IHNvcnRlZCBtYXJrIHNldCBmcm9tIG51bGwsIGEgc2luZ2xlIG1hcmssIG9yIGFuXG4gICAgdW5zb3J0ZWQgYXJyYXkgb2YgbWFya3MuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0RnJvbShtYXJrcykge1xuICAgICAgICBpZiAoIW1hcmtzIHx8IEFycmF5LmlzQXJyYXkobWFya3MpICYmIG1hcmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgaWYgKG1hcmtzIGluc3RhbmNlb2YgTWFyaylcbiAgICAgICAgICAgIHJldHVybiBbbWFya3NdO1xuICAgICAgICBsZXQgY29weSA9IG1hcmtzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkuc29ydCgoYSwgYikgPT4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuayk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBtYXJrcy5cbiovXG5NYXJrLm5vbmUgPSBbXTtcblxuLyoqXG5FcnJvciB0eXBlIHJhaXNlZCBieSBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdoZW5cbmdpdmVuIGFuIGludmFsaWQgcmVwbGFjZW1lbnQuXG4qL1xuY2xhc3MgUmVwbGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLypcblJlcGxhY2VFcnJvciA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpXG4gIDsoZXJyIGFzIGFueSkuX19wcm90b19fID0gUmVwbGFjZUVycm9yLnByb3RvdHlwZVxuICByZXR1cm4gZXJyXG59IGFzIGFueVxuXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZUVycm9yXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlJlcGxhY2VFcnJvclwiXG4qL1xuLyoqXG5BIHNsaWNlIHJlcHJlc2VudHMgYSBwaWVjZSBjdXQgb3V0IG9mIGEgbGFyZ2VyIGRvY3VtZW50LiBJdFxuc3RvcmVzIG5vdCBvbmx5IGEgZnJhZ21lbnQsIGJ1dCBhbHNvIHRoZSBkZXB0aCB1cCB0byB3aGljaCBub2RlcyBvblxuYm90aCBzaWRlIGFyZSDigJhvcGVu4oCZIChjdXQgdGhyb3VnaCkuXG4qL1xuY2xhc3MgU2xpY2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlLiBXaGVuIHNwZWNpZnlpbmcgYSBub24temVybyBvcGVuIGRlcHRoLCB5b3UgbXVzdFxuICAgIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBub2RlcyBvZiBhdCBsZWFzdCB0aGF0IGRlcHRoIGF0IHRoZVxuICAgIGFwcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGZyYWdtZW504oCUaS5lLiBpZiB0aGUgZnJhZ21lbnQgaXMgYW5cbiAgICBlbXB0eSBwYXJhZ3JhcGggbm9kZSwgYG9wZW5TdGFydGAgYW5kIGBvcGVuRW5kYCBjYW4ndCBiZSBncmVhdGVyXG4gICAgdGhhbiAxLlxuICAgIFxuICAgIEl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb250ZW50IG9mIG9wZW4gbm9kZXMgdG8gY29uZm9ybSB0b1xuICAgIHRoZSBzY2hlbWEncyBjb250ZW50IGNvbnN0cmFpbnRzLCB0aG91Z2ggaXQgc2hvdWxkIGJlIGEgdmFsaWRcbiAgICBzdGFydC9lbmQvbWlkZGxlIGZvciBzdWNoIGEgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGVzIGFyZVxuICAgIG9wZW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2xpY2UncyBjb250ZW50LlxuICAgICovXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIG9wZW5TdGFydCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIG9wZW5FbmQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IG9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIHRoaXMgc2xpY2Ugd291bGQgYWRkIHdoZW4gaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBpbnNlcnRJbnRvKHRoaXMuY29udGVudCwgcG9zICsgdGhpcy5vcGVuU3RhcnQsIGZyYWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgJiYgbmV3IFNsaWNlKGNvbnRlbnQsIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlbW92ZUJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoaXMgc2xpY2UgaXMgZXF1YWwgdG8gYW5vdGhlciBzbGljZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBzbGljZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uID0geyBjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzbGljZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLCBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZSBmcm9tIGEgZnJhZ21lbnQgYnkgdGFraW5nIHRoZSBtYXhpbXVtIHBvc3NpYmxlXG4gICAgb3BlbiB2YWx1ZSBvbiBib3RoIHNpZGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgc3RhdGljIG1heE9wZW4oZnJhZ21lbnQsIG9wZW5Jc29sYXRpbmcgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKVxuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5sYXN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2xpY2UuXG4qL1xuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuZnVuY3Rpb24gcmVtb3ZlUmFuZ2UoY29udGVudCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGxldCB7IGluZGV4OiBpbmRleFRvLCBvZmZzZXQ6IG9mZnNldFRvIH0gPSBjb250ZW50LmZpbmRJbmRleCh0byk7XG4gICAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAob2Zmc2V0VG8gIT0gdG8gJiYgIWNvbnRlbnQuY2hpbGQoaW5kZXhUbykuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT0gaW5kZXhUbylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpO1xuICAgIH1cbiAgICBsZXQgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQpO1xuICAgIHJldHVybiBpbm5lciAmJiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluc2VydGVkIGNvbnRlbnQgZGVlcGVyIHRoYW4gaW5zZXJ0aW9uIHBvc2l0aW9uXCIpO1xuICAgIGlmICgkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCAhPSAkdG8uZGVwdGggLSBzbGljZS5vcGVuRW5kKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5jb25zaXN0ZW50IG9wZW4gZGVwdGhzXCIpO1xuICAgIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICAgIGxldCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgbGV0IGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgICAgICByZXR1cm4gbm9kZS5jb3B5KG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5kZXB0aCA9PSBkZXB0aCAmJiAkdG8uZGVwdGggPT0gZGVwdGgpIHsgLy8gU2ltcGxlLCBmbGF0IGNhc2VcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLnBhcmVudCwgY29udGVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKTtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgc3RhcnQsIGVuZCwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgICBpZiAoIXN1Yi50eXBlLmNvbXBhdGlibGVDb250ZW50KG1haW4udHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJDYW5ub3Qgam9pbiBcIiArIHN1Yi50eXBlLm5hbWUgKyBcIiBvbnRvIFwiICsgbWFpbi50eXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICAgIGxldCBub2RlID0gJGJlZm9yZS5ub2RlKGRlcHRoKTtcbiAgICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICAgIGxldCBsYXN0ID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKVxuICAgICAgICB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO1xuICAgIGVsc2VcbiAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gICAgbGV0IG5vZGUgPSAoJGVuZCB8fCAkc3RhcnQpLm5vZGUoZGVwdGgpO1xuICAgIGxldCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSAkZW5kID8gJGVuZC5pbmRleChkZXB0aCkgOiBub2RlLmNoaWxkQ291bnQ7XG4gICAgaWYgKCRzdGFydCkge1xuICAgICAgICBzdGFydEluZGV4ID0gJHN0YXJ0LmluZGV4KGRlcHRoKTtcbiAgICAgICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldClcbiAgICAgICAgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBjbG9zZShub2RlLCBjb250ZW50KSB7XG4gICAgbm9kZS50eXBlLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgICBsZXQgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICAgIGxldCBvcGVuRW5kID0gJHRvLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGVuZCwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgICAgICBjaGVja0pvaW4ob3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcGVuU3RhcnQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgICAgICBpZiAob3BlbkVuZClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKHR5cGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gICAgbGV0IGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LCBwYXJlbnQgPSAkYWxvbmcubm9kZShleHRyYSk7XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuY29weShzbGljZS5jb250ZW50KTtcbiAgICBmb3IgKGxldCBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgICAgICBlbmQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUobm9kZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kIC0gZXh0cmEpIH07XG59XG5cbi8qKlxuWW91IGNhbiBbX3Jlc29sdmVfXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXNvbHZlKSBhIHBvc2l0aW9uIHRvIGdldCBtb3JlXG5pbmZvcm1hdGlvbiBhYm91dCBpdC4gT2JqZWN0cyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBzdWNoIGFcbnJlc29sdmVkIHBvc2l0aW9uLCBwcm92aWRpbmcgdmFyaW91cyBwaWVjZXMgb2YgY29udGV4dFxuaW5mb3JtYXRpb24sIGFuZCBzb21lIGhlbHBlciBtZXRob2RzLlxuXG5UaHJvdWdob3V0IHRoaXMgaW50ZXJmYWNlLCBtZXRob2RzIHRoYXQgdGFrZSBhbiBvcHRpb25hbCBgZGVwdGhgXG5wYXJhbWV0ZXIgd2lsbCBpbnRlcnByZXQgdW5kZWZpbmVkIGFzIGB0aGlzLmRlcHRoYCBhbmQgbmVnYXRpdmVcbm51bWJlcnMgYXMgYHRoaXMuZGVwdGggKyB2YWx1ZWAuXG4qL1xuY2xhc3MgUmVzb2x2ZWRQb3Mge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIHRoYXQgd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhdGgsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgdGhpcyBwb3NpdGlvbiBoYXMgaW50byBpdHMgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucGFyZW50T2Zmc2V0ID0gcGFyZW50T2Zmc2V0O1xuICAgICAgICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlRGVwdGgodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgICBpZiAodmFsIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoICsgdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gcG9pbnRzIGludG8uIE5vdGUgdGhhdCBldmVuIGlmXG4gICAgYSBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhhdCBub2RlIGlzIG5vdCBjb25zaWRlcmVkXG4gICAgdGhlIHBhcmVudOKAlHRleHQgbm9kZXMgYXJlIOKAmGZsYXTigJkgaW4gdGhpcyBtb2RlbCwgYW5kIGhhdmUgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgcm9vdCBub2RlIGluIHdoaWNoIHRoZSBwb3NpdGlvbiB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBnZXQgZG9jKCkgeyByZXR1cm4gdGhpcy5ub2RlKDApOyB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2VzdG9yIG5vZGUgYXQgdGhlIGdpdmVuIGxldmVsLiBgcC5ub2RlKHAuZGVwdGgpYCBpcyB0aGVcbiAgICBzYW1lIGFzIGBwLnBhcmVudGAuXG4gICAgKi9cbiAgICBub2RlKGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlIGdpdmVuIGxldmVsLiBJZiB0aGlzIHBvaW50c1xuICAgIGF0IHRoZSAzcmQgbm9kZSBpbiB0aGUgMm5kIHBhcmFncmFwaCBvbiB0aGUgdG9wIGxldmVsLCBmb3JcbiAgICBleGFtcGxlLCBgcC5pbmRleCgwKWAgaXMgMSBhbmQgYHAuaW5kZXgoMSlgIGlzIDIuXG4gICAgKi9cbiAgICBpbmRleChkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBwb2ludGluZyBhZnRlciB0aGlzIHBvc2l0aW9uIGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLlxuICAgICovXG4gICAgaW5kZXhBZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZGVwdGgpICsgKGRlcHRoID09IHRoaXMuZGVwdGggJiYgIXRoaXMudGV4dE9mZnNldCA/IDAgOiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgc3RhcnQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBlbmQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGRlcHRoKSArIHRoaXMubm9kZShkZXB0aCkuY29udGVudC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBiZWZvcmUgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yLCB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYCwgdGhlIG9yaWdpbmFsXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBiZWZvcmUoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLlxuICAgICovXG4gICAgYWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGlzIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGlzIHJldHVybnMgdGhlXG4gICAgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gYW5kIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBub2RlLlxuICAgIFdpbGwgYmUgemVybyBmb3IgcG9zaXRpb25zIHRoYXQgcG9pbnQgYmV0d2VlbiBub2Rlcy5cbiAgICAqL1xuICAgIGdldCB0ZXh0T2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGUgcG9zaXRpb25cbiAgICBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGUgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUFmdGVyKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdLCBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gICAgICAgIHJldHVybiBkT2ZmID8gcGFyZW50LmNoaWxkKGluZGV4KS5jdXQoZE9mZikgOiBjaGlsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGJlZm9yZSB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlXG4gICAgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlXG4gICAgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQmVmb3JlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IDAgPyBudWxsIDogdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHBhcmVudCBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGRlcHRoICh3aGljaCBkZWZhdWx0cyB0byBgdGhpcy5kZXB0aGApLlxuICAgICovXG4gICAgcG9zQXRJbmRleChpbmRleCwgZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYXQgdGhpcyBwb3NpdGlvbiwgZmFjdG9yaW5nIGluIHRoZSBzdXJyb3VuZGluZ1xuICAgIG1hcmtzJyBbYGluY2x1c2l2ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5pbmNsdXNpdmUpIHByb3BlcnR5LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgYSBub24tZW1wdHkgbm9kZSwgdGhlIG1hcmtzIG9mIHRoZVxuICAgIG5vZGUgYWZ0ZXIgaXQgKGlmIGFueSkgYXJlIHJldHVybmVkLlxuICAgICovXG4gICAgbWFya3MoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICAgIC8vIEluIGFuIGVtcHR5IHBhcmVudCwgcmV0dXJuIHRoZSBlbXB0eSBhcnJheVxuICAgICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgLy8gV2hlbiBpbnNpZGUgYSB0ZXh0IG5vZGUsIGp1c3QgcmV0dXJuIHRoZSB0ZXh0IG5vZGUncyBtYXJrc1xuICAgICAgICBpZiAodGhpcy50ZXh0T2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICAgIGxldCBtYWluID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXggLSAxKSwgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIC8vIElmIHRoZSBgYWZ0ZXJgIGZsYWcgaXMgdHJ1ZSBvZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSwgbWFrZVxuICAgICAgICAvLyB0aGUgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uIHRoZSBtYWluIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gbWFpbjtcbiAgICAgICAgICAgIG1haW4gPSBvdGhlcjtcbiAgICAgICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbGwgbWFya3MgaW4gdGhlIG1haW4gbm9kZSwgZXhjZXB0IHRob3NlIHRoYXQgaGF2ZVxuICAgICAgICAvLyBgaW5jbHVzaXZlYCBzZXQgdG8gZmFsc2UgYW5kIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgbm9kZS5cbiAgICAgICAgbGV0IG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGlmIGFueSwgZXhjZXB0IHRob3NlXG4gICAgdGhhdCBhcmUgbm9uLWluY2x1c2l2ZSBhbmQgbm90IHByZXNlbnQgYXQgcG9zaXRpb24gYCRlbmRgLiBUaGlzXG4gICAgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIG1hcmtzIHRvIHByZXNlcnZlIGFmdGVyIGFcbiAgICBkZWxldGlvbi4gV2lsbCByZXR1cm4gYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZSBvciBpdHMgcGFyZW50IG5vZGUgaXNuJ3QgYSB0ZXh0YmxvY2sgKGluIHdoaWNoXG4gICAgY2FzZSBubyBtYXJrcyBzaG91bGQgYmUgcHJlc2VydmVkKS5cbiAgICAqL1xuICAgIG1hcmtzQWNyb3NzKCRlbmQpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgICBpZiAoIWFmdGVyIHx8ICFhZnRlci5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbWFya3MgPSBhZnRlci5tYXJrcywgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW5leHQgfHwgIW1hcmtzW2ldLmlzSW5TZXQobmV4dC5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVwdGggdXAgdG8gd2hpY2ggdGhpcyBwb3NpdGlvbiBhbmQgdGhlIGdpdmVuIChub24tcmVzb2x2ZWQpXG4gICAgcG9zaXRpb24gc2hhcmUgdGhlIHNhbWUgcGFyZW50IG5vZGVzLlxuICAgICovXG4gICAgc2hhcmVkRGVwdGgocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQoZGVwdGgpIDw9IHBvcyAmJiB0aGlzLmVuZChkZXB0aCkgPj0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByYW5nZSBiYXNlZCBvbiB0aGUgcGxhY2Ugd2hlcmUgdGhpcyBwb3NpdGlvbiBhbmQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24gZGl2ZXJnZSBhcm91bmQgYmxvY2sgY29udGVudC4gSWYgYm90aCBwb2ludCBpbnRvXG4gICAgdGhlIHNhbWUgdGV4dGJsb2NrLCBmb3IgZXhhbXBsZSwgYSByYW5nZSBhcm91bmQgdGhhdCB0ZXh0YmxvY2tcbiAgICB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGV5IHBvaW50IGludG8gZGlmZmVyZW50IGJsb2NrcywgdGhlIHJhbmdlXG4gICAgYXJvdW5kIHRob3NlIGJsb2NrcyBpbiB0aGVpciBzaGFyZWQgYW5jZXN0b3IgaXMgcmV0dXJuZWQuIFlvdSBjYW5cbiAgICBwYXNzIGluIGFuIG9wdGlvbmFsIHByZWRpY2F0ZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJlbnRcbiAgICBub2RlIHRvIHNlZSBpZiBhIHJhbmdlIGludG8gdGhhdCBwYXJlbnQgaXMgYWNjZXB0YWJsZS5cbiAgICAqL1xuICAgIGJsb2NrUmFuZ2Uob3RoZXIgPSB0aGlzLCBwcmVkKSB7XG4gICAgICAgIGlmIChvdGhlci5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5ibG9ja1JhbmdlKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBkID0gdGhpcy5kZXB0aCAtICh0aGlzLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHRoaXMucG9zID09IG90aGVyLnBvcyA/IDEgOiAwKTsgZCA+PSAwOyBkLS0pXG4gICAgICAgICAgICBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJhbmdlKHRoaXMsIG90aGVyLCBkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIHNoYXJlcyB0aGUgc2FtZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHNhbWVQYXJlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWF4KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPiB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zIDwgdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmRlcHRoOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTtcbiAgICAgICAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgICAgaWYgKCEocG9zID49IDAgJiYgcG9zIDw9IGRvYy5jb250ZW50LnNpemUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMCwgcGFyZW50T2Zmc2V0ID0gcG9zO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gZG9jOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghcmVtKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmVDYWNoZWQoZG9jLCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSByZXNvbHZlQ2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkLnBvcyA9PSBwb3MgJiYgY2FjaGVkLmRvYyA9PSBkb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzb2x2ZUNhY2hlW3Jlc29sdmVDYWNoZVBvc10gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgICAgcmVzb2x2ZUNhY2hlUG9zID0gKHJlc29sdmVDYWNoZVBvcyArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5sZXQgcmVzb2x2ZUNhY2hlID0gW10sIHJlc29sdmVDYWNoZVBvcyA9IDAsIHJlc29sdmVDYWNoZVNpemUgPSAxMjtcbi8qKlxuUmVwcmVzZW50cyBhIGZsYXQgcmFuZ2Ugb2YgY29udGVudCwgaS5lLiBvbmUgdGhhdCBzdGFydHMgYW5kXG5lbmRzIGluIHRoZSBzYW1lIG5vZGUuXG4qL1xuY2xhc3MgTm9kZVJhbmdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBub2RlIHJhbmdlLiBgJGZyb21gIGFuZCBgJHRvYCBzaG91bGQgcG9pbnQgaW50byB0aGVcbiAgICBzYW1lIG5vZGUgdW50aWwgYXQgbGVhc3QgdGhlIGdpdmVuIGBkZXB0aGAsIHNpbmNlIGEgbm9kZSByYW5nZVxuICAgIGRlbm90ZXMgYW4gYWRqYWNlbnQgc2V0IG9mIG5vZGVzIGluIGEgc2luZ2xlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQSByZXNvbHZlZCBwb3NpdGlvbiBhbG9uZyB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQuIE1heSBoYXZlIGFcbiAgICBgZGVwdGhgIGdyZWF0ZXIgdGhhbiB0aGlzIG9iamVjdCdzIGBkZXB0aGAgcHJvcGVydHksIHNpbmNlXG4gICAgdGhlc2UgYXJlIHRoZSBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgcmFuZ2UsXG4gICAgbm90IHJlLXJlc29sdmVkIHBvc2l0aW9ucyBkaXJlY3RseSBhdCBpdHMgYm91bmRhcmllcy5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBBIHBvc2l0aW9uIGFsb25nIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuIFNlZVxuICAgIGNhdmVhdCBmb3IgW2AkZnJvbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UuJGZyb20pLlxuICAgICovXG4gICAgJHRvLCBcbiAgICAvKipcbiAgICBUaGUgZGVwdGggb2YgdGhlIG5vZGUgdGhhdCB0aGlzIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZGVwdGgpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uYmVmb3JlKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgc3RhcnRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgZW5kSW5kZXgoKSB7IHJldHVybiB0aGlzLiR0by5pbmRleEFmdGVyKHRoaXMuZGVwdGgpOyB9XG59XG5cbmNvbnN0IGVtcHR5QXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5UaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBub2RlIGluIHRoZSB0cmVlIHRoYXQgbWFrZXMgdXAgYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQuIFNvIGEgZG9jdW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLCB3aXRoXG5jaGlsZHJlbiB0aGF0IGFyZSBhbHNvIGluc3RhbmNlcyBvZiBgTm9kZWAuXG5cbk5vZGVzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcy4gSW5zdGVhZCBvZiBjaGFuZ2luZyB0aGVtLCB5b3VcbmNyZWF0ZSBuZXcgb25lcyB3aXRoIHRoZSBjb250ZW50IHlvdSB3YW50LiBPbGQgb25lcyBrZWVwIHBvaW50aW5nXG5hdCB0aGUgb2xkIGRvY3VtZW50IHNoYXBlLiBUaGlzIGlzIG1hZGUgY2hlYXBlciBieSBzaGFyaW5nXG5zdHJ1Y3R1cmUgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgZGF0YSBhcyBtdWNoIGFzIHBvc3NpYmxlLCB3aGljaCBhXG50cmVlIHNoYXBlIGxpa2UgdGhpcyAod2l0aG91dCBiYWNrIHBvaW50ZXJzKSBtYWtlcyBlYXN5LlxuXG4qKkRvIG5vdCoqIGRpcmVjdGx5IG11dGF0ZSB0aGUgcHJvcGVydGllcyBvZiBhIGBOb2RlYCBvYmplY3QuIFNlZVxuW3RoZSBndWlkZV0oL2RvY3MvZ3VpZGUvI2RvYykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBpcy5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIEFuIG9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMuIFRoZSBraW5kIG9mXG4gICAgYXR0cmlidXRlcyBhbGxvd2VkIGFuZCByZXF1aXJlZCBhcmVcbiAgICBbZGV0ZXJtaW5lZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0dHJzKSBieSB0aGUgbm9kZSB0eXBlLlxuICAgICovXG4gICAgYXR0cnMsIFxuICAgIC8vIEEgZnJhZ21lbnQgaG9sZGluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrcyAodGhpbmdzIGxpa2Ugd2hldGhlciBpdCBpcyBlbXBoYXNpemVkIG9yIHBhcnQgb2YgYVxuICAgIGxpbmspIGFwcGxpZWQgdG8gdGhpcyBub2RlLlxuICAgICovXG4gICAgbWFya3MgPSBNYXJrLm5vbmUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIG9mIHRoaXMgbm9kZSwgYXMgZGVmaW5lZCBieSB0aGUgaW50ZWdlci1iYXNlZCBbaW5kZXhpbmdcbiAgICBzY2hlbWVdKC9kb2NzL2d1aWRlLyNkb2MuaW5kZXhpbmcpLiBGb3IgdGV4dCBub2RlcywgdGhpcyBpcyB0aGVcbiAgICBhbW91bnQgb2YgY2hhcmFjdGVycy4gRm9yIG90aGVyIGxlYWYgbm9kZXMsIGl0IGlzIG9uZS4gRm9yXG4gICAgbm9uLWxlYWYgbm9kZXMsIGl0IGlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IHBsdXMgdHdvICh0aGVcbiAgICBzdGFydCBhbmQgZW5kIHRva2VuKS5cbiAgICAqL1xuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGUgbm9kZSBoYXMuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50OyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2VzIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikgeyB0aGlzLmNvbnRlbnQuZm9yRWFjaChmKTsgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyByZWN1cnNpdmVseSBiZXR3ZWVuXG4gICAgdGhlIGdpdmVuIHR3byBwb3NpdGlvbnMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpc1xuICAgIG5vZGUncyBjb250ZW50LiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIHRoZSBub2RlLCBpdHNcbiAgICBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgbm9kZSAobWV0aG9kIHJlY2VpdmVyKSxcbiAgICBpdHMgcGFyZW50IG5vZGUsIGFuZCBpdHMgY2hpbGQgaW5kZXguIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBmYWxzZSBmb3IgYSBnaXZlbiBub2RlLCB0aGF0IG5vZGUncyBjaGlsZHJlbiB3aWxsIG5vdCBiZVxuICAgIHJlY3Vyc2VkIG92ZXIuIFRoZSBsYXN0IHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGFcbiAgICBzdGFydGluZyBwb3NpdGlvbiB0byBjb3VudCBmcm9tLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcyA9IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBEb2Vzbid0XG4gICAgZGVzY2VuZCBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uY2F0ZW5hdGVzIGFsbCB0aGUgdGV4dCBub2RlcyBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IGFuZCBpdHNcbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dClcbiAgICAgICAgICAgID8gdGhpcy50eXBlLnNwZWMubGVhZlRleHQodGhpcylcbiAgICAgICAgICAgIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhbGwgdGV4dCBiZXR3ZWVuIHBvc2l0aW9ucyBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgYmxvY2tTZXBhcmF0b3JgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGluc2VydGVkIHRvIHNlcGFyYXRlIHRleHRcbiAgICBmcm9tIGRpZmZlcmVudCBibG9jayBub2Rlcy4gSWYgYGxlYWZUZXh0YCBpcyBnaXZlbiwgaXQnbGwgYmVcbiAgICBpbnNlcnRlZCBmb3IgZXZlcnkgbm9uLXRleHQgbGVhZiBub2RlIGVuY291bnRlcmVkLCBvdGhlcndpc2VcbiAgICBbYGxlYWZUZXh0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjXmxlYWZUZXh0KSB3aWxsIGJlIHVzZWQuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGFzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBub2RlcyByZXByZXNlbnQgdGhlIHNhbWUgcGllY2Ugb2YgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCAodGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBtYXJrdXAgKHR5cGUsIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcykgb2YgdGhpcyBub2RlIHRvXG4gICAgdGhvc2Ugb2YgYW5vdGhlci4gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBoYXZlIHRoZSBzYW1lIG1hcmt1cC5cbiAgICAqL1xuICAgIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTWFya3VwKG90aGVyLnR5cGUsIG90aGVyLmF0dHJzLCBvdGhlci5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlJ3MgbWFya3VwIGNvcnJlc3BvbmQgdG8gdGhlIGdpdmVuIHR5cGUsXG4gICAgYXR0cmlidXRlcywgYW5kIG1hcmtzLlxuICAgICovXG4gICAgaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IHR5cGUgJiZcbiAgICAgICAgICAgIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmXG4gICAgICAgICAgICBNYXJrLnNhbWVTZXQodGhpcy5tYXJrcywgbWFya3MgfHwgTWFyay5ub25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgd2l0aCB0aGUgc2FtZSBtYXJrdXAgYXMgdGhpcyBub2RlLCBjb250YWluaW5nXG4gICAgdGhlIGdpdmVuIGNvbnRlbnQgKG9yIGVtcHR5LCBpZiBubyBjb250ZW50IGlzIGdpdmVuKS5cbiAgICAqL1xuICAgIGNvcHkoY29udGVudCA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gdGhpcy5jb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSwgd2l0aCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGluc3RlYWRcbiAgICBvZiB0aGUgbm9kZSdzIG93biBtYXJrcy5cbiAgICAqL1xuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUgd2l0aCBvbmx5IHRoZSBjb250ZW50IGJldHdlZW4gdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb25zLiBJZiBgdG9gIGlzIG5vdCBnaXZlbiwgaXQgZGVmYXVsdHMgdG8gdGhlIGVuZCBvZlxuICAgIHRoZSBub2RlLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuY29udGVudC5jdXQoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLCBhbmRcbiAgICByZXR1cm4gaXQgYXMgYSBgU2xpY2VgIG9iamVjdC5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUsIGluY2x1ZGVQYXJlbnRzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5yZXNvbHZlKHRvKTtcbiAgICAgICAgbGV0IGRlcHRoID0gaW5jbHVkZVBhcmVudHMgPyAwIDogJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBub2RlLmNvbnRlbnQuY3V0KCRmcm9tLnBvcyAtIHN0YXJ0LCAkdG8ucG9zIC0gc3RhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsICRmcm9tLmRlcHRoIC0gZGVwdGgsICR0by5kZXB0aCAtIGRlcHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zIHdpdGhcbiAgICB0aGUgZ2l2ZW4gc2xpY2UuIFRoZSBzbGljZSBtdXN0ICdmaXQnLCBtZWFuaW5nIGl0cyBvcGVuIHNpZGVzXG4gICAgbXVzdCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQsIGFuZCBpdHNcbiAgICBjb250ZW50IG5vZGVzIG11c3QgYmUgdmFsaWQgY2hpbGRyZW4gZm9yIHRoZSBub2RlIHRoZXkgYXJlIHBsYWNlZFxuICAgIGludG8uIElmIGFueSBvZiB0aGlzIGlzIHZpb2xhdGVkLCBhbiBlcnJvciBvZiB0eXBlXG4gICAgW2BSZXBsYWNlRXJyb3JgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVwbGFjZUVycm9yKSBpcyB0aHJvd24uXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZSh0aGlzLnJlc29sdmUoZnJvbSksIHRoaXMucmVzb2x2ZSh0byksIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICBwb3MgLT0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGFmdGVyIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGJlZm9yZSB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG51bGwsIGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgcG9zKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY29udGVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICByZXR1cm4geyBub2RlLCBpbmRleDogaW5kZXggLSAxLCBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzb2x2ZSB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCByZXR1cm5pbmcgYW5cbiAgICBbb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVzb2x2ZWRQb3MpIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgaXRzIGNvbnRleHQuXG4gICAgKi9cbiAgICByZXNvbHZlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZUNhY2hlZCh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlTm9DYWNoZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIG1hcmsgb3IgbWFyayB0eXBlIG9jY3VycyBpbiB0aGlzIGRvY3VtZW50XG4gICAgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgYmxvY2sgKG5vbi1pbmxpbmUgbm9kZSlcbiAgICAqL1xuICAgIGdldCBpc0Jsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHRibG9jayBub2RlLCBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dGJsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBhbGxvd3MgaW5saW5lIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gaW5saW5lIG5vZGUgKGEgdGV4dCBub2RlIG9yIGEgbm9kZSB0aGF0IGNhblxuICAgIGFwcGVhciBhbW9uZyB0ZXh0KS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0lubGluZTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dCBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzVGV4dCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNMZWFmOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmUgZGlyZWN0bHlcbiAgICBlZGl0YWJsZSBjb250ZW50LiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMgYGlzTGVhZmAsIGJ1dCBjYW5cbiAgICBiZSBjb25maWd1cmVkIHdpdGggdGhlIFtgYXRvbWAgcHJvcGVydHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdG9tKVxuICAgIG9uIGEgbm9kZSdzIHNwZWMgKHR5cGljYWxseSB1c2VkIHdoZW4gdGhlIG5vZGUgaXMgZGlzcGxheWVkIGFzXG4gICAgYW4gdW5lZGl0YWJsZSBbbm9kZSB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykpLlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlIGZvciBkZWJ1Z2dpbmdcbiAgICBwdXJwb3Nlcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMudHlwZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBuYW1lICs9IFwiKFwiICsgdGhpcy5jb250ZW50LnRvU3RyaW5nSW5uZXIoKSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgbWF0Y2ggaW4gdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAqL1xuICAgIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIDAsIGluZGV4KTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBjb250ZW50TWF0Y2hBdCBvbiBhIG5vZGUgd2l0aCBpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgKGJ5XG4gICAgY2hpbGQgaW5kZXgpIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGZyYWdtZW50ICh3aGljaCBkZWZhdWx0c1xuICAgIHRvIHRoZSBlbXB0eSBmcmFnbWVudCkgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLiBZb3VcbiAgICBjYW4gb3B0aW9uYWxseSBwYXNzIGBzdGFydGAgYW5kIGBlbmRgIGluZGljZXMgaW50byB0aGVcbiAgICByZXBsYWNlbWVudCBmcmFnbWVudC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2UoZnJvbSwgdG8sIHJlcGxhY2VtZW50ID0gRnJhZ21lbnQuZW1wdHksIHN0YXJ0ID0gMCwgZW5kID0gcmVwbGFjZW1lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgb25lID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaEZyYWdtZW50KHJlcGxhY2VtZW50LCBzdGFydCwgZW5kKTtcbiAgICAgICAgbGV0IHR3byA9IG9uZSAmJiBvbmUubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhyZXBsYWNlbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYGZyb21gIHRvIGB0b2AgKGJ5IGluZGV4KSB3aXRoXG4gICAgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgICBpZiAobWFya3MgJiYgIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhtYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgJiYgc3RhcnQubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUncyBjb250ZW50IGNvdWxkIGJlIGFwcGVuZGVkIHRvIHRoaXNcbiAgICBub2RlLiBJZiB0aGF0IG5vZGUgaXMgZW1wdHksIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0cnVlIGlmIHRoZXJlXG4gICAgaXMgYXQgbGVhc3Qgb25lIG5vZGUgdHlwZSB0aGF0IGNhbiBhcHBlYXIgaW4gYm90aCBub2RlcyAodG8gYXZvaWRcbiAgICBtZXJnaW5nIGNvbXBsZXRlbHkgaW5jb21wYXRpYmxlIG5vZGVzKS5cbiAgICAqL1xuICAgIGNhbkFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FuUmVwbGFjZSh0aGlzLmNoaWxkQ291bnQsIHRoaXMuY2hpbGRDb3VudCwgb3RoZXIuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMgY29uZm9ybSB0byB0aGVcbiAgICBzY2hlbWEsIGFuZCByYWlzZSBlcnJvciB3aGVuIHRoZXkgZG8gbm90LlxuICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIHRoaXMudHlwZS5jaGVja0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvcHkgPSB0aGlzLm1hcmtzW2ldLmFkZFRvU2V0KGNvcHkpO1xuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbGxlY3Rpb24gb2YgbWFya3MgZm9yIG5vZGUgJHt0aGlzLnR5cGUubmFtZX06ICR7dGhpcy5tYXJrcy5tYXAobSA9PiBtLnR5cGUubmFtZSl9YCk7XG4gICAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jaGVjaygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKG4gPT4gbi50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBtYXJrcyA9IG51bGw7XG4gICAgICAgIGlmIChqc29uLm1hcmtzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIik7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICAgIHJldHVybiBzY2hlbWEubm9kZVR5cGUoanNvbi50eXBlKS5jcmVhdGUoanNvbi5hdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbn1cbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGF0dHJzLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnRleHQ7IH1cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKTsgfVxuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMudGV4dCwgbWFya3MpO1xuICAgIH1cbiAgICB3aXRoVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIGN1dChmcm9tID0gMCwgdG8gPSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICAgIGZvciAobGV0IGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgc3RyID0gbWFya3NbaV0udHlwZS5uYW1lICsgXCIoXCIgKyBzdHIgKyBcIilcIjtcbiAgICByZXR1cm4gc3RyO1xufVxuXG4vKipcbkluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBhIG1hdGNoIHN0YXRlIG9mIGEgbm9kZSB0eXBlJ3Ncbltjb250ZW50IGV4cHJlc3Npb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb250ZW50KSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5maW5kIG91dCB3aGV0aGVyIGZ1cnRoZXIgY29udGVudCBtYXRjaGVzIGhlcmUsIGFuZCB3aGV0aGVyIGEgZ2l2ZW5cbnBvc2l0aW9uIGlzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuKi9cbmNsYXNzIENvbnRlbnRNYXRjaCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBtYXRjaCBzdGF0ZSByZXByZXNlbnRzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuICAgICovXG4gICAgdmFsaWRFbmQpIHtcbiAgICAgICAgdGhpcy52YWxpZEVuZCA9IHZhbGlkRW5kO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcENhY2hlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHBhcnNlKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50TWF0Y2guZW1wdHk7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IGRmYShuZmEoZXhwcikpO1xuICAgICAgICBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIGEgbm9kZSB0eXBlLCByZXR1cm5pbmcgYSBtYXRjaCBhZnRlciB0aGF0IG5vZGUgaWZcbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0W2ldLm5leHQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggYSBmcmFnbWVudC4gUmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdGNoIHdoZW5cbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hGcmFnbWVudChmcmFnLCBzdGFydCA9IDAsIGVuZCA9IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgY3VyID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBjdXIgJiYgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCAhPSAwICYmIHRoaXMubmV4dFswXS50eXBlLmlzSW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgdHlwZSBhdCB0aGlzIG1hdGNoIHBvc2l0aW9uIHRoYXQgY2FuXG4gICAgYmUgZ2VuZXJhdGVkLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRUeXBlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gdGhpcy5uZXh0W2ldO1xuICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhdGlibGUob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IG90aGVyLm5leHRbal0udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIHRoZSBnaXZlbiBmcmFnbWVudCwgYW5kIGlmIHRoYXQgZmFpbHMsIHNlZSBpZiBpdCBjYW5cbiAgICBiZSBtYWRlIHRvIG1hdGNoIGJ5IGluc2VydGluZyBub2RlcyBpbiBmcm9udCBvZiBpdC4gV2hlblxuICAgIHN1Y2Nlc3NmdWwsIHJldHVybiBhIGZyYWdtZW50IG9mIGluc2VydGVkIG5vZGVzICh3aGljaCBtYXkgYmVcbiAgICBlbXB0eSBpZiBub3RoaW5nIGhhZCB0byBiZSBpbnNlcnRlZCkuIFdoZW4gYHRvRW5kYCBpcyB0cnVlLCBvbmx5XG4gICAgcmV0dXJuIGEgZnJhZ21lbnQgaWYgdGhlIHJlc3VsdGluZyBtYXRjaCBnb2VzIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZmlsbEJlZm9yZShhZnRlciwgdG9FbmQgPSBmYWxzZSwgc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbdGhpc107XG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoYWZ0ZXIsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHR5cGVzLm1hcCh0cCA9PiB0cC5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZSB0eXBlcyB0aGF0IHdvdWxkIGFsbG93IGEgbm9kZSBvZiB0aGVcbiAgICBnaXZlbiB0eXBlIHRvIGFwcGVhciBhdCB0aGlzIHBvc2l0aW9uLiBUaGUgcmVzdWx0IG1heSBiZSBlbXB0eVxuICAgICh3aGVuIGl0IGZpdHMgZGlyZWN0bHkpIGFuZCB3aWxsIGJlIG51bGwgd2hlbiBubyBzdWNoIHdyYXBwaW5nXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgZmluZFdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwQ2FjaGVbaSArIDFdO1xuICAgICAgICBsZXQgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZVdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBsZXQgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCksIGFjdGl2ZSA9IFt7IG1hdGNoOiB0aGlzLCB0eXBlOiBudWxsLCB2aWE6IG51bGwgfV07XG4gICAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLCBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzTGVhZiAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkgJiYgISh0eXBlLm5hbWUgaW4gc2VlbikgJiYgKCFjdXJyZW50LnR5cGUgfHwgbmV4dC52YWxpZEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goeyBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsIHR5cGUsIHZpYTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2Vlblt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgdGhpcyBub2RlIGhhcyBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBnZXQgZWRnZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBfbl/igIt0aCBvdXRnb2luZyBlZGdlIGZyb20gdGhpcyBub2RlIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGVkZ2Uobikge1xuICAgICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlJ3Mgbm8gJHtufXRoIGVkZ2UgaW4gdGhpcyBjb250ZW50IG1hdGNoYCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRbbl07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzZWVuID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4obS5uZXh0W2ldLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHNjYW4odGhpcyk7XG4gICAgICAgIHJldHVybiBzZWVuLm1hcCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBvdXQgKz0gKGkgPyBcIiwgXCIgOiBcIlwiKSArIG0ubmV4dFtpXS50eXBlLm5hbWUgKyBcIi0+XCIgKyBzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkNvbnRlbnRNYXRjaC5lbXB0eSA9IG5ldyBDb250ZW50TWF0Y2godHJ1ZSk7XG5jbGFzcyBUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICAgICAgICB0aGlzLmlubGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc107IH1cbiAgICBlYXQodG9rKSB7IHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpOyB9XG4gICAgZXJyKHN0cikgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7IH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU2VxKHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5uZXh0ICYmIHN0cmVhbS5uZXh0ICE9IFwiKVwiICYmIHN0cmVhbS5uZXh0ICE9IFwifFwiKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJzZXFcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgICBsZXQgZXhwciA9IHBhcnNlRXhwckF0b20oc3RyZWFtKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiK1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwicGx1c1wiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJzdGFyXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcIm9wdFwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKVxuICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICAgIGlmICgvXFxELy50ZXN0KHN0cmVhbS5uZXh0KSlcbiAgICAgICAgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIGxldCByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gICAgbGV0IG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksIG1heCA9IG1pbjtcbiAgICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ICE9IFwifVwiKVxuICAgICAgICAgICAgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4ID0gLTE7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLmVhdChcIn1cIikpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmNsb3NlZCBicmFjZWQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyYW5nZVwiLCBtaW4sIG1heCwgZXhwciB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5hbWUoc3RyZWFtLCBuYW1lKSB7XG4gICAgbGV0IHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcywgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gW3R5cGVdO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuZ3JvdXBzLmluZGV4T2YobmFtZSkgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKVxuICAgICAgICBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwckF0b20oc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIoXCIpKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWlzc2luZyBjbG9zaW5nIHBhcmVuXCIpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgICAgIGxldCBleHBycyA9IHJlc29sdmVOYW1lKHN0cmVhbSwgc3RyZWFtLm5leHQpLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uaW5saW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmlubGluZSA9IHR5cGUuaXNJbmxpbmU7XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVycihcIk1peGluZyBpbmxpbmUgYW5kIGJsb2NrIGNvbnRlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHR5cGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5wb3MrKztcbiAgICAgICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICB9XG59XG4vKipcbkNvbnN0cnVjdCBhbiBORkEgZnJvbSBhbiBleHByZXNzaW9uIGFzIHJldHVybmVkIGJ5IHRoZSBwYXJzZXIuIFRoZVxuTkZBIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHN0YXRlcywgd2hpY2ggYXJlIHRoZW1zZWx2ZXNcbmFycmF5cyBvZiBlZGdlcywgd2hpY2ggYXJlIGB7dGVybSwgdG99YCBvYmplY3RzLiBUaGUgZmlyc3Qgc3RhdGUgaXNcbnRoZSBlbnRyeSBzdGF0ZSBhbmQgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgc3VjY2VzcyBzdGF0ZS5cblxuTm90ZSB0aGF0IHVubGlrZSB0eXBpY2FsIE5GQXMsIHRoZSBlZGdlIG9yZGVyaW5nIGluIHRoaXMgb25lIGlzXG5zaWduaWZpY2FudCwgaW4gdGhhdCBpdCBpcyB1c2VkIHRvIGNvbnRydWN0IGZpbGxlciBjb250ZW50IHdoZW5cbm5lY2Vzc2FyeS5cbiovXG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICAgIGxldCBuZmEgPSBbW11dO1xuICAgIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgICByZXR1cm4gbmZhO1xuICAgIGZ1bmN0aW9uIG5vZGUoKSB7IHJldHVybiBuZmEucHVzaChbXSkgLSAxOyB9XG4gICAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgICAgICBsZXQgZWRnZSA9IHsgdGVybSwgdG8gfTtcbiAgICAgICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGVkZ2UgPT4gZWRnZS50byA9IHRvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT0gXCJjaG9pY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKChvdXQsIGV4cHIpID0+IG91dC5jb25jYXQoY29tcGlsZShleHByLCBmcm9tKSksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvbXBpbGUoZXhwci5leHByc1tpXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICBjb25uZWN0KG5leHQsIGZyb20gPSBub2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5taW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5tYXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV4cHIubWluOyBpIDwgZXhwci5tYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZShjdXIsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoY3VyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSwgdW5kZWZpbmVkLCBleHByLnZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBiIC0gYTsgfVxuLy8gR2V0IHRoZSBzZXQgb2Ygbm9kZXMgcmVhY2hhYmxlIGJ5IG51bGwgZWRnZXMgZnJvbSBgbm9kZWAuIE9taXRcbi8vIG5vZGVzIHdpdGggb25seSBhIHNpbmdsZSBudWxsLW91dC1lZGdlLCBzaW5jZSB0aGV5IG1heSBsZWFkIHRvXG4vLyBuZWVkbGVzcyBkdXBsaWNhdGVkIG5vZGVzLlxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIHNjYW4obm9kZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCk7XG4gICAgZnVuY3Rpb24gc2Nhbihub2RlKSB7XG4gICAgICAgIGxldCBlZGdlcyA9IG5mYVtub2RlXTtcbiAgICAgICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pO1xuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdGVybSwgdG8gfSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzY2FuKHRvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENvbXBpbGVzIGFuIE5GQSBhcyBwcm9kdWNlZCBieSBgbmZhYCBpbnRvIGEgREZBLCBtb2RlbGVkIGFzIGEgc2V0XG4vLyBvZiBzdGF0ZSBvYmplY3RzIChgQ29udGVudE1hdGNoYCBpbnN0YW5jZXMpIHdpdGggdHJhbnNpdGlvbnNcbi8vIGJldHdlZW4gdGhlbS5cbmZ1bmN0aW9uIGRmYShuZmEpIHtcbiAgICBsZXQgbGFiZWxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gICAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICAgICAgbGV0IG91dCA9IFtdO1xuICAgICAgICBzdGF0ZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIG5mYVtub2RlXS5mb3JFYWNoKCh7IHRlcm0sIHRvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlcm0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2ldWzBdID09IHRlcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgICAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChbdGVybSwgc2V0ID0gW11dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IG91dFtpXVsxXS5zb3J0KGNtcCk7XG4gICAgICAgICAgICBzdGF0ZS5uZXh0LnB1c2goeyB0eXBlOiBvdXRbaV1bMF0sIG5leHQ6IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSB8fCBleHBsb3JlKHN0YXRlcykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCB3b3JrID0gW21hdGNoXTsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXRlID0gd29ya1tpXSwgZGVhZCA9ICFzdGF0ZS52YWxpZEVuZCwgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5uZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBzdGF0ZS5uZXh0W2pdO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgZGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICB3b3JrLnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlYWQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiT25seSBub24tZ2VuZXJhdGFibGUgbm9kZXMgKFwiICsgbm9kZXMuam9pbihcIiwgXCIpICsgXCIpIGluIGEgcmVxdWlyZWQgcG9zaXRpb24gKHNlZSBodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNnZW5lcmF0YWJsZSlcIik7XG4gICAgfVxufVxuXG4vLyBGb3Igbm9kZSB0eXBlcyB3aGVyZSBhbGwgYXR0cnMgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgKG9yIHdoaWNoIGRvbid0XG4vLyBoYXZlIGFueSBhdHRyaWJ1dGVzKSwgYnVpbGQgdXAgYSBzaW5nbGUgcmV1c2FibGUgZGVmYXVsdCBhdHRyaWJ1dGVcbi8vIG9iamVjdCwgYW5kIHVzZSBpdCBmb3IgYWxsIG5vZGVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBzcGVjaWZpY1xuLy8gYXR0cmlidXRlcy5cbmZ1bmN0aW9uIGRlZmF1bHRBdHRycyhhdHRycykge1xuICAgIGxldCBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHIuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzLCB2YWx1ZSkge1xuICAgIGxldCBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIGdpdmVuID0gYXR0ci5kZWZhdWx0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gdmFsdWUgc3VwcGxpZWQgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWx0W25hbWVdID0gZ2l2ZW47XG4gICAgfVxuICAgIHJldHVybiBidWlsdDtcbn1cbmZ1bmN0aW9uIGluaXRBdHRycyhhdHRycykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUoYXR0cnNbbmFtZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbk5vZGUgdHlwZXMgYXJlIG9iamVjdHMgYWxsb2NhdGVkIG9uY2UgcGVyIGBTY2hlbWFgIGFuZCB1c2VkIHRvXG5bdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50eXBlKSBgTm9kZWAgaW5zdGFuY2VzLiBUaGV5IGNvbnRhaW4gaW5mb3JtYXRpb25cbmFib3V0IHRoZSBub2RlIHR5cGUsIHN1Y2ggYXMgaXRzIG5hbWUgYW5kIHdoYXQga2luZCBvZiBub2RlIGl0XG5yZXByZXNlbnRzLlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIHRoZSBub2RlIHR5cGUgaGFzIGluIHRoaXMgc2NoZW1hLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQSBsaW5rIGJhY2sgdG8gdGhlIGBTY2hlbWFgIHRoZSBub2RlIHR5cGUgYmVsb25ncyB0by5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgdGhhdCB0aGlzIHR5cGUgaXMgYmFzZWQgb25cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc2V0IG9mIG1hcmtzIGFsbG93ZWQgaW4gdGhpcyBub2RlLiBgbnVsbGAgbWVhbnMgYWxsIG1hcmtzXG4gICAgICAgIGFyZSBhbGxvd2VkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLmlubGluZUNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSAhKHNwZWMuaW5saW5lIHx8IG5hbWUgPT0gXCJ0ZXh0XCIpO1xuICAgICAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhbiBpbmxpbmUgdHlwZS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuICF0aGlzLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYSB0ZXh0YmxvY2sgdHlwZSwgYSBibG9jayB0aGF0IGNvbnRhaW5zIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLmlzQmxvY2sgJiYgdGhpcy5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBmb3Igbm9kZSB0eXBlcyB0aGF0IGFsbG93IG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZVxuICAgIGRpcmVjdGx5IGVkaXRhYmxlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgfHwgISF0aGlzLnNwZWMuYXRvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGUncyBbd2hpdGVzcGFjZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLndoaXRlc3BhY2UpIG9wdGlvbi5cbiAgICAqL1xuICAgIGdldCB3aGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLndoaXRlc3BhY2UgfHwgKHRoaXMuc3BlYy5jb2RlID8gXCJwcmVcIiA6IFwibm9ybWFsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIG5vZGUgdHlwZSBoYXMgYW55IHJlcXVpcmVkIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgICBmb3IgKGxldCBuIGluIHRoaXMuYXR0cnMpXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbm9kZSBhbGxvd3Mgc29tZSBvZiB0aGUgc2FtZSBjb250ZW50IGFzXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGNvbXBhdGlibGVDb250ZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBdHRycztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBOb2RlYCBvZiB0aGlzIHR5cGUuIFRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZVxuICAgIGNoZWNrZWQgYW5kIGRlZmF1bHRlZCAoeW91IGNhbiBwYXNzIGBudWxsYCB0byB1c2UgdGhlIHR5cGUnc1xuICAgIGRlZmF1bHRzIGVudGlyZWx5LCBpZiBubyByZXF1aXJlZCBhdHRyaWJ1dGVzIGV4aXN0KS4gYGNvbnRlbnRgXG4gICAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYSBub2RlLCBhbiBhcnJheSBvZiBub2Rlcywgb3JcbiAgICBgbnVsbGAuIFNpbWlsYXJseSBgbWFya3NgIG1heSBiZSBgbnVsbGAgdG8gZGVmYXVsdCB0byB0aGUgZW1wdHlcbiAgICBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBjaGVjayB0aGUgZ2l2ZW4gY29udGVudFxuICAgIGFnYWluc3QgdGhlIG5vZGUgdHlwZSdzIGNvbnRlbnQgcmVzdHJpY3Rpb25zLCBhbmQgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiBpdCBkb2Vzbid0IG1hdGNoLlxuICAgICovXG4gICAgY3JlYXRlQ2hlY2tlZChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgY29udGVudCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IHNlZSBpZiBpdCBpc1xuICAgIG5lY2Vzc2FyeSB0byBhZGQgbm9kZXMgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgZ2l2ZW4gZnJhZ21lbnRcbiAgICB0byBtYWtlIGl0IGZpdCB0aGUgbm9kZS4gSWYgbm8gZml0dGluZyB3cmFwcGluZyBjYW4gYmUgZm91bmQsXG4gICAgcmV0dXJuIG51bGwuIE5vdGUgdGhhdCwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcmVxdWlyZWQgbm9kZXMgY2FuXG4gICAgYWx3YXlzIGJlIGNyZWF0ZWQsIHRoaXMgd2lsbCBhbHdheXMgc3VjY2VlZCBpZiB5b3UgcGFzcyBudWxsIG9yXG4gICAgYEZyYWdtZW50LmVtcHR5YCBhcyBjb250ZW50LlxuICAgICovXG4gICAgY3JlYXRlQW5kRmlsbChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgbGV0IGFmdGVyID0gbWF0Y2hlZCAmJiBtYXRjaGVkLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyB2YWxpZCBjb250ZW50IGZvciB0aGlzIG5vZGVcbiAgICB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICB2YWxpZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyBub3QgdmFsaWQgY29udGVudCBmb3IgdGhpc1xuICAgIG5vZGUgdHlwZS5cbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb250ZW50IGZvciBub2RlICR7dGhpcy5uYW1lfTogJHtjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApfWApO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGFyZSBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIGxldCB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICAgICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgaXRzIHRvcCBub2RlIHR5cGUgKCdcIiArIHRvcFR5cGUgKyBcIicpXCIpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZXN1bHQudGV4dC5hdHRycylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICB9XG4gICAgZ2V0IGlzUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbn1cbi8vIE1hcmtzXG4vKipcbkxpa2Ugbm9kZXMsIG1hcmtzICh3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIG5vZGVzIHRvIHNpZ25pZnlcbnRoaW5ncyBsaWtlIGVtcGhhc2lzIG9yIGJlaW5nIHBhcnQgb2YgYSBsaW5rKSBhcmVcblt0YWdnZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrLnR5cGUpIHdpdGggdHlwZSBvYmplY3RzLCB3aGljaCBhcmVcbmluc3RhbnRpYXRlZCBvbmNlIHBlciBgU2NoZW1hYC5cbiovXG5jbGFzcyBNYXJrVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5rLCBcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgPyBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cykgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuICAgIGNvbnRhaW5pbmcgb25seSBzb21lIG9mIHRoZSBtYXJrJ3MgYXR0cmlidXRlcy4gVGhlIG90aGVycywgaWZcbiAgICB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gICAgICAgIG1hcmtzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4gICAgd2l0aG91dCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgc2V0IGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4gICAgW2V4Y2x1ZGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG59XG4vKipcbkEgZG9jdW1lbnQgc2NoZW1hLiBIb2xkcyBbbm9kZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlKSBhbmQgW21hcmtcbnR5cGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrVHlwZSkgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIGFuZCBtYXJrcyB0aGF0IG1heVxub2NjdXIgaW4gY29uZm9ybWluZyBkb2N1bWVudHMsIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuY3JlYXRpbmcgYW5kIGRlc2VyaWFsaXppbmcgc3VjaCBkb2N1bWVudHMuXG5cbldoZW4gZ2l2ZW4sIHRoZSB0eXBlIHBhcmFtZXRlcnMgcHJvdmlkZSB0aGUgbmFtZXMgb2YgdGhlIG5vZGVzIGFuZFxubWFya3MgaW4gdGhpcyBzY2hlbWEuXG4qL1xuY2xhc3MgU2NoZW1hIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBzY2hlbWEgZnJvbSBhIHNjaGVtYSBbc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNjaGVtYVNwZWMpLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICAvKipcbiAgICAgICAgQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gICAgICAgIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgICAgICAgaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZVNwZWMgPSB0aGlzLnNwZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKVxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjW3Byb3BdID0gc3BlY1twcm9wXTtcbiAgICAgICAgaW5zdGFuY2VTcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpLFxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcbiAgICAgICAgbGV0IGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRoaXMubWFya3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgICAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgICAgICAgICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgICAgICAgICB0eXBlLm1hcmtTZXQgPSBtYXJrRXhwciA9PSBcIl9cIiA/IG51bGwgOlxuICAgICAgICAgICAgICAgIG1hcmtFeHByID8gZ2F0aGVyTWFya3ModGhpcywgbWFya0V4cHIuc3BsaXQoXCIgXCIpKSA6XG4gICAgICAgICAgICAgICAgICAgIG1hcmtFeHByID09IFwiXCIgfHwgIXR5cGUuaW5saW5lQ29udGVudCA/IFtdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubWFya3MpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5tYXJrc1twcm9wXSwgZXhjbCA9IHR5cGUuc3BlYy5leGNsdWRlcztcbiAgICAgICAgICAgIHR5cGUuZXhjbHVkZWQgPSBleGNsID09IG51bGwgPyBbdHlwZV0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVGcm9tSlNPTiA9IHRoaXMubm9kZUZyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWFya0Zyb21KU09OID0gdGhpcy5tYXJrRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b3BOb2RlVHlwZSA9IHRoaXMubm9kZXNbdGhpcy5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIl07XG4gICAgICAgIHRoaXMuY2FjaGVkLndyYXBwaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgaW4gdGhpcyBzY2hlbWEuIFRoZSBgdHlwZWAgbWF5IGJlIGEgc3RyaW5nIG9yIGFcbiAgICBgTm9kZVR5cGVgIGluc3RhbmNlLiBBdHRyaWJ1dGVzIHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBkZWZhdWx0cyxcbiAgICBgY29udGVudGAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYG51bGxgLCBhIGBOb2RlYCwgb3IgYW4gYXJyYXkgb2ZcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIG5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm5vZGVUeXBlKHR5cGUpO1xuICAgICAgICBlbHNlIGlmICghKHR5cGUgaW5zdGFuY2VvZiBOb2RlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICBlbHNlIGlmICh0eXBlLnNjaGVtYSAhPSB0aGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgZnJvbSBkaWZmZXJlbnQgc2NoZW1hIHVzZWQgKFwiICsgdHlwZS5uYW1lICsgXCIpXCIpO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGVDaGVja2VkKGF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgbm9kZSBpbiB0aGUgc2NoZW1hLiBFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3RcbiAgICBhbGxvd2VkLlxuICAgICovXG4gICAgdGV4dCh0ZXh0LCBtYXJrcykge1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXMudGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0eXBlLCB0eXBlLmRlZmF1bHRBdHRycywgdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIG1hcmsodHlwZSwgYXR0cnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5tYXJrc1t0eXBlXTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIGlzXG4gICAgYm91bmQuXG4gICAgKi9cbiAgICBub2RlRnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIGlzXG4gICAgYm91bmQuXG4gICAgKi9cbiAgICBtYXJrRnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gTWFyay5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBub2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyTWFya3Moc2NoZW1hLCBtYXJrcykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBtYXJrc1tpXSwgbWFyayA9IHNjaGVtYS5tYXJrc1tuYW1lXSwgb2sgPSBtYXJrO1xuICAgICAgICBpZiAobWFyaykge1xuICAgICAgICAgICAgZm91bmQucHVzaChtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBzY2hlbWEubWFya3NbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgKG1hcmsuc3BlYy5ncm91cCAmJiBtYXJrLnNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpLmluZGV4T2YobmFtZSkgPiAtMSkpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gob2sgPSBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9rKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBtYXJrIHR5cGU6ICdcIiArIG1hcmtzW2ldICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQSBET00gcGFyc2VyIHJlcHJlc2VudHMgYSBzdHJhdGVneSBmb3IgcGFyc2luZyBET00gY29udGVudCBpbnRvIGFcblByb3NlTWlycm9yIGRvY3VtZW50IGNvbmZvcm1pbmcgdG8gYSBnaXZlbiBzY2hlbWEuIEl0cyBiZWhhdmlvciBpc1xuZGVmaW5lZCBieSBhbiBhcnJheSBvZiBbcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpLlxuKi9cbmNsYXNzIERPTVBhcnNlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGFyc2VyIHRoYXQgdGFyZ2V0cyB0aGUgZ2l2ZW4gc2NoZW1hLCB1c2luZyB0aGUgZ2l2ZW5cbiAgICBwYXJzaW5nIHJ1bGVzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBpbnRvIHdoaWNoIHRoZSBwYXJzZXIgcGFyc2VzLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIFtwYXJzZSBydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkgdGhhdCB0aGUgcGFyc2VyXG4gICAgdXNlcywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIHJ1bGVzKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgIGlmIChydWxlLnRhZylcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucHVzaChydWxlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc3R5bGUpXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKHIgPT4ge1xuICAgICAgICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbiAgICAqL1xuICAgIHBhcnNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2VcbiAgICBbYHBhcnNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2ZcbiAgICBvcHRpb25zLiBCdXQgdW5saWtlIHRoYXQgbWV0aG9kLCB3aGljaCBwcm9kdWNlcyBhIHdob2xlIG5vZGUsXG4gICAgdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuICAgIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4gICAgdGhlIGxlZnQgb2YgdGhlIGlucHV0IGFuZCB0aGUgZW5kIG9mIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBwYXJzZVNsaWNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFRhZyhkb20sIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMudGFnc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKGRvbSwgcnVsZS50YWcpICYmXG4gICAgICAgICAgICAgICAgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiZcbiAgICAgICAgICAgICAgICAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hTdHlsZShwcm9wLCB2YWx1ZSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuc3R5bGVzW2ldLCBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5jb250ZXh0ICYmICFjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIHN0eWxlIHN0cmluZyBlaXRoZXIgcHJlY2lzZWx5IG1hdGNoZXMgdGhlIHByb3AsXG4gICAgICAgICAgICAgICAgLy8gb3IgaGFzIGFuICc9JyBzaWduIGFmdGVyIHRoZSBwcm9wLCBmb2xsb3dlZCBieSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZW5ndGggPiBwcm9wLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGUuY2hhckNvZGVBdChwcm9wLmxlbmd0aCkgIT0gNjEgfHwgc3R5bGUuc2xpY2UocHJvcC5sZW5ndGggKyAxKSAhPSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSByZXN1bHRbaV0sIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShpLCAwLCBydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5ub2Rlc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubm9kZSB8fCBydWxlLmlnbm9yZSB8fCBydWxlLm1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ub2RlID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBET00gcGFyc2VyIHVzaW5nIHRoZSBwYXJzaW5nIHJ1bGVzIGxpc3RlZCBpbiBhXG4gICAgc2NoZW1hJ3MgW25vZGUgc3BlY3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5wYXJzZURPTSksIHJlb3JkZXJlZCBieVxuICAgIFtwcmlvcml0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZS5wcmlvcml0eSkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKHNjaGVtYSwgRE9NUGFyc2VyLnNjaGVtYVJ1bGVzKHNjaGVtYSkpKTtcbiAgICB9XG59XG5jb25zdCBibG9ja1RhZ3MgPSB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGNhbnZhczogdHJ1ZSxcbiAgICBkZDogdHJ1ZSwgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZpZ2NhcHRpb246IHRydWUsIGZpZ3VyZTogdHJ1ZSxcbiAgICBmb290ZXI6IHRydWUsIGZvcm06IHRydWUsIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSxcbiAgICBoNjogdHJ1ZSwgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBsaTogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9sOiB0cnVlLFxuICAgIG91dHB1dDogdHJ1ZSwgcDogdHJ1ZSwgcHJlOiB0cnVlLCBzZWN0aW9uOiB0cnVlLCB0YWJsZTogdHJ1ZSwgdGZvb3Q6IHRydWUsIHVsOiB0cnVlXG59O1xuY29uc3QgaWdub3JlVGFncyA9IHtcbiAgICBoZWFkOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2JqZWN0OiB0cnVlLCBzY3JpcHQ6IHRydWUsIHN0eWxlOiB0cnVlLCB0aXRsZTogdHJ1ZVxufTtcbmNvbnN0IGxpc3RUYWdzID0geyBvbDogdHJ1ZSwgdWw6IHRydWUgfTtcbi8vIFVzaW5nIGEgYml0ZmllbGQgZm9yIG5vZGUgY29udGV4dCBvcHRpb25zXG5jb25zdCBPUFRfUFJFU0VSVkVfV1MgPSAxLCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA9IDIsIE9QVF9PUEVOX0xFRlQgPSA0O1xuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV2hpdGVzcGFjZSwgYmFzZSkge1xuICAgIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8XG4gICAgICAgICAgICAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMCk7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbmNsYXNzIE5vZGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgXG4gICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGlzIG5vZGUgaXRzZWxmXG4gICAgbWFya3MsIFxuICAgIC8vIE1hcmtzIHRoYXQgY2FuJ3QgYXBwbHkgaGVyZSwgYnV0IHdpbGwgYmUgdXNlZCBpbiBjaGlsZHJlbiBpZiBwb3NzaWJsZVxuICAgIHBlbmRpbmdNYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgIC8vIE5lc3RlZCBNYXJrcyB3aXRoIHNhbWUgdHlwZVxuICAgICAgICB0aGlzLnN0YXNoTWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLCB3cmFwO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sIG07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gICAgcG9wRnJvbVN0YXNoTWFyayhtYXJrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXNoTWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAobWFyay5lcSh0aGlzLnN0YXNoTWFya3NbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXNoTWFya3Muc3BsaWNlKGksIDEpWzBdO1xuICAgIH1cbiAgICBhcHBseVBlbmRpbmcobmV4dFR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdNYXJrczsgaSA8IHBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gcGVuZGluZ1tpXTtcbiAgICAgICAgICAgIGlmICgodGhpcy50eXBlID8gdGhpcy50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkgOiBtYXJrTWF5QXBwbHkobWFyay50eXBlLCBuZXh0VHlwZSkpICYmXG4gICAgICAgICAgICAgICAgIW1hcmsuaXNJblNldCh0aGlzLmFjdGl2ZU1hcmtzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVDb250ZXh0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdLmlzSW5saW5lO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIHBhcnNlciB3ZSBhcmUgdXNpbmcuXG4gICAgcGFyc2VyLCBcbiAgICAvLyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhpcyBwYXJzZS5cbiAgICBvcHRpb25zLCBpc09wZW4pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSwgdG9wQ29udGV4dDtcbiAgICAgICAgbGV0IHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICAgICAgaWYgKHRvcE5vZGUpXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2UgaWYgKGlzT3BlbilcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0b3BDb250ZXh0XTtcbiAgICAgICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gICAgLy8gQWRkIGEgRE9NIG5vZGUgdG8gdGhlIGNvbnRlbnQuIFRleHQgaXMgaW5zZXJ0ZWQgYXMgdGV4dCBub2RlLFxuICAgIC8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cbiAgICBhZGRET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tKTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tKTtcbiAgICB9XG4gICAgd2l0aFN0eWxlUnVsZXMoZG9tLCBmKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgaWYgKCFzdHlsZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIGxldCBtYXJrcyA9IHRoaXMucmVhZFN0eWxlcyhwYXJzZVN0eWxlcyhzdHlsZSkpO1xuICAgICAgICBpZiAoIW1hcmtzKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBIHN0eWxlIHdpdGggaWdub3JlOiB0cnVlXG4gICAgICAgIGxldCBbYWRkTWFya3MsIHJlbW92ZU1hcmtzXSA9IG1hcmtzLCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0sIHRvcCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldKTtcbiAgICAgICAgZigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZE1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0pO1xuICAgIH1cbiAgICBhZGRUZXh0Tm9kZShkb20pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIHRvcCA9IHRoaXMudG9wLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5za2lwKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQWxsKGRvbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHRoaXMuYWRkQWxsKGRvbSkpO1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UgPyBydWxlSUQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBsZWFmIERPTSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBpZ25vcmVkXG4gICAgbGVhZkZhbGxiYWNrKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20pIHtcbiAgICAgICAgLy8gSWdub3JlZCBCUiBub2RlcyBzaG91bGQgYXQgbGVhc3QgY3JlYXRlIGFuIGlubGluZSBjb250ZXh0XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICghdGhpcy50b3AudHlwZSB8fCAhdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSlcbiAgICAgICAgICAgIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlIHN0eWxlc1xuICAgIC8vIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG4gICAgcmVhZFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IGFkZCA9IE1hcmsubm9uZSwgcmVtb3ZlID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSB1bmRlZmluZWQ7Oykge1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5wYXJzZXIubWF0Y2hTdHlsZShzdHlsZXNbaV0sIHN0eWxlc1tpICsgMV0sIHRoaXMsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmlnbm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcy5jb25jYXQodGhpcy50b3AuYWN0aXZlTWFya3MpLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmsobSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gbS5hZGRUb1NldChyZW1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKS5hZGRUb1NldChhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FkZCwgcmVtb3ZlXTtcbiAgICB9XG4gICAgLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4gICAgLy8gZmFsc2UuIE90aGVyd2lzZSwgYXBwbHkgaXQsIHVzZSBpdHMgcmV0dXJuIHZhbHVlIHRvIGRyaXZlIHRoZSB3YXlcbiAgICAvLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuICAgIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBjb250aW51ZUFmdGVyKSB7XG4gICAgICAgIGxldCBzeW5jLCBub2RlVHlwZSwgbWFyaztcbiAgICAgICAgaWYgKHJ1bGUubm9kZSkge1xuICAgICAgICAgICAgbm9kZVR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbcnVsZS5ub2RlXTtcbiAgICAgICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgc3luYyA9IHRoaXMuZW50ZXIobm9kZVR5cGUsIHJ1bGUuYXR0cnMgfHwgbnVsbCwgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICAgICAgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGludWVBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgY29udGludWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChub2RlID0+IHRoaXMuaW5zZXJ0Tm9kZShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudERPTSA9IGRvbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3RvcihydWxlLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKVxuICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrLCBzdGFydEluKTtcbiAgICB9XG4gICAgLy8gQWRkIGFsbCBjaGlsZCBub2RlcyBiZXR3ZWVuIGBzdGFydEluZGV4YCBhbmQgYGVuZEluZGV4YCAob3IgdGhlXG4gICAgLy8gd2hvbGUgbm9kZSwgaWYgbm90IGdpdmVuKS4gSWYgYHN5bmNgIGlzIHBhc3NlZCwgdXNlIGl0IHRvXG4gICAgLy8gc3luY2hyb25pemUgYWZ0ZXIgZXZlcnkgYmxvY2sgZWxlbWVudC5cbiAgICBhZGRBbGwocGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hZGRET00oZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4gICAgLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuICAgIC8vIG5vZGVzIHRoYXQgd2UncmUgaW4uXG4gICAgZmluZFBsYWNlKG5vZGUpIHtcbiAgICAgICAgbGV0IHJvdXRlLCBzeW5jO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBzeW5jID0gY3g7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN4LnNvbGlkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luYyhzeW5jKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuICAgIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVySW5uZXIoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbmRQbGFjZShub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRvcC5hY3RpdmVNYXJrcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlIHx8IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG5vZGUubWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbm9kZS5tYXJrc1tpXS5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhtYXJrcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gc3RhcnQgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlblxuICAgIC8vIG5lY2Vzc2FyeS5cbiAgICBlbnRlcih0eXBlLCBhdHRycywgcHJlc2VydmVXUykge1xuICAgICAgICBsZXQgb2sgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuICAgIC8vIE9wZW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZW50ZXJJbm5lcih0eXBlLCBhdHRycyA9IG51bGwsIHNvbGlkID0gZmFsc2UsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLmFwcGx5UGVuZGluZyh0eXBlKTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgICAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCB0b3AuYWN0aXZlTWFya3MsIHRvcC5wZW5kaW5nTWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMub3BlbisrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYWxsIG5vZGVzIGFib3ZlIHRoaXMub3BlbiBhcmUgZmluaXNoZWQgYW5kIGFkZGVkIHRvXG4gICAgLy8gdGhlaXIgcGFyZW50c1xuICAgIGNsb3NlRXh0cmEob3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2kgLSAxXS5jb250ZW50LnB1c2godGhpcy5ub2Rlc1tpXS5maW5pc2gob3BlbkVuZCkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKHRoaXMuaXNPcGVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKTtcbiAgICB9XG4gICAgc3luYyh0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldID09IHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBvcygpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29udGVudFtqXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5UZXh0KHRleHROb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGV4dCBzdHJpbmcgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG4gICAgbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgbGV0IHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgbGV0IHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICAgIGxldCBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gICAgICAgIGxldCBtYXRjaCA9IChpLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IChuZXh0Lm5hbWUgIT0gcGFydCAmJiBuZXh0Lmdyb3Vwcy5pbmRleE9mKHBhcnQpID09IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICAgIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgICBsZXQgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgaWYgKCRjb250ZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRQZW5kaW5nTWFyayhtYXJrKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHRoaXMudG9wLnN0YXNoTWFya3MucHVzaChmb3VuZCk7XG4gICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICB9XG4gICAgcmVtb3ZlUGVuZGluZ01hcmsobWFyaywgdXB0bykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBsZXZlbC5wZW5kaW5nTWFya3MubGFzdEluZGV4T2YobWFyayk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFzaE1hcmsgPSBsZXZlbC5wb3BGcm9tU3Rhc2hNYXJrKG1hcmspO1xuICAgICAgICAgICAgICAgIGlmIChzdGFzaE1hcmsgJiYgbGV2ZWwudHlwZSAmJiBsZXZlbC50eXBlLmFsbG93c01hcmtUeXBlKHN0YXNoTWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBzdGFzaE1hcmsuYWRkVG9TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxldmVsID09IHVwdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgZGlyZWN0bHkgbmVzdGVkIGxpc3Qgbm9kZXMgcHJvZHVjZWQgYnkgc29tZVxuLy8gdG9vbHMgYW5kIGFsbG93ZWQgYnkgYnJvd3NlcnMgdG8gbWVhbiB0aGF0IHRoZSBuZXN0ZWQgbGlzdCBpc1xuLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBpdGVtIGFib3ZlIGl0LlxuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkLCBwcmV2SXRlbSA9IG51bGw7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwibGlcIikge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBBcHBseSBhIENTUyBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAoZG9tLm1hdGNoZXMgfHwgZG9tLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLm1vek1hdGNoZXNTZWxlY3RvcikuY2FsbChkb20sIHNlbGVjdG9yKTtcbn1cbi8vIFRva2VuaXplIGEgc3R5bGUgYXR0cmlidXRlIGludG8gcHJvcGVydHkvdmFsdWUgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzdHlsZSkge1xuICAgIGxldCByZSA9IC9cXHMqKFtcXHctXSspXFxzKjpcXHMqKFteO10rKS9nLCBtLCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAobSA9IHJlLmV4ZWMoc3R5bGUpKVxuICAgICAgICByZXN1bHQucHVzaChtWzFdLCBtWzJdLnRyaW0oKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8vIFVzZWQgd2hlbiBmaW5kaW5nIGEgbWFyayBhdCB0aGUgdG9wIGxldmVsIG9mIGEgZnJhZ21lbnQgcGFyc2UuXG4vLyBDaGVja3Mgd2hldGhlciBpdCB3b3VsZCBiZSByZWFzb25hYmxlIHRvIGFwcGx5IGEgZ2l2ZW4gbWFyayB0eXBlIHRvXG4vLyBhIGdpdmVuIG5vZGUsIGJ5IGxvb2tpbmcgYXQgdGhlIHdheSB0aGUgbWFyayBvY2N1cnMgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG1hcmtNYXlBcHBseShtYXJrVHlwZSwgbm9kZVR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBub2Rlcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc2VlbiA9IFtdLCBzY2FuID0gKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gbm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NhbihwYXJlbnQuY29udGVudE1hdGNoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrLmVxKHNldFtpXSkpXG4gICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbn1cblxuLyoqXG5BIERPTSBzZXJpYWxpemVyIGtub3dzIGhvdyB0byBjb252ZXJ0IFByb3NlTWlycm9yIG5vZGVzIGFuZFxubWFya3Mgb2YgdmFyaW91cyB0eXBlcyB0byBET00gbm9kZXMuXG4qL1xuY2xhc3MgRE9NU2VyaWFsaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VyaWFsaXplci4gYG5vZGVzYCBzaG91bGQgbWFwIG5vZGUgbmFtZXMgdG8gZnVuY3Rpb25zXG4gICAgdGhhdCB0YWtlIGEgbm9kZSBhbmQgcmV0dXJuIGEgZGVzY3JpcHRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICBET00uIGBtYXJrc2AgZG9lcyB0aGUgc2FtZSBmb3IgbWFyayBuYW1lcywgYnV0IGFsc28gZ2V0cyBhblxuICAgIGFyZ3VtZW50IHRoYXQgdGVsbHMgaXQgd2hldGhlciB0aGUgbWFyaydzIGNvbnRlbnQgaXMgYmxvY2sgb3JcbiAgICBpbmxpbmUgY29udGVudCAoZm9yIHR5cGljYWwgdXNlLCBpdCdsbCBhbHdheXMgYmUgaW5saW5lKS4gQSBtYXJrXG4gICAgc2VyaWFsaXplciBtYXkgYmUgYG51bGxgIHRvIGluZGljYXRlIHRoYXQgbWFya3Mgb2YgdGhhdCB0eXBlXG4gICAgc2hvdWxkIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBub2RlcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBtYXJrcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoaXMgZnJhZ21lbnQgdG8gYSBET00gZnJhZ21lbnQuIFdoZW5cbiAgICBub3QgaW4gdGhlIGJyb3dzZXIsIHRoZSBgZG9jdW1lbnRgIG9wdGlvbiwgY29udGFpbmluZyBhIERPTVxuICAgIGRvY3VtZW50LCBzaG91bGQgYmUgcGFzc2VkIHNvIHRoYXQgdGhlIHNlcmlhbGl6ZXIgY2FuIGNyZWF0ZVxuICAgIG5vZGVzLlxuICAgICovXG4gICAgc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMgPSB7fSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRhcmdldCwgYWN0aXZlID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBrZWVwID0gMCwgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5tYXJrc1tyZW5kZXJlZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXJrc1tuZXh0LnR5cGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdWzBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKVsxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtET00gPSB0aGlzLnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKG1hcmtET00uZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZCh0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSkpO1xuICAgICAgICBpZiAoY29udGVudERPTSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIik7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VcbiAgICBuZWVkIHRvIHNlcmlhbGl6ZSBhIHBhcnQgb2YgYSBkb2N1bWVudCwgYXMgb3Bwb3NlZCB0byB0aGUgd2hvbGVcbiAgICBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuICAgIFtgc2VyaWFsaXplRnJhZ21lbnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbiAgICBpdHMgW2NvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLmNvbnRlbnQpLlxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXAgPSB0aGlzLnNlcmlhbGl6ZU1hcmsobm9kZS5tYXJrc1tpXSwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICByZXR1cm4gdG9ET00gJiYgRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbmRlciBhbiBbb3V0cHV0IHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01PdXRwdXRTcGVjKSB0byBhIERPTSBub2RlLiBJZlxuICAgIHRoZSBzcGVjIGhhcyBhIGhvbGUgKHplcm8pIGluIGl0LCBgY29udGVudERPTWAgd2lsbCBwb2ludCBhdCB0aGVcbiAgICBub2RlIHdpdGggdGhlIGhvbGUuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogc3RydWN0dXJlIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUuZG9tICYmIHN0cnVjdHVyZS5kb20ubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gICAgICAgIGxldCB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzcGFjZSA9IHRhZ05hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zbGljZShzcGFjZSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50RE9NO1xuICAgICAgICBsZXQgZG9tID0gKHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gICAgICAgIGxldCBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICAgICAgICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gbmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYWNlID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlKSwgbmFtZS5zbGljZShzcGFjZSArIDEpLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET006IGRvbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZG9tOiBpbm5lciwgY29udGVudERPTTogaW5uZXJDb250ZW50IH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMpO1xuICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERPTSA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbiAgICBwcm9wZXJ0aWVzIGluIGEgc2NoZW1hJ3Mgbm9kZSBhbmQgbWFyayBzcGVjcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbiAgICAqL1xuICAgIHN0YXRpYyBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgcmVzdWx0LnRleHQgPSBub2RlID0+IG5vZGUudGV4dDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG1hcmsgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgbGV0IHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgICAgIGlmICh0b0RPTSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-model/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* binding */ addListNodes),\n/* harmony export */   bulletList: () => (/* binding */ bulletList),\n/* harmony export */   liftListItem: () => (/* binding */ liftListItem),\n/* harmony export */   listItem: () => (/* binding */ listItem),\n/* harmony export */   orderedList: () => (/* binding */ orderedList),\n/* harmony export */   sinkListItem: () => (/* binding */ sinkListItem),\n/* harmony export */   splitListItem: () => (/* binding */ splitListItem),\n/* harmony export */   wrapInList: () => (/* binding */ wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1 } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range)\n            return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0)\n                return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount)\n                range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n        if (!wrap)\n            return false;\n        if (dispatch)\n            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let after = tr.mapping.map(end, -1) - 1;\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, after))\n        tr.join(after);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty)))\n        .append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RztBQUN4QztBQUNqQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxjQUFjO0FBQ3BDLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDO0FBQ2xGLHVDQUF1Qyx5Q0FBeUM7QUFDaEYsbUNBQW1DLHNCQUFzQjtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBUztBQUN0QztBQUNBLDRCQUE0Qix3REFBUztBQUNyQztBQUNBO0FBQ0EsbUJBQW1CLG1FQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQVE7QUFDMUIsc0NBQXNDLFFBQVE7QUFDOUMsa0JBQWtCLHVEQUFRO0FBQzFCLGdCQUFnQixvRUFBaUIsNEVBQTRFLG9EQUFLO0FBQ2xIO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxPQUFPO0FBQzVFLHNCQUFzQiwrREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUUsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUTtBQUMzQztBQUNBLCtFQUErRSxvREFBSztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQ0FBb0Msd0RBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQyxVQUFVLGdCQUFnQjtBQUMzRyxhQUFhLCtEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBaUIseUNBQXlDLG9EQUFLLENBQUMsdURBQVE7QUFDNUYsb0JBQW9CLHdEQUFTO0FBQzdCO0FBQ0EsbUJBQW1CLGlFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE9BQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Ryx1REFBUSxTQUFTLHVEQUFRO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0VBQWlCLDJFQUEyRSxvREFBSyxZQUFZLHVEQUFRLFNBQVMsdURBQVEsZ0JBQWdCLHVEQUFRO0FBQzlLLHdCQUF3Qix1REFBUSxTQUFTLHVEQUFRLGdCQUFnQix1REFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBUTtBQUNoQyw0QkFBNEIsb0RBQUssQ0FBQyx1REFBUSw0QkFBNEIsdURBQVE7QUFDOUU7QUFDQSx1Q0FBdUMsb0VBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguanM/Mzk0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxIH0gfSxcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcIm9sXCIsIGdldEF0dHJzKGRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG9yZGVyOiBkb20uaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyArZG9tLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIDogMSB9O1xuICAgICAgICAgICAgfSB9XSxcbiAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJzLm9yZGVyID09IDEgPyBvbERPTSA6IFtcIm9sXCIsIHsgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXIgfSwgMF07XG4gICAgfVxufTtcbi8qKlxuQSBidWxsZXQgbGlzdCBub2RlIHNwZWMsIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDx1bD5gLlxuKi9cbmNvbnN0IGJ1bGxldExpc3QgPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJ1bFwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gdWxET007IH1cbn07XG4vKipcbkEgbGlzdCBpdGVtIChgPGxpPmApIHNwZWMuXG4qL1xuY29uc3QgbGlzdEl0ZW0gPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJsaVwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gbGlET007IH0sXG4gICAgZGVmaW5pbmc6IHRydWVcbn07XG5mdW5jdGlvbiBhZGQob2JqLCBwcm9wcykge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcylcbiAgICAgICAgY29weVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLyoqXG5Db252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxpc3QtcmVsYXRlZCBub2RlIHR5cGVzIHRvIGEgbWFwXG5zcGVjaWZ5aW5nIHRoZSBub2RlcyBmb3IgYSBzY2hlbWEuIEFkZHNcbltgb3JkZXJlZExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Qub3JkZXJlZExpc3QpIGFzIGBcIm9yZGVyZWRfbGlzdFwiYCxcbltgYnVsbGV0TGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5idWxsZXRMaXN0KSBhcyBgXCJidWxsZXRfbGlzdFwiYCwgYW5kXG5bYGxpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lmxpc3RJdGVtKSBhcyBgXCJsaXN0X2l0ZW1cImAuXG5cbmBpdGVtQ29udGVudGAgZGV0ZXJtaW5lcyB0aGUgY29udGVudCBleHByZXNzaW9uIGZvciB0aGUgbGlzdCBpdGVtcy5cbklmIHlvdSB3YW50IHRoZSBjb21tYW5kcyBkZWZpbmVkIGluIHRoaXMgbW9kdWxlIHRvIGFwcGx5IHRvIHlvdXJcbmxpc3Qgc3RydWN0dXJlLCBpdCBzaG91bGQgaGF2ZSBhIHNoYXBlIGxpa2UgYFwicGFyYWdyYXBoIGJsb2NrKlwiYCBvclxuYFwicGFyYWdyYXBoIChvcmRlcmVkX2xpc3QgfCBidWxsZXRfbGlzdCkqXCJgLiBgbGlzdEdyb3VwYCBjYW4gYmVcbmdpdmVuIHRvIGFzc2lnbiBhIGdyb3VwIG5hbWUgdG8gdGhlIGxpc3Qgbm9kZSB0eXBlcywgZm9yIGV4YW1wbGVcbmBcImJsb2NrXCJgLlxuKi9cbmZ1bmN0aW9uIGFkZExpc3ROb2Rlcyhub2RlcywgaXRlbUNvbnRlbnQsIGxpc3RHcm91cCkge1xuICAgIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgICAgICBvcmRlcmVkX2xpc3Q6IGFkZChvcmRlcmVkTGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgYnVsbGV0X2xpc3Q6IGFkZChidWxsZXRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBsaXN0X2l0ZW06IGFkZChsaXN0SXRlbSwgeyBjb250ZW50OiBpdGVtQ29udGVudCB9KVxuICAgIH0pO1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzZWxlY3Rpb24gaW4gYSBsaXN0IHdpdGhcbnRoZSBnaXZlbiB0eXBlIGFuIGF0dHJpYnV0ZXMuIElmIGBkaXNwYXRjaGAgaXMgbnVsbCwgb25seSByZXR1cm4gYVxudmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGlzIHBvc3NpYmxlLCBidXQgZG9uJ3QgYWN0dWFsbHlcbnBlcmZvcm0gdGhlIGNoYW5nZS5cbiovXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBpcyBhdCB0aGUgdG9wIG9mIGFuIGV4aXN0aW5nIGxpc3QgaXRlbVxuICAgICAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleChyYW5nZS5kZXB0aCAtIDEpID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRpbnNlcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCBzdGF0ZS5kb2MucmVzb2x2ZSgkdG8uZW5kKHJhbmdlLmRlcHRoKSksIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGRvSm9pbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXAgPSBmaW5kV3JhcHBpbmcob3V0ZXJSYW5nZSwgbGlzdFR5cGUsIGF0dHJzLCByYW5nZSk7XG4gICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdFR5cGUpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChyYW5nZS5zdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCByYW5nZS5lbmQsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gICAgbGV0IGZvdW5kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PSBsaXN0VHlwZSlcbiAgICAgICAgICAgIGZvdW5kID0gaSArIDE7XG4gICAgbGV0IHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZDtcbiAgICBsZXQgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlLnN0YXJ0SW5kZXgsIGUgPSByYW5nZS5lbmRJbmRleCwgZmlyc3QgPSB0cnVlOyBpIDwgZTsgaSsrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZmlyc3QgJiYgY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgICAgICAgIHNwbGl0UG9zICs9IDIgKiBzcGxpdERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuLyoqXG5CdWlsZCBhIGNvbW1hbmQgdGhhdCBzcGxpdHMgYSBub24tZW1wdHkgdGV4dGJsb2NrIGF0IHRoZSB0b3AgbGV2ZWxcbm9mIGEgbGlzdCBpdGVtIGJ5IGFsc28gc3BsaXR0aW5nIHRoYXQgbGlzdCBpdGVtLlxuKi9cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8sIG5vZGUgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fFxuICAgICAgICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZC0tKVxuICAgICAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMVxuICAgICAgICAgICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICAgICAgbGV0IHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8geyB0eXBlOiBpdGVtVHlwZSwgYXR0cnM6IGl0ZW1BdHRycyB9IDogbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCBhZnRlciA9IHRyLm1hcHBpbmcubWFwKGVuZCwgLTEpIC0gMTtcbiAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGFmdGVyKSlcbiAgICAgICAgdHIuam9pbihhZnRlcik7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgd3JhcEluTGlzdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-schema-list/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* binding */ AllSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   NodeSelection: () => (/* binding */ NodeSelection),\n/* harmony export */   Plugin: () => (/* binding */ Plugin),\n/* harmony export */   PluginKey: () => (/* binding */ PluginKey),\n/* harmony export */   Selection: () => (/* binding */ Selection),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   TextSelection: () => (/* binding */ TextSelection),\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection's head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError(\"Invalid input for Selection.fromJSON\");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        super.replace(tr, content);\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\")\n            throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: \"all\" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == \"string\" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc(\"doc\", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc(\"selection\", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc(\"storedMarks\", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta(\"appendedTransaction\", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError(\"Applying a mismatched transaction\");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == 'object')\n            for (let prop in pluginFields) {\n                if (prop == \"doc\" || prop == \"selection\")\n                    throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n        if (!config.schema)\n            throw new RangeError(\"Required config field 'schema' missing\");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == \"doc\") {\n                instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == \"selection\") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == \"storedMarks\") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == \"handleDOMEvents\")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUNrQjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0Msa0JBQWtCLGFBQWE7QUFDL0IsOEVBQThFLG9EQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQUs7QUFDL0I7QUFDQSx1QkFBdUIsb0RBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFLLENBQUMsdURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFLO0FBQy9CLHVCQUF1QixvREFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3Q0FBd0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFXLG9CQUFvQixvRUFBaUI7QUFDMUU7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0REFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkksbURBQUk7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFpRTtBQUN4RixvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLDZEQUE2RDtBQUM5RixvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRCx5Q0FBeUM7QUFDekMsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQ0FBZ0M7QUFDNUUsb0RBQW9ELGlDQUFpQyxJQUFJLG1CQUFtQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFOEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcz9lMjU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCwgTWFyaywgTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFJlcGxhY2VTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgY2xhc3Nlc0J5SWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5TdXBlcmNsYXNzIGZvciBlZGl0b3Igc2VsZWN0aW9ucy4gRXZlcnkgc2VsZWN0aW9uIHR5cGUgc2hvdWxkXG5leHRlbmQgdGhpcy4gU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4qL1xuY2xhc3MgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBJbml0aWFsaXplIGEgc2VsZWN0aW9uIHdpdGggdGhlIGhlYWQgYW5kIGFuY2hvciBhbmQgcmFuZ2VzLiBJZiBub1xuICAgIHJhbmdlcyBhcmUgZ2l2ZW4sIGNvbnN0cnVjdHMgYSBzaW5nbGUgcmFuZ2UgYWNyb3NzIGAkYW5jaG9yYCBhbmRcbiAgICBgJGhlYWRgLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGFuY2hvciBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IHN0YXlzIGluXG4gICAgcGxhY2Ugd2hlbiB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRhbmNob3IsIFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBoZWFkIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgbW92ZXMgd2hlblxuICAgIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGhlYWQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLiRhbmNob3IgPSAkYW5jaG9yO1xuICAgICAgICB0aGlzLiRoZWFkID0gJGhlYWQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzIHx8IFtuZXcgU2VsZWN0aW9uUmFuZ2UoJGFuY2hvci5taW4oJGhlYWQpLCAkYW5jaG9yLm1heCgkaGVhZCkpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGFuY2hvciwgYXMgYW4gdW5yZXNvbHZlZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuJGhlYWQucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLiRmcm9tLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuJHRvLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBsb3dlciAgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJGZyb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kZnJvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICR0bygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiR0bztcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjb250YWlucyBhbnkgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChyYW5nZXNbaV0uJGZyb20ucG9zICE9IHJhbmdlc1tpXS4kdG8ucG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBvZiB0aGlzIHNlbGVjdGlvbiBhcyBhIHNsaWNlLlxuICAgICovXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZyb20uZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgc2xpY2Ugb3IsIGlmIG5vIHNsaWNlIGlzIGdpdmVuLFxuICAgIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLiBXaWxsIGFwcGVuZCB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgLy8gUHV0IHRoZSBuZXcgc2VsZWN0aW9uIGF0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gY29udGVudC4gV2hlbiB0aGF0IGVuZGVkIGluIGFuIGlubGluZSBub2RlLCBzZWFyY2ggYmFja3dhcmRzLFxuICAgICAgICAvLyB0byBnZXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS4gSWYgbm90LCBzZWFyY2ggZm9yd2FyZC5cbiAgICAgICAgbGV0IGxhc3ROb2RlID0gY29udGVudC5jb250ZW50Lmxhc3RDaGlsZCwgbGFzdFBhcmVudCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5vcGVuRW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxhc3RQYXJlbnQgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2UobWFwcGluZy5tYXAoJGZyb20ucG9zKSwgbWFwcGluZy5tYXAoJHRvLnBvcyksIGkgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgKGxhc3ROb2RlID8gbGFzdE5vZGUuaXNJbmxpbmUgOiBsYXN0UGFyZW50ICYmIGxhc3RQYXJlbnQuaXNUZXh0YmxvY2spID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZSwgYXBwZW5kaW5nIHRoZSBjaGFuZ2VzXG4gICAgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoJGZyb20ucG9zKSwgdG8gPSBtYXBwaW5nLm1hcCgkdG8ucG9zKTtcbiAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIG5vZGUuaXNJbmxpbmUgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBzdGFydGluZyBhdCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBhbmQgc2VhcmNoaW5nIGJhY2sgaWYgYGRpcmAgaXMgbmVnYXRpdmUsIGFuZCBmb3J3YXJkIGlmXG4gICAgcG9zaXRpdmUuIFdoZW4gYHRleHRPbmx5YCBpcyB0cnVlLCBvbmx5IGNvbnNpZGVyIGN1cnNvclxuICAgIHNlbGVjdGlvbnMuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiBubyB2YWxpZCBzZWxlY3Rpb24gcG9zaXRpb24gaXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbSgkcG9zLCBkaXIsIHRleHRPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGlubmVyID0gJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCA/IG5ldyBUZXh0U2VsZWN0aW9uKCRwb3MpXG4gICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3MucGFyZW50LCAkcG9zLnBvcywgJHBvcy5pbmRleCgpLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGggLSAxOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBkaXIgPCAwXG4gICAgICAgICAgICAgICAgPyBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmJlZm9yZShkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSwgZGlyLCB0ZXh0T25seSlcbiAgICAgICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYWZ0ZXIoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCkgKyAxLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBuZWFyIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLiBTZWFyY2hlcyBmb3J3YXJkIGZpcnN0IGJ5IGRlZmF1bHQsIGJ1dCBpZiBgYmlhc2AgaXNcbiAgICBuZWdhdGl2ZSwgaXQgd2lsbCBzZWFyY2ggYmFja3dhcmRzIGZpcnN0LlxuICAgICovXG4gICAgc3RhdGljIG5lYXIoJHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEZyb20oJHBvcywgYmlhcykgfHwgdGhpcy5maW5kRnJvbSgkcG9zLCAtYmlhcykgfHwgbmV3IEFsbFNlbGVjdGlvbigkcG9zLm5vZGUoMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBzdGFydCBvZlxuICAgIHRoZSBnaXZlbiBkb2N1bWVudC4gV2lsbCByZXR1cm4gYW5cbiAgICBbYEFsbFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5BbGxTZWxlY3Rpb24pIGlmIG5vIHZhbGlkIHBvc2l0aW9uXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgc3RhdGljIGF0U3RhcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIDAsIDAsIDEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGF0RW5kKGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCBkb2MuY29udGVudC5zaXplLCBkb2MuY2hpbGRDb3VudCwgLTEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rpb24uIE11c3QgYmVcbiAgICBpbXBsZW1lbnRlZCBmb3IgY3VzdG9tIGNsYXNzZXMgKGFzIGEgc3RhdGljIGNsYXNzIG1ldGhvZCkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi50eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBjbHMgPSBjbGFzc2VzQnlJZFtqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIWNscylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzZWxlY3Rpb24gdHlwZSAke2pzb24udHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gY2xzLmZyb21KU09OKGRvYywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGVzZXJpYWxpemUgc2VsZWN0aW9ucyBmcm9tIEpTT04sIGN1c3RvbSBzZWxlY3Rpb25cbiAgICBjbGFzc2VzIG11c3QgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIGFuIElEIHN0cmluZywgc28gdGhhdCB0aGV5XG4gICAgY2FuIGJlIGRpc2FtYmlndWF0ZWQuIFRyeSB0byBwaWNrIHNvbWV0aGluZyB0aGF0J3MgdW5saWtlbHkgdG9cbiAgICBjbGFzaCB3aXRoIGNsYXNzZXMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc2VsZWN0aW9uQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIGNsYXNzZXNCeUlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHNlbGVjdGlvbiBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBjbGFzc2VzQnlJZFtpZF0gPSBzZWxlY3Rpb25DbGFzcztcbiAgICAgICAgc2VsZWN0aW9uQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQ2xhc3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtib29rbWFya10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbkJvb2ttYXJrKSBmb3IgdGhpcyBzZWxlY3Rpb24sXG4gICAgd2hpY2ggaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBtYXBwZWQgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvIGFcbiAgICBjdXJyZW50IGRvY3VtZW50LCBhbmQgbGF0ZXIgcmVzb2x2ZWQgdG8gYSByZWFsIHNlbGVjdGlvbiBmb3IgYVxuICAgIGdpdmVuIGRvY3VtZW50IGFnYWluLiAoVGhpcyBpcyB1c2VkIG1vc3RseSBieSB0aGUgaGlzdG9yeSB0b1xuICAgIHRyYWNrIGFuZCByZXN0b3JlIG9sZCBzZWxlY3Rpb25zLikgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2ZcbiAgICB0aGlzIG1ldGhvZCBqdXN0IGNvbnZlcnRzIHRoZSBzZWxlY3Rpb24gdG8gYSB0ZXh0IHNlbGVjdGlvbiBhbmRcbiAgICByZXR1cm5zIHRoZSBib29rbWFyayBmb3IgdGhhdC5cbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKHRoaXMuJGFuY2hvciwgdGhpcy4kaGVhZCkuZ2V0Qm9va21hcmsoKTtcbiAgICB9XG59XG5TZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSB0cnVlO1xuLyoqXG5SZXByZXNlbnRzIGEgc2VsZWN0ZWQgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2UuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkdG8pIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICB9XG59XG5sZXQgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjaGVja1RleHRTZWxlY3Rpb24oJHBvcykge1xuICAgIGlmICghd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uICYmICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiVGV4dFNlbGVjdGlvbiBlbmRwb2ludCBub3QgcG9pbnRpbmcgaW50byBhIG5vZGUgd2l0aCBpbmxpbmUgY29udGVudCAoXCIgKyAkcG9zLnBhcmVudC50eXBlLm5hbWUgKyBcIilcIik7XG4gICAgfVxufVxuLyoqXG5BIHRleHQgc2VsZWN0aW9uIHJlcHJlc2VudHMgYSBjbGFzc2ljYWwgZWRpdG9yIHNlbGVjdGlvbiwgd2l0aCBhXG5oZWFkICh0aGUgbW92aW5nIHNpZGUpIGFuZCBhbmNob3IgKGltbW9iaWxlIHNpZGUpLCBib3RoIG9mIHdoaWNoXG5wb2ludCBpbnRvIHRleHRibG9jayBub2Rlcy4gSXQgY2FuIGJlIGVtcHR5IChhIHJlZ3VsYXIgY3Vyc29yXG5wb3NpdGlvbikuXG4qL1xuY2xhc3MgVGV4dFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdGV4dCBzZWxlY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJGFuY2hvciwgJGhlYWQgPSAkYW5jaG9yKSB7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkYW5jaG9yKTtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRoZWFkKTtcbiAgICAgICAgc3VwZXIoJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmVzb2x2ZWQgcG9zaXRpb24gaWYgdGhpcyBpcyBhIGN1cnNvciBzZWxlY3Rpb24gKGFuXG4gICAgZW1wdHkgdGV4dCBzZWxlY3Rpb24pLCBhbmQgbnVsbCBvdGhlcndpc2UuXG4gICAgKi9cbiAgICBnZXQgJGN1cnNvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3MgPT0gdGhpcy4kaGVhZC5wb3MgPyB0aGlzLiRoZWFkIDogbnVsbDsgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQpO1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJGFuY2hvciA6ICRoZWFkLCAkaGVhZCk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuJGZyb20ubWFya3NBY3Jvc3ModGhpcy4kdG8pO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFRleHRTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKCRhbmNob3IsIGhlYWQgPT0gYW5jaG9yID8gJGFuY2hvciA6IGRvYy5yZXNvbHZlKGhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgdGV4dCBzZWxlY3Rpb24gdGhhdCBzcGFucyB0aGUgZ2l2ZW4gcG9zaXRpb25zIG9yLCBpZlxuICAgIHRoZXkgYXJlbid0IHRleHQgcG9zaXRpb25zLCBmaW5kIGEgdGV4dCBzZWxlY3Rpb24gbmVhciB0aGVtLlxuICAgIGBiaWFzYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1ldGhvZCBzZWFyY2hlcyBmb3J3YXJkIChkZWZhdWx0KVxuICAgIG9yIGJhY2t3YXJkcyAobmVnYXRpdmUgbnVtYmVyKSBmaXJzdC4gV2lsbCBmYWxsIGJhY2sgdG8gY2FsbGluZ1xuICAgIFtgU2VsZWN0aW9uLm5lYXJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uXm5lYXIpIHdoZW4gdGhlIGRvY3VtZW50XG4gICAgZG9lc24ndCBjb250YWluIGEgdmFsaWQgdGV4dCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBiZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgICAgIGxldCBkUG9zID0gJGFuY2hvci5wb3MgLSAkaGVhZC5wb3M7XG4gICAgICAgIGlmICghYmlhcyB8fCBkUG9zKVxuICAgICAgICAgICAgYmlhcyA9IGRQb3MgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCBiaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIC1iaWFzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAkaGVhZCA9IGZvdW5kLiRoZWFkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoZFBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9IChTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgLWJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCBiaWFzLCB0cnVlKSkuJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAoKCRhbmNob3IucG9zIDwgJGhlYWQucG9zKSAhPSAoZFBvcyA8IDApKVxuICAgICAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwidGV4dFwiLCBUZXh0U2VsZWN0aW9uKTtcbmNsYXNzIFRleHRCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgZG9jLnJlc29sdmUodGhpcy5oZWFkKSk7XG4gICAgfVxufVxuLyoqXG5BIG5vZGUgc2VsZWN0aW9uIGlzIGEgc2VsZWN0aW9uIHRoYXQgcG9pbnRzIGF0IGEgc2luZ2xlIG5vZGUuIEFsbFxubm9kZXMgbWFya2VkIFtzZWxlY3RhYmxlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuc2VsZWN0YWJsZSkgY2FuIGJlIHRoZVxudGFyZ2V0IG9mIGEgbm9kZSBzZWxlY3Rpb24uIEluIHN1Y2ggYSBzZWxlY3Rpb24sIGBmcm9tYCBhbmQgYHRvYFxucG9pbnQgZGlyZWN0bHkgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0ZWQgbm9kZSwgYGFuY2hvcmAgZXF1YWxzXG5gZnJvbWAsIGFuZCBgaGVhZGAgZXF1YWxzIGB0b2AuLlxuKi9cbmNsYXNzIE5vZGVTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uLiBEb2VzIG5vdCB2ZXJpZnkgdGhlIHZhbGlkaXR5IG9mIGl0c1xuICAgIGFyZ3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBsZXQgJGVuZCA9ICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHN1cGVyKCRwb3MsICRlbmQpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIGlmIChkZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0aGlzLm5vZGUpLCAwLCAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3I7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJub2RlXCIsIGFuY2hvcjogdGhpcy5hbmNob3IgfTtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgTm9kZUJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGVTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZnJvbSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgbWF5IGJlIHNlbGVjdGVkIGFzIGEgbm9kZVxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBpc1NlbGVjdGFibGUobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuaXNUZXh0ICYmIG5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbn1cbk5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblNlbGVjdGlvbi5qc29uSUQoXCJub2RlXCIsIE5vZGVTZWxlY3Rpb24pO1xuY2xhc3MgTm9kZUJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG5ldyBUZXh0Qm9va21hcmsocG9zLCBwb3MpIDogbmV3IE5vZGVCb29rbWFyayhwb3MpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBpZiAobm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbi8qKlxuQSBzZWxlY3Rpb24gdHlwZSB0aGF0IHJlcHJlc2VudHMgc2VsZWN0aW5nIHRoZSB3aG9sZSBkb2N1bWVudFxuKHdoaWNoIGNhbiBub3QgbmVjZXNzYXJpbHkgYmUgZXhwcmVzc2VkIHdpdGggYSB0ZXh0IHNlbGVjdGlvbiwgd2hlblxudGhlcmUgYXJlIGZvciBleGFtcGxlIGxlYWYgYmxvY2sgbm9kZXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGVcbmRvY3VtZW50KS5cbiovXG5jbGFzcyBBbGxTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBhbGwtc2VsZWN0aW9uIG92ZXIgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHN1cGVyKGRvYy5yZXNvbHZlKDApLCBkb2MucmVzb2x2ZShkb2MuY29udGVudC5zaXplKSk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgdHIuZGVsZXRlKDAsIHRyLmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IHNlbCA9IFNlbGVjdGlvbi5hdFN0YXJ0KHRyLmRvYyk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lcSh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkgeyByZXR1cm4geyB0eXBlOiBcImFsbFwiIH07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIG1hcChkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbjsgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gQWxsQm9va21hcms7IH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJhbGxcIiwgQWxsU2VsZWN0aW9uKTtcbmNvbnN0IEFsbEJvb2ttYXJrID0ge1xuICAgIG1hcCgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgcmVzb2x2ZShkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxufTtcbi8vIEZJWE1FIHdlJ2xsIG5lZWQgc29tZSBhd2FyZW5lc3Mgb2YgdGV4dCBkaXJlY3Rpb24gd2hlbiBzY2FubmluZyBmb3Igc2VsZWN0aW9uc1xuLy8gVHJ5IHRvIGZpbmQgYSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBnaXZlbiBub2RlLiBgcG9zYCBwb2ludHMgYXQgdGhlXG4vLyBwb3NpdGlvbiB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy4gV2hlbiBgdGV4dGAgaXMgdHJ1ZSwgb25seSByZXR1cm5cbi8vIHRleHQgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rpb25Jbihkb2MsIG5vZGUsIHBvcywgaW5kZXgsIGRpciwgdGV4dCA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAoZGlyID4gMCA/IDAgOiAxKTsgZGlyID4gMCA/IGkgPCBub2RlLmNoaWxkQ291bnQgOiBpID49IDA7IGkgKz0gZGlyKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSk7XG4gICAgICAgIGlmICghY2hpbGQuaXNBdG9tKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kU2VsZWN0aW9uSW4oZG9jLCBjaGlsZCwgcG9zICsgZGlyLCBkaXIgPCAwID8gY2hpbGQuY2hpbGRDb3VudCA6IDAsIGRpciwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0ZXh0ICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zIC0gKGRpciA8IDAgPyBjaGlsZC5ub2RlU2l6ZSA6IDApKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemUgKiBkaXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gICAgbGV0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0IDwgc3RhcnRMZW4pXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XSwgZW5kO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHsgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBuZXdUbzsgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuY29uc3QgVVBEQVRFRF9TRUwgPSAxLCBVUERBVEVEX01BUktTID0gMiwgVVBEQVRFRF9TQ1JPTEwgPSA0O1xuLyoqXG5BbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGEgc3RhdGUgdG9cbmNyZWF0ZSBhbiB1cGRhdGVkIHN0YXRlLiBVc2VcbltgRWRpdG9yU3RhdGUudHJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudHIpIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZS5cblxuVHJhbnNhY3Rpb25zIHRyYWNrIGNoYW5nZXMgdG8gdGhlIGRvY3VtZW50ICh0aGV5IGFyZSBhIHN1YmNsYXNzIG9mXG5bYFRyYW5zZm9ybWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtKSksIGJ1dCBhbHNvIG90aGVyIHN0YXRlIGNoYW5nZXMsXG5saWtlIHNlbGVjdGlvbiB1cGRhdGVzIGFuZCBhZGp1c3RtZW50cyBvZiB0aGUgc2V0IG9mIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpLiBJbiBhZGRpdGlvbiwgeW91IGNhbiBzdG9yZVxubWV0YWRhdGEgcHJvcGVydGllcyBpbiBhIHRyYW5zYWN0aW9uLCB3aGljaCBhcmUgZXh0cmEgcGllY2VzIG9mXG5pbmZvcm1hdGlvbiB0aGF0IGNsaWVudCBjb2RlIG9yIHBsdWdpbnMgY2FuIHVzZSB0byBkZXNjcmliZSB3aGF0IGFcbnRyYW5zYWN0aW9uIHJlcHJlc2VudHMsIHNvIHRoYXQgdGhleSBjYW4gdXBkYXRlIHRoZWlyIFtvd25cbnN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCkgYWNjb3JkaW5nbHkuXG5cblRoZSBbZWRpdG9yIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcpIHVzZXMgYSBmZXcgbWV0YWRhdGFcbnByb3BlcnRpZXM6IGl0IHdpbGwgYXR0YWNoIGEgcHJvcGVydHkgYFwicG9pbnRlclwiYCB3aXRoIHRoZSB2YWx1ZVxuYHRydWVgIHRvIHNlbGVjdGlvbiB0cmFuc2FjdGlvbnMgZGlyZWN0bHkgY2F1c2VkIGJ5IG1vdXNlIG9yIHRvdWNoXG5pbnB1dCwgYSBgXCJjb21wb3NpdGlvblwiYCBwcm9wZXJ0eSBob2xkaW5nIGFuIElEIGlkZW50aWZ5aW5nIHRoZVxuY29tcG9zaXRpb24gdGhhdCBjYXVzZWQgaXQgdG8gdHJhbnNhY3Rpb25zIGNhdXNlZCBieSBjb21wb3NlZCBET01cbmlucHV0LCBhbmQgYSBgXCJ1aUV2ZW50XCJgIHByb3BlcnR5IG9mIHRoYXQgbWF5IGJlIGBcInBhc3RlXCJgLFxuYFwiY3V0XCJgLCBvciBgXCJkcm9wXCJgLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKHN0YXRlLmRvYyk7XG4gICAgICAgIC8vIFRoZSBzdGVwIGNvdW50IGZvciB3aGljaCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgdmFsaWQuXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gMDtcbiAgICAgICAgLy8gQml0ZmllbGQgdG8gdHJhY2sgd2hpY2ggYXNwZWN0cyBvZiB0aGUgc3RhdGUgd2VyZSB1cGRhdGVkIGJ5XG4gICAgICAgIC8vIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICAgIC8vIE9iamVjdCB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy5tZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFRoaXMgZGVmYXVsdHMgdG8gdGhlIGVkaXRvclxuICAgIHNlbGVjdGlvbiBbbWFwcGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uLm1hcCkgdGhyb3VnaCB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNhY3Rpb24sIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gd2l0aFxuICAgIFtgc2V0U2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldFNlbGVjdGlvbikuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJTZWxlY3Rpb25Gb3IgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSB0aGlzLmN1clNlbGVjdGlvbi5tYXAodGhpcy5kb2MsIHRoaXMubWFwcGluZy5zbGljZSh0aGlzLmN1clNlbGVjdGlvbkZvcikpO1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJTZWxlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCBkZXRlcm1pbmUgdGhlXG4gICAgc2VsZWN0aW9uIHRoYXQgdGhlIGVkaXRvciBnZXRzIHdoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFwcGxpZWQuXG4gICAgKi9cbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20uZG9jICE9IHRoaXMuZG9jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcGFzc2VkIHRvIHNldFNlbGVjdGlvbiBtdXN0IHBvaW50IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50XCIpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gKHRoaXMudXBkYXRlZCB8IFVQREFURURfU0VMKSAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSB1cGRhdGVkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0VMKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgY3VycmVudCBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBzZXRTdG9yZWRNYXJrcyhtYXJrcykge1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX01BUktTO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcyBvciwgaWYgdGhhdCBpcyBudWxsLCB0aGUgbWFya3NcbiAgICBhdCB0aGUgc2VsZWN0aW9uLCBtYXRjaCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLiBEb2VzIG5vdGhpbmcgaWZcbiAgICB0aGlzIGlzIGFscmVhZHkgdGhlIGNhc2UuXG4gICAgKi9cbiAgICBlbnN1cmVNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCksIG1hcmtzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0U3RvcmVkTWFya3MobWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIGFkZFN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLmFkZFRvU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIG9yIG1hcmsgdHlwZSBmcm9tIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgcmVtb3ZlU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RvcmVkIG1hcmtzIHdlcmUgZXhwbGljaXRseSBzZXQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc3RvcmVkTWFya3NTZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9NQVJLUykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHN1cGVyLmFkZFN0ZXAoc3RlcCwgZG9jKTtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdGhpcy51cGRhdGVkICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRpbWVzdGFtcCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2V0VGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBzbGljZS5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZS4gV2hlbiBgaW5oZXJpdE1hcmtzYCBpc1xuICAgIHRydWUgYW5kIHRoZSBjb250ZW50IGlzIGlubGluZSwgaXQgaW5oZXJpdHMgdGhlIG1hcmtzIGZyb20gdGhlXG4gICAgcGxhY2Ugd2hlcmUgaXQgaXMgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlLCBpbmhlcml0TWFya3MgPSB0cnVlKSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGluaGVyaXRNYXJrcylcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1hcmsodGhpcy5zdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkgOiAoc2VsZWN0aW9uLiRmcm9tLm1hcmtzQWNyb3NzKHNlbGVjdGlvbi4kdG8pIHx8IE1hcmsubm9uZSkpKTtcbiAgICAgICAgc2VsZWN0aW9uLnJlcGxhY2VXaXRoKHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBkZWxldGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSwgb3IgdGhlIHNlbGVjdGlvbiBpZiBubyByYW5nZSBpcyBnaXZlbixcbiAgICB3aXRoIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGluc2VydFRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuZG9jLnR5cGUuc2NoZW1hO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0aW9uV2l0aChzY2hlbWEudGV4dCh0ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICB0byA9IHRvID09IG51bGwgPyBmcm9tIDogdG87XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIGlmICghbWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgJGZyb20gPSB0aGlzLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gdG8gPT0gZnJvbSA/ICRmcm9tLm1hcmtzKCkgOiAkZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRoaXMuc2VsZWN0aW9uLiR0bykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBrZXllZCBlaXRoZXIgYnlcbiAgICBuYW1lIG9yIGJ5IHBsdWdpbi5cbiAgICAqL1xuICAgIHNldE1ldGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGEgbWV0YWRhdGEgcHJvcGVydHkgZm9yIGEgZ2l2ZW4gbmFtZSBvciBwbHVnaW4uXG4gICAgKi9cbiAgICBnZXRNZXRhKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBkb2Vzbid0IGNvbnRhaW4gYW55IG1ldGFkYXRhLFxuICAgIGFuZCBjYW4gdGh1cyBzYWZlbHkgYmUgZXh0ZW5kZWQuXG4gICAgKi9cbiAgICBnZXQgaXNHZW5lcmljKCkge1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMubWV0YSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBzaG91bGQgc2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3XG4gICAgd2hlbiB1cGRhdGVkIHRvIHRoZSBzdGF0ZSBwcm9kdWNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX1NDUk9MTDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBoYWQgYHNjcm9sbEludG9WaWV3YCBjYWxsZWQgb24gaXQuXG4gICAgKi9cbiAgICBnZXQgc2Nyb2xsZWRJbnRvVmlldygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NDUk9MTCkgPiAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZChmLCBzZWxmKSB7XG4gICAgcmV0dXJuICFzZWxmIHx8ICFmID8gZiA6IGYuYmluZChzZWxmKTtcbn1cbmNsYXNzIEZpZWxkRGVzYyB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVzYywgc2VsZikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXQgPSBiaW5kKGRlc2MuaW5pdCwgc2VsZik7XG4gICAgICAgIHRoaXMuYXBwbHkgPSBiaW5kKGRlc2MuYXBwbHksIHNlbGYpO1xuICAgIH1cbn1cbmNvbnN0IGJhc2VGaWVsZHMgPSBbXG4gICAgbmV3IEZpZWxkRGVzYyhcImRvY1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuZG9jIHx8IGNvbmZpZy5zY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuZG9jOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoY29uZmlnLCBpbnN0YW5jZSkgeyByZXR1cm4gY29uZmlnLnNlbGVjdGlvbiB8fCBTZWxlY3Rpb24uYXRTdGFydChpbnN0YW5jZS5kb2MpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuc2VsZWN0aW9uOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInN0b3JlZE1hcmtzXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5zdG9yZWRNYXJrcyB8fCBudWxsOyB9LFxuICAgICAgICBhcHBseSh0ciwgX21hcmtzLCBfb2xkLCBzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3IgPyB0ci5zdG9yZWRNYXJrcyA6IG51bGw7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2Nyb2xsVG9TZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgYXBwbHkodHIsIHByZXYpIHsgcmV0dXJuIHRyLnNjcm9sbGVkSW50b1ZpZXcgPyBwcmV2ICsgMSA6IHByZXY7IH1cbiAgICB9KVxuXTtcbi8vIE9iamVjdCB3cmFwcGluZyB0aGUgcGFydCBvZiBhIHN0YXRlIG9iamVjdCB0aGF0IHN0YXlzIHRoZSBzYW1lXG4vLyBhY3Jvc3MgdHJhbnNhY3Rpb25zLiBTdG9yZWQgaW4gdGhlIHN0YXRlJ3MgYGNvbmZpZ2AgcHJvcGVydHkuXG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIHBsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gYmFzZUZpZWxkcy5zbGljZSgpO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBZGRpbmcgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIGtleWVkIHBsdWdpbiAoXCIgKyBwbHVnaW4ua2V5ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBGaWVsZERlc2MocGx1Z2luLmtleSwgcGx1Z2luLnNwZWMuc3RhdGUsIHBsdWdpbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG5UaGUgc3RhdGUgb2YgYSBQcm9zZU1pcnJvciBlZGl0b3IgaXMgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IG9mXG50aGlzIHR5cGUuIEEgc3RhdGUgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJl4oCUaXQgaXNuJ3RcbnVwZGF0ZWQsIGJ1dCByYXRoZXIgYSBuZXcgc3RhdGUgdmFsdWUgaXMgY29tcHV0ZWQgZnJvbSBhbiBvbGQgb25lXG51c2luZyB0aGUgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgbWV0aG9kLlxuXG5BIHN0YXRlIGhvbGRzIGEgbnVtYmVyIG9mIGJ1aWx0LWluIGZpZWxkcywgYW5kIHBsdWdpbnMgY2FuXG5bZGVmaW5lXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5zdGF0ZSkgYWRkaXRpb25hbCBmaWVsZHMuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgb2YgdGhlIHN0YXRlJ3MgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGx1Z2lucyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucGx1Z2lucztcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRvIHByb2R1Y2UgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseSh0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXJUcmFuc2FjdGlvbih0ciwgaWdub3JlID0gLTEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGkgIT0gaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uICYmICFwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgdHIsIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBWZXJib3NlIHZhcmlhbnQgb2YgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgdGhhdFxuICAgIHJldHVybnMgdGhlIHByZWNpc2UgdHJhbnNhY3Rpb25zIHRoYXQgd2VyZSBhcHBsaWVkICh3aGljaCBtaWdodFxuICAgIGJlIGluZmx1ZW5jZWQgYnkgdGhlIFt0cmFuc2FjdGlvblxuICAgIGhvb2tzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5maWx0ZXJUcmFuc2FjdGlvbikgb2ZcbiAgICBwbHVnaW5zKSBhbG9uZyB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHJvb3RUcikge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyVHJhbnNhY3Rpb24ocm9vdFRyKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiB0aGlzLCB0cmFuc2FjdGlvbnM6IFtdIH07XG4gICAgICAgIGxldCB0cnMgPSBbcm9vdFRyXSwgbmV3U3RhdGUgPSB0aGlzLmFwcGx5SW5uZXIocm9vdFRyKSwgc2VlbiA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgbG9vcCByZXBlYXRlZGx5IGdpdmVzIHBsdWdpbnMgYSBjaGFuY2UgdG8gcmVzcG9uZCB0b1xuICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXMgbmV3IHRyYW5zYWN0aW9ucyBhcmUgYWRkZWQsIG1ha2luZyBzdXJlIHRvIG9ubHlcbiAgICAgICAgLy8gcGFzcyB0aGUgdHJhbnNhY3Rpb25zIHRoZSBwbHVnaW4gZGlkIG5vdCBzZWUgYmVmb3JlLlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgaGF2ZU5ldyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gc2VlbiA/IHNlZW5baV0ubiA6IDAsIG9sZFN0YXRlID0gc2VlbiA/IHNlZW5baV0uc3RhdGUgOiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSBuIDwgdHJzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIG4gPyB0cnMuc2xpY2UobikgOiB0cnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ciAmJiBuZXdTdGF0ZS5maWx0ZXJUcmFuc2FjdGlvbih0ciwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIsIHJvb3RUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2goaiA8IGkgPyB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9IDogeyBzdGF0ZTogdGhpcywgbjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRycy5wdXNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUuYXBwbHlJbm5lcih0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlTmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5baV0gPSB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGF2ZU5ldylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogbmV3U3RhdGUsIHRyYW5zYWN0aW9uczogdHJzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseUlubmVyKHRyKSB7XG4gICAgICAgIGlmICghdHIuYmVmb3JlLmVxKHRoaXMuZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgYSBtaXNtYXRjaGVkIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUodGhpcy5jb25maWcpLCBmaWVsZHMgPSB0aGlzLmNvbmZpZy5maWVsZHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBuZXdJbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmFwcGx5KHRyLCB0aGlzW2ZpZWxkLm5hbWVdLCB0aGlzLCBuZXdJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0luc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSBmcm9tIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgdHIoKSB7IHJldHVybiBuZXcgVHJhbnNhY3Rpb24odGhpcyk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5kb2MgPyBjb25maWcuZG9jLnR5cGUuc2NoZW1hIDogY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGNvbmZpZy5maWVsZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpbnN0YW5jZVskY29uZmlnLmZpZWxkc1tpXS5uYW1lXSA9ICRjb25maWcuZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlIGJhc2VkIG9uIHRoaXMgb25lLCBidXQgd2l0aCBhbiBhZGp1c3RlZCBzZXRcbiAgICBvZiBhY3RpdmUgcGx1Z2lucy4gU3RhdGUgZmllbGRzIHRoYXQgZXhpc3QgaW4gYm90aCBzZXRzIG9mXG4gICAgcGx1Z2lucyBhcmUga2VwdCB1bmNoYW5nZWQuIFRob3NlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0IGFyZVxuICAgIGRyb3BwZWQsIGFuZCB0aG9zZSB0aGF0IGFyZSBuZXcgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZWlyXG4gICAgW2Bpbml0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQuaW5pdCkgbWV0aG9kLCBwYXNzaW5nIGluIHRoZSBuZXdcbiAgICBjb25maWd1cmF0aW9uIG9iamVjdC4uXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbih0aGlzLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gJGNvbmZpZy5maWVsZHMsIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBmaWVsZHNbaV0ubmFtZTtcbiAgICAgICAgICAgIGluc3RhbmNlW25hbWVdID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXNbbmFtZV0gOiBmaWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIHN0YXRlIHRvIEpTT04uIElmIHlvdSB3YW50IHRvIHNlcmlhbGl6ZSB0aGUgc3RhdGVcbiAgICBvZiBwbHVnaW5zLCBwYXNzIGFuIG9iamVjdCBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIHRvIHVzZSBpbiB0aGVcbiAgICByZXN1bHRpbmcgSlNPTiBvYmplY3QgdG8gcGx1Z2luIG9iamVjdHMuIFRoZSBhcmd1bWVudCBtYXkgYWxzbyBiZVxuICAgIGEgc3RyaW5nIG9yIG51bWJlciwgaW4gd2hpY2ggY2FzZSBpdCBpcyBpZ25vcmVkLCB0byBzdXBwb3J0IHRoZVxuICAgIHdheSBgSlNPTi5zdHJpbmdpZnlgIGNhbGxzIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgICAqL1xuICAgIHRvSlNPTihwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgZG9jOiB0aGlzLmRvYy50b0pTT04oKSwgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgIHJlc3VsdC5zdG9yZWRNYXJrcyA9IHRoaXMuc3RvcmVkTWFya3MubWFwKG0gPT4gbS50b0pTT04oKSk7XG4gICAgICAgIGlmIChwbHVnaW5GaWVsZHMgJiYgdHlwZW9mIHBsdWdpbkZpZWxkcyA9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT0gXCJkb2NcIiB8fCBwcm9wID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIEpTT04gZmllbGRzIGBkb2NgIGFuZCBgc2VsZWN0aW9uYCBhcmUgcmVzZXJ2ZWRcIik7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9KU09OKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBzdGF0ZS50b0pTT04uY2FsbChwbHVnaW4sIHRoaXNbcGx1Z2luLmtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzdGF0ZS4gYGNvbmZpZ2Agc2hvdWxkXG4gICAgaGF2ZSBhdCBsZWFzdCBhIGBzY2hlbWFgIGZpZWxkLCBhbmQgc2hvdWxkIGNvbnRhaW4gYXJyYXkgb2ZcbiAgICBwbHVnaW5zIHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIHdpdGguIGBwbHVnaW5GaWVsZHNgIGNhbiBiZSB1c2VkXG4gICAgdG8gZGVzZXJpYWxpemUgdGhlIHN0YXRlIG9mIHBsdWdpbnMsIGJ5IGFzc29jaWF0aW5nIHBsdWdpblxuICAgIGluc3RhbmNlcyB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lcyB0aGV5IHVzZSBpbiB0aGUgSlNPTiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oY29uZmlnLCBqc29uLCBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBFZGl0b3JTdGF0ZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgaWYgKCFjb25maWcuc2NoZW1hKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXF1aXJlZCBjb25maWcgZmllbGQgJ3NjaGVtYScgbWlzc2luZ1wiKTtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgJGNvbmZpZy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PSBcImRvY1wiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZG9jID0gTm9kZS5mcm9tSlNPTihjb25maWcuc2NoZW1hLCBqc29uLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24gPSBTZWxlY3Rpb24uZnJvbUpTT04oaW5zdGFuY2UuZG9jLCBqc29uLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic3RvcmVkTWFya3NcIikge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdG9yZWRNYXJrcyA9IGpzb24uc3RvcmVkTWFya3MubWFwKGNvbmZpZy5zY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5GaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5rZXkgPT0gZmllbGQubmFtZSAmJiBzdGF0ZSAmJiBzdGF0ZS5mcm9tSlNPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gc3RhdGUuZnJvbUpTT04uY2FsbChwbHVnaW4sIGNvbmZpZywganNvbltwcm9wXSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRQcm9wcyhvYmosIHNlbGYsIHRhcmdldCkge1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGxldCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgIHZhbCA9IHZhbC5iaW5kKHNlbGYpO1xuICAgICAgICBlbHNlIGlmIChwcm9wID09IFwiaGFuZGxlRE9NRXZlbnRzXCIpXG4gICAgICAgICAgICB2YWwgPSBiaW5kUHJvcHModmFsLCBzZWxmLCB7fSk7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuUGx1Z2lucyBidW5kbGUgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBhZGRlZCB0byBhbiBlZGl0b3IuXG5UaGV5IGFyZSBwYXJ0IG9mIHRoZSBbZWRpdG9yIHN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUpIGFuZFxubWF5IGluZmx1ZW5jZSB0aGF0IHN0YXRlIGFuZCB0aGUgdmlldyB0aGF0IGNvbnRhaW5zIGl0LlxuKi9cbmNsYXNzIFBsdWdpbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbidzIFtzcGVjIG9iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMpLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpIGV4cG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0ge307XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgYmluZFByb3BzKHNwZWMucHJvcHMsIHRoaXMsIHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmtleSA9IHNwZWMua2V5ID8gc3BlYy5rZXkua2V5IDogY3JlYXRlS2V5KFwicGx1Z2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmaWVsZCBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cbmNvbnN0IGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlS2V5KG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBrZXlzKVxuICAgICAgICByZXR1cm4gbmFtZSArIFwiJFwiICsgKytrZXlzW25hbWVdO1xuICAgIGtleXNbbmFtZV0gPSAwO1xuICAgIHJldHVybiBuYW1lICsgXCIkXCI7XG59XG4vKipcbkEga2V5IGlzIHVzZWQgdG8gW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMua2V5KSBwbHVnaW5zIGluIGEgd2F5XG50aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGZpbmQgdGhlbSwgZ2l2ZW4gYW4gZWRpdG9yIHN0YXRlLlxuQXNzaWduaW5nIGEga2V5IGRvZXMgbWVhbiBvbmx5IG9uZSBwbHVnaW4gb2YgdGhhdCB0eXBlIGNhbiBiZVxuYWN0aXZlIGluIGEgc3RhdGUuXG4qL1xuY2xhc3MgUGx1Z2luS2V5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4ga2V5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSA9IFwia2V5XCIpIHsgdGhpcy5rZXkgPSBjcmVhdGVLZXkobmFtZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGFjdGl2ZSBwbHVnaW4gd2l0aCB0aGlzIGtleSwgaWYgYW55LCBmcm9tIGFuIGVkaXRvclxuICAgIHN0YXRlLlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jb25maWcucGx1Z2luc0J5S2V5W3RoaXMua2V5XTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5cbmV4cG9ydCB7IEFsbFNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBUZXh0U2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-state/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* binding */ AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* binding */ AttrStep),\n/* harmony export */   MapResult: () => (/* binding */ MapResult),\n/* harmony export */   Mapping: () => (/* binding */ Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* binding */ RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* binding */ ReplaceStep),\n/* harmony export */   Step: () => (/* binding */ Step),\n/* harmony export */   StepMap: () => (/* binding */ StepMap),\n/* harmony export */   StepResult: () => (/* binding */ StepResult),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   canJoin: () => (/* binding */ canJoin),\n/* harmony export */   canSplit: () => (/* binding */ canSplit),\n/* harmony export */   dropPoint: () => (/* binding */ dropPoint),\n/* harmony export */   findWrapping: () => (/* binding */ findWrapping),\n/* harmony export */   insertPoint: () => (/* binding */ insertPoint),\n/* harmony export */   joinPoint: () => (/* binding */ joinPoint),\n/* harmony export */   liftTarget: () => (/* binding */ liftTarget),\n/* harmony export */   replaceStep: () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(\n    /**\n    The step maps in this mapping.\n    */\n    maps = [], \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps.length) {\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */\n    copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: \"replace\", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: \"replaceAround\", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (child.isText && !parentType.spec.code) {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while (m = newline.exec(child.text)) {\n                    if (!slice)\n                        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n        tr.step(replSteps[i]);\n}\n\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) &&\n        (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth;; --depth) {\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content))\n            return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n            break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner)\n        return null;\n    return around.map(withAttrs)\n        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) { return { type, attrs: null }; }\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around)\n        return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside)\n        return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for (let i = startIndex; innerMatch && i < endIndex; i++)\n        innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd)\n        return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n            return false;\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError(\"No node at given position\");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating ||\n        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n        return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating)\n            return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild)\n            rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = (typesAfter && typesAfter[i]) || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n            return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n        $pos.parent.canReplace(index, index + 1);\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for (let d = $pos.depth;; d--) {\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        }\n        else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        }\n        else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) &&\n            $pos.node(d).canReplace(index, index + 1))\n            return pos;\n        if (d == 0)\n            break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);\n    tr.step(step);\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size)\n        return pos;\n    let content = slice.content;\n    for (let i = 0; i < slice.openStart; i++)\n        content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n        for (let d = $pos.depth; d >= 0; d--) {\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            }\n            else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits)\n                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n            let node = cur.firstChild;\n            if (cur.childCount > 1)\n                openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n            preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node)\n                throw new RangeError(\"No node at position \" + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark)\n                return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csUUFBUTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQUs7QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsb0RBQUssQ0FBQyx1REFBUTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsb0RBQUssQ0FBQyx1REFBUTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0RBQUs7QUFDdkUsc0JBQXNCLG9EQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvREFBSztBQUN2RSxzQkFBc0Isb0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsb0RBQUs7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvREFBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBSyxDQUFDLHVEQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFRO0FBQzVDLGlDQUFpQyxvREFBSztBQUN0QztBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBLGlCQUFpQix1REFBUTtBQUN6QiwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EscUJBQXFCLHVEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEIsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBLG9CQUFvQix1REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG9EQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQVE7QUFDMUIsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBUTtBQUMxQjtBQUNBO0FBQ0EsOERBQThELG9EQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysb0RBQUssQ0FBQyx1REFBUTtBQUNoRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csb0RBQUssQ0FBQyx1REFBUTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdURBQVEsZ0JBQWdCLHVEQUFRO0FBQzdFLG9FQUFvRSxPQUFPO0FBQzNFLGlCQUFpQix1REFBUTtBQUN6QjtBQUNBLGdCQUFnQix1REFBUTtBQUN4QjtBQUNBLDBDQUEwQyxvREFBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0RBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHVCQUF1QixzREFBc0Q7QUFDN0UsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFRO0FBQzlCLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QywwQkFBMEIsdURBQVE7QUFDbEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQkFBZ0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDLG9GQUFvRixpQkFBaUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQjtBQUN6RSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQSx3R0FBd0csdURBQVE7QUFDaEg7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQUs7QUFDckM7QUFDQTtBQUNBLGdDQUFnQyxvREFBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFpRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQSxpQ0FBaUMsOERBQThEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQUs7QUFDMUMsZ0NBQWdDLG9EQUFLO0FBQ3JDLHNCQUFzQixvREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdURBQVE7QUFDckUsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdURBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLHVEQUFRO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLG9EQUFLO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx1REFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQUssQ0FBQyx1REFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG9EQUFLLENBQUMsdURBQVE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9EQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFLLENBQUMsdURBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvREFBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbURBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzPzgxZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbuKAmFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZynigJkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwcyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMubWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5tYXBzLmxlbmd0aCArIG1hcHBpbmcubWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9g4oCUdGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSksIGdhcFRvID0gbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCAmJiAhcGFyZW50VHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nLCBzbGljZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIgKyBtLmluZGV4LCBjdXIgKyBtLmluZGV4ICsgbVswXS5sZW5ndGgsIHNsaWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgICAgICBsZXQgZmlsbCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVwbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKHJlcGxTdGVwc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiZcbiAgICAgICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2VcbmNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuW2lzb2xhdGluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuKi9cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGxldCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG4gICAgZm9yIChsZXQgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSByYW5nZS4kZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLCBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwIHx8IG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhY2FuQ3V0KG5vZGUsIGluZGV4LCBlbmRJbmRleCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBsaWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gICAgbGV0IHsgJGZyb20sICR0bywgZGVwdGggfSA9IHJhbmdlO1xuICAgIGxldCBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgICBsZXQgc3RhcnQgPSBnYXBTdGFydCwgZW5kID0gZ2FwRW5kO1xuICAgIGxldCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgb3BlblN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eSwgb3BlbkVuZCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICR0by5hZnRlcihkICsgMSkgPCAkdG8uZW5kKGQpKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKCR0by5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG5ub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG50aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xudXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG5jb250ZW50IG9mIGByYW5nZWAuXG4qL1xuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMgPSBudWxsLCBpbm5lclJhbmdlID0gcmFuZ2UpIHtcbiAgICBsZXQgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIGxldCBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmICghaW5uZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycylcbiAgICAgICAgLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlLCBhdHRycyB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHsgdHlwZSwgYXR0cnM6IG51bGwgfTsgfVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmICghYXJvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIGxldCBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKCFpbnNpZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICBsZXQgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiB3cmFwKHRyLCByYW5nZSwgd3JhcHBlcnMpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnMpICYmIGNhbkNoYW5nZVR5cGUodHIuZG9jLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MpLCB0eXBlKSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBtYXJrdXAgdGhhdCBpc24ndCBhbGxvd2VkIGluIHRoZSBuZXcgbm9kZSB0eXBlIGlzIGNsZWFyZWRcbiAgICAgICAgICAgIHRyLmNsZWFySW5jb21wYXRpYmxlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBhLmNhbkFwcGVuZChiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IHN0ZXAgPSBuZXcgUmVwbGFjZVN0ZXAocG9zIC0gZGVwdGgsIHBvcyArIGRlcHRoLCBTbGljZS5lbXB0eSwgdHJ1ZSk7XG4gICAgdHIuc3RlcChzdGVwKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG7igJhGaXTigJkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhIG1hcmsgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBpZiAoIShtYXJrIGluc3RhbmNlb2YgTWFyaykpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrLmlzSW5TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoIW1hcmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdC5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-transform/dist/index.js\n");

/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard),\n/* harmony export */   __serializeForClipboard: () => (/* binding */ __serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n\nconst domIndex = function (node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n};\nconst parentNode = function (node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function (node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function (node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||\n                node.contentEditable == \"false\")\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.contentEditable == \"false\")\n                return false;\n            off = dir < 0 ? nodeSize(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n        if (node == parent)\n            return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node)\n            return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n        if (desc = cur.pmViewDesc)\n            break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function (domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos)\n                return { node: pos.offsetNode, offset: pos.offset };\n        }\n        catch (_) { }\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range)\n            return { node: range.startContainer, offset: range.startOffset };\n    }\n}\n\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = (nav && nav.userAgent) || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n\nfunction windowRect(doc) {\n    return { left: 0, right: doc.documentElement.clientWidth,\n        top: 0, bottom: doc.documentElement.clientHeight };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = (rect.width / node.offsetWidth) || 1;\n    let scaleY = (rect.height / node.offsetHeight) || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return { left: rect.left, right: rect.left + node.clientWidth * scaleX,\n        top: rect.top, bottom: rect.top + node.clientHeight * scaleY };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {\n        if (!parent)\n            break;\n        if (parent.nodeType != 1)\n            continue;\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n            moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n            moveY = rect.bottom - rect.top > bounding.bottom - bounding.top\n                ? rect.top + getSide(scrollMargin, \"top\") - bounding.top\n                : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n            moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n            moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            }\n            else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY)\n                    elt.scrollTop += moveY;\n                if (moveX)\n                    elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n            }\n        }\n        if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))\n            break;\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom))\n            continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return { refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n        if (dom == doc)\n            break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop)\n            dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left)\n            dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n        let rects;\n        if (child.nodeType == 1)\n            rects = child.getClientRects();\n        else if (child.nodeType == 3)\n            rects = textRange(child).getClientRects();\n        else\n            continue;\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left\n                    : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx)\n                        offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            }\n            else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                coords.left >= rect.left && coords.top >= rect.bottom))\n                offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n        return findOffsetInText(closest, coordsClosest);\n    if (!closest || (dxClosest && closest.nodeType == 1))\n        return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom)\n            continue;\n        if (inRect(coords, rect))\n            return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n    }\n    return { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 &&\n        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n        return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false;;) {\n        if (cur == view.dom)\n            break;\n        let desc = view.docView.nearestDesc(cur, true);\n        if (!desc)\n            return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {\n            let rect = desc.dom.getBoundingClientRect();\n            if (desc.node.isBlock && desc.parent && !sawBlock) {\n                sawBlock = true;\n                if (rect.left > coords.left || rect.top > coords.top)\n                    outsideBlock = desc.posBefore;\n                else if (rect.right < coords.left || rect.bottom < coords.top)\n                    outsideBlock = desc.posAfter;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2\n                    : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for (let j = 0; j < rects.length; j++) {\n                    let rect = rects[j];\n                    if (inRect(coords, rect))\n                        return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI)\n                break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret)\n        ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc)\n        .elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box))\n            return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt)\n            return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for (let p = elt; node && p; p = parentNode(p))\n            if (p.draggable)\n                node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n                    box.bottom > coords.top)\n                    offset++;\n            }\n        }\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n            coords.top > node.lastChild.getBoundingClientRect().bottom)\n            pos = view.state.doc.content.size;\n        // Ignore positions directly after a BR, since caret*FromPoint\n        // 'round up' positions that would be more accurately placed\n        // before the BR node.\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n            pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n        pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first))\n            return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top)\n                        return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        }\n        else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            }\n            else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            }\n            else if (side < 0) {\n                from--;\n            }\n            else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1)\n                return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1)\n                return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n            // BR nodes tend to only return the rectangle before them.\n            // Only use them if they are the last element in their parent\n            : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target)\n            return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n            after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n            : after.nodeType == 1 ? after : null;\n        if (target)\n            return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0)\n        return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0)\n        return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n        view.updateState(state);\n    if (active != view.dom)\n        view.focus();\n    try {\n        return f();\n    }\n    finally {\n        if (viewState != state)\n            view.updateState(viewState);\n        if (active != view.dom && active)\n            active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for (;;) {\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest)\n                break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for (let child = dom.firstChild; child; child = child.nextSibling) {\n            let boxes;\n            if (child.nodeType == 1)\n                boxes = child.getClientRects();\n            else if (child.nodeType == 3)\n                boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else\n                continue;\n            for (let i = 0; i < boxes.length; i++) {\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 &&\n                    (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2\n                        : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n                    return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n        return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n        return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) ||\n            (oldNode == newNode && oldOff == newOff);\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n                sel.extend(oldNode, oldOff);\n        }\n        catch (_) { }\n        if (oldBidiLevel != null)\n            sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n        return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\"\n        ? endOfTextblockVertical(view, state, dir)\n        : endOfTextblockHorizontal(view, state, dir);\n}\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, \n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM) {\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) { return false; }\n    matchesMark(mark) { return false; }\n    matchesNode(node, outerDeco, innerDeco) { return false; }\n    matchesHack(nodeName) { return false; }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() { return null; }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) { return false; }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for (let i = 0; i < this.children.length; i++)\n            size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() { return 0; }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this)\n            this.dom.pmViewDesc = undefined;\n        for (let i = 0; i < this.children.length; i++)\n            this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for (let i = 0, pos = this.posAtStart;; i++) {\n            let cur = this.children[i];\n            if (cur == child)\n                return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n                    domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            }\n            else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n                    domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        }\n        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        }\n        else if (this.dom.firstChild) {\n            if (offset == 0)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = false;\n                        break;\n                    }\n                    if (search.previousSibling)\n                        break;\n                }\n            if (atEnd == null && offset == dom.childNodes.length)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = true;\n                        break;\n                    }\n                    if (search.nextSibling)\n                        break;\n                }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) &&\n                    !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n                    first = false;\n                else\n                    return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for (let cur = desc; cur; cur = cur.parent)\n            if (cur == this)\n                return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for (let scan = dom; scan; scan = scan.parentNode) {\n            let desc = this.getDesc(scan);\n            if (desc)\n                return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while (!child.border && child.children.length)\n                    child = child.children[0];\n                return child;\n            }\n            if (pos < end)\n                return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM)\n            return { node: this.dom, offset: 0, atom: pos + 1 };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for (let curPos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset)\n            return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) { }\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for (;; i--, enter = false) {\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom)\n                return prev.domFromPos(prev.size, side);\n            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n        }\n        else {\n            let next, enter = true;\n            for (;; i++, enter = false) {\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (next && enter && !next.border && !next.domAtom)\n                return next.domFromPos(0, side);\n            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0)\n            return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n        let fromOffset = -1, toOffset = -1;\n        for (let offset = base, i = 0;; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node &&\n                    child.contentDOM && this.contentDOM.contains(child.contentDOM))\n                    return child.parseRange(from, to, childBase);\n                from = offset;\n                for (let j = i; j > 0; j--) {\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1)\n                    fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for (let j = i + 1; j < this.children.length; j++) {\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1)\n                    toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return { node: this.contentDOM, from, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length)\n            return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length)\n            throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, root, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end)\n                return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = root.getSelection();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for (let scan = node, after; scan; scan = scan.parentNode) {\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\")\n                                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock)\n                            break;\n                    }\n                }\n            }\n            else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n            let after = domSel.focusNode.childNodes[domSel.focusOffset];\n            if (after && after.contentEditable == \"false\")\n                force = true;\n        }\n        if (!(force || brKludge && safari) &&\n            isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n            isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n            return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !brKludge) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head)\n                    domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            }\n            catch (_) {\n                // In some cases with Chrome the selection is empty after calling\n                // collapse, even when it should be valid. This appears to be a bug, but\n                // it is difficult to isolate. If this happens fallback to the old path\n                // without using extend.\n                // Similarly, this could crash on Safari if the editor is hidden, and\n                // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for (let offset = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside &&\n                        (child.contentLost || child.dom.parentNode != this.contentDOM))\n                        child.dirty = NODE_DIRTY;\n                    else\n                        child.markDirty(from - startInside, to - startInside);\n                    return;\n                }\n                else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n                        ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for (let node = this.parent; node; node = node.parent, level++) {\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty)\n                node.dirty = dirty;\n        }\n    }\n    get domAtom() { return false; }\n    get ignoreForCoords() { return false; }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\")\n            dom = dom(view, () => {\n                if (!self)\n                    return pos;\n                if (self.parent)\n                    return self.parent.posBeforeChild(self);\n            });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() { return { ignore: true }; }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() { return true; }\n    get side() { return this.widget.type.side; }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text) {\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() { return this.text.length; }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM)\n            return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n        return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM) {\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom)\n            spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n    }\n    parseRule() {\n        if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView)\n            return null;\n        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n    }\n    matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark); }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while (!parent.node)\n                parent = parent.parent;\n            if (parent.dirty < this.dirty)\n                parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size)\n            nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0)\n            nodes = replaceNodes(nodes, 0, from, view);\n        for (let i = 0; i < nodes.length; i++)\n            nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, () => {\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj)\n                return pos;\n            if (descObj.parent)\n                return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom)\n                dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3)\n                throw new RangeError(\"Text must be rendered as a DOM text node\");\n        }\n        else if (!dom) {\n            ({ dom, contentDOM } = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n            if (!dom.hasAttribute(\"contenteditable\"))\n                dom.contentEditable = \"false\";\n            if (node.type.spec.draggable)\n                dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec)\n            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText)\n            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else\n            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView)\n            return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = { node: this.node.type.name, attrs: this.node.attrs };\n        if (this.node.type.whitespace == \"pre\")\n            rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = () => this.node.content;\n        }\n        else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        }\n        else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement)\n                rule.getContent = () => prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n            sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() { return this.node.nodeSize; }\n    get border() { return this.node.isLeaf ? 0 : 1; }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n            if (widget.spec.marks)\n                updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode)\n                updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i) => {\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off &&\n                view.state.selection.to < off + child.nodeSize &&\n                (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock)\n            updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition)\n                this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios)\n                iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size)\n            return null;\n        let sel = view.domSelectionRange();\n        let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n        if (!textNode || !this.dom.contains(textNode.parentNode))\n            return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n        }\n        else {\n            return { node: textNode, pos: -1, text: \"\" };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node))\n            return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for (;; topNode = topNode.parentNode) {\n            if (topNode.parentNode == this.contentDOM)\n                break;\n            while (topNode.previousSibling)\n                topNode.parentNode.removeChild(topNode.previousSibling);\n            while (topNode.nextSibling)\n                topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc)\n                topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM)\n            this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco))\n            return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1)\n            this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n            this.dom.draggable = true;\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1)\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n            this.dom.removeAttribute(\"draggable\");\n    }\n    get domAtom() { return this.node.isAtom; }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n        docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while (skip && skip != this.dom && !skip.pmIsDeco)\n            skip = skip.parentNode;\n        return { skip: (skip || true) };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM)\n                view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for (let n = this.nodeDOM; n; n = n.parentNode)\n            if (n == parentDOM)\n                return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM)\n            return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n            this.dirty = NODE_DIRTY;\n    }\n    get domAtom() { return false; }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() { return { ignore: true }; }\n    matchesHack(nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName; }\n    get domAtom() { return true; }\n    get ignoreForCoords() { return this.dom.nodeName == \"IMG\"; }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY)\n            return false;\n        if (this.spec.update) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result)\n                this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        }\n        else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        }\n        else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, root, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n            : super.setSelection(anchor, head, root, force);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while (childDOM != dom) {\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        }\n        else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while (dom) {\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n        view.trackWrites = null;\n}\nconst OuterDecoLevel = function (nodeName) {\n    if (nodeName)\n        this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [new OuterDecoLevel];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n        return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs)\n            continue;\n        if (attrs.nodeName)\n            result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for (let name in attrs) {\n            let val = attrs[name];\n            if (val == null)\n                continue;\n            if (needsWrap && result.length == 1)\n                result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\")\n                top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\")\n                top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\")\n                top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco)\n        return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n                (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            }\n            else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n            dom.removeAttribute(name);\n    for (let name in cur)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n            dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for (let i = 0; i < prevList.length; i++)\n            if (curList.indexOf(prevList[i]) == -1)\n                dom.classList.remove(prevList[i]);\n        for (let i = 0; i < curList.length; i++)\n            if (prevList.indexOf(curList[i]) == -1)\n                dom.classList.add(curList[i]);\n        if (dom.classList.length == 0)\n            dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while (m = prop.exec(prev.style))\n                dom.style.removeProperty(m[1]);\n        }\n        if (cur.style)\n            dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].type.eq(b[i].type))\n            return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view) {\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end)\n            return;\n        for (let i = start; i < end; i++)\n            this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while (keep < maxKeep &&\n            (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1])\n                .matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n            keep++;\n        while (keep < depth) {\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while (depth < marks.length) {\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            }\n            else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index &&\n            (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n            targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        }\n        else {\n            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0)\n            return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n            child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view))\n            return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for (;;) {\n            let parent = domNode.parentNode;\n            if (!parent)\n                return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc)\n                    for (let i = this.index; i < this.top.children.length; i++) {\n                        if (this.top.children[i] == desc)\n                            return i;\n                    }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for (let i = this.index; i < this.top.children.length; i++) {\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index)\n                    return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) &&\n                    !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n                        next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM)\n                        this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.top.children[this.index] = updated;\n                    updated.dirty = CONTENT_DIRTY;\n                    updated.updateChildren(view, pos + 1);\n                    updated.dirty = NOT_DIRTY;\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length ||\n            !next.node.content.eq(node.content))\n            return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (!wrapper.contentDOM)\n            return null;\n        wrapper.children = next.children;\n        next.children = [];\n        next.destroy();\n        for (let ch of wrapper.children)\n            ch.parent = wrapper;\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM)\n            desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) &&\n            (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        }\n        else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while (lastChild instanceof MarkViewDesc) {\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n            !(lastChild instanceof TextViewDesc) ||\n            /\\n$/.test(lastChild.node.text) ||\n            (this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text))) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n                this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        }\n        else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\")\n                dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top)\n                parent.children.push(hack);\n            else\n                parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while (fI > 0) {\n        let desc;\n        for (;;) {\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                }\n                else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            }\n            else if (curDesc == parentDesc) {\n                break outer;\n            }\n            else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node)\n            continue;\n        if (node != frag.child(fI - 1))\n            break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return { index: fI, matched, matches: matches.reverse() };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for (let i = 0; i < parent.childCount; i++) {\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0;;) {\n        if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n            let widget = locals[decoIndex++], widgets;\n            while (decoIndex < locals.length && locals[decoIndex].to == offset)\n                (widgets || (widgets = [widget])).push(locals[decoIndex++]);\n            if (widgets) {\n                widgets.sort(compareSide);\n                for (let i = 0; i < widgets.length; i++)\n                    onWidget(widgets[i], parentIndex, !!restNode);\n            }\n            else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        }\n        else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        }\n        else {\n            break;\n        }\n        for (let i = 0; i < active.length; i++)\n            if (active[i].to <= offset)\n                active.splice(i--, 1);\n        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n            active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n                cutAt = locals[decoIndex].from;\n            for (let i = 0; i < active.length; i++)\n                if (active[i].to < cutAt)\n                    cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter(d => !d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\nfunction nearbyTextNode(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n                return node.childNodes[offset];\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText)\n            continue;\n        let str = child.text;\n        while (i < frag.childCount) {\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText)\n                break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from)\n                return childStart + found;\n            if (from == to && str.length >= (to + text.length) - childStart &&\n                str.slice(to - childStart, to - childStart + text.length) == text)\n                return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes.length; i++) {\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        }\n        else {\n            if (start < from)\n                result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to)\n                result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\n\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode)\n        return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n        return null;\n    let $head = doc.resolve(head), $anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        $anchor = $head;\n        while (nearestDesc && !nearestDesc.node)\n            nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent\n            && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    }\n    else {\n        let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        if (anchor < 0)\n            return null;\n        $anchor = doc.resolve(anchor);\n    }\n    if (!selection) {\n        let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() :\n        hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n        return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode &&\n            isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    }\n    else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent)\n                resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent)\n                resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view.root, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom)\n                resetEditable(resetEditableFrom);\n            if (resetEditableTo)\n                resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        }\n        else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document)\n                removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\")\n        return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") &&\n        (!before || before.contentEditable == \"false\")) {\n        if (after)\n            return setEditable(after);\n        else if (before)\n            return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(() => {\n                if (!editorOwnsSelection(view) || view.state.selection.visible)\n                    view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection(), range = document.createRange();\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img)\n        range.setEnd(node.parentNode, domIndex(node) + 1);\n    else\n        range.setEnd(node, 0);\n    range.collapse(false);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc)\n                desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    }\n    else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent)\n            view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n        || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n        return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n            (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\n\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (!sel.empty || mods.indexOf(\"s\") > -1) {\n            return false;\n        }\n        else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n                return apply(view, next);\n            return false;\n        }\n        else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText)\n                return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n                return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            }\n            else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    }\n    else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next)\n            return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom) {\n    if (dom.contentEditable == \"false\")\n        return true;\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset]))\n        force = true;\n    for (;;) {\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            }\n            else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                }\n                else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                }\n                else\n                    break;\n            }\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let prev = node.previousSibling;\n            while (prev && isIgnorable(prev)) {\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = 0;\n            }\n            else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force)\n        setSelFocus(view, node, offset);\n    else if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (;;) {\n        if (offset < len) {\n            if (node.nodeType != 1)\n                break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            }\n            else\n                break;\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let next = node.nextSibling;\n            while (next && isIgnorable(next)) {\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = len = 0;\n            }\n            else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while (node && offset < node.childNodes.length) {\n        node = node.childNodes[offset];\n        if (node.nodeType == 3)\n            return node;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while (node && !offset && !hasBlockDesc(node)) {\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while (node && offset) {\n        node = node.childNodes[offset - 1];\n        if (node.nodeType == 3)\n            return node;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        }\n        else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(() => {\n        if (view.state == state)\n            selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n                return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n                return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n        return false;\n    if (mac && mods.indexOf(\"m\") > -1)\n        return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n            return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection))\n        return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor))\n        return true;\n    if (!empty)\n        return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n        return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0)\n            tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else\n            tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n        return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n        focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(() => switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey)\n        result += \"c\";\n    if (event.metaKey)\n        result += \"m\";\n    if (event.altKey)\n        result += \"a\";\n    if (event.shiftKey)\n        result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || (mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    }\n    else if ((code == 46 && !event.shiftKey) || (mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    }\n    else if (code == 13 || code == 27) { // Enter, Esc\n        return true;\n    }\n    else if (code == 37 || (mac && code == 66 && mods == \"c\")) { // Left arrow, Ctrl-b on Mac\n        let dir = code == 37 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1) : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 39 || (mac && code == 70 && mods == \"c\")) { // Right arrow, Ctrl-f on Mac\n        let dir = code == 39 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1) : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 38 || (mac && code == 80 && mods == \"c\")) { // Up arrow, Ctrl-p on Mac\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    }\n    else if (code == 40 || (mac && code == 78 && mods == \"c\")) { // Down arrow, Ctrl-n on Mac\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesAfter(view);\n    }\n    else if (mods == (mac ? \"m\" : \"c\") &&\n        (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n        return true;\n    }\n    return false;\n}\n\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", f => { slice = f(slice, view); });\n    let context = [], { content, openStart, openEnd } = slice;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, { document: doc }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n        for (let i = needsWrap.length - 1; i >= 0; i--) {\n            let wrapper = doc.createElement(needsWrap[i]);\n            while (wrap.firstChild)\n                wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n        firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", f => f(slice, view)) ||\n        slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return { dom: wrap, text };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text)\n        return null;\n    let asText = text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText, view); });\n        if (inCode)\n            return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n        let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        }\n        else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block)\n                    p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    }\n    else {\n        view.someProp(\"transformPastedHTML\", f => { html = f(html, view); });\n        dom = readHTML(html);\n        if (webkit)\n            restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3])\n        for (let i = +sliceData[3]; i > 0; i--) {\n            let child = dom.firstChild;\n            while (child && child.nodeType != 1)\n                child = child.nextSibling;\n            if (!child)\n                break;\n            dom = child;\n        }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode(dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling &&\n                    dom.parentNode && !inlineParents.test(dom.parentNode.nodeName))\n                    return { ignore: true };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    }\n    else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) { }\n            for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) { }\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", f => { slice = f(slice, view); });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n        return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach(node => {\n            if (!result)\n                return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap)\n                return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            }\n            else {\n                if (result.length)\n                    result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result)\n            return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for (let i = wrap.length - 1; i >= from; i--)\n        node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner)\n            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n            return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0)\n        return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1)\n        openEnd = 0;\n    if (depth < to - 1)\n        inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from)\n        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner)\n            : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\"table\"],\n    tbody: [\"table\"],\n    tfoot: [\"table\"],\n    caption: [\"table\"],\n    colgroup: [\"table\"],\n    col: [\"table\", \"colgroup\"],\n    tr: [\"table\", \"tbody\"],\n    td: [\"table\", \"tbody\", \"tr\"],\n    th: [\"table\", \"tbody\", \"tr\"]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n        html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n        html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = html;\n    if (wrap)\n        for (let i = 0; i < wrap.length; i++)\n            elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\u00a0\" && node.parentNode)\n            node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size)\n        return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    }\n    catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs())\n            break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = { touchstart: true, touchmove: true };\nclass InputState {\n    constructor() {\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = { time: 0, x: 0, y: 0, type: \"\" };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastAndroidDelete = 0;\n        this.composing = false;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for (let event in handlers) {\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event) => {\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n                (view.editable || !(event.type in editHandlers)))\n                handler(view, event);\n        }, passiveHandlers[event] ? { passive: true } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari)\n        view.dom.addEventListener(\"input\", () => null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n        view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", currentHandlers => {\n        for (let type in currentHandlers)\n            if (!view.input.eventHandlers[type])\n                view.dom.addEventListener(type, view.input.eventHandlers[type] = event => runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", handlers => {\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n        if (!node || node.nodeType == 11 ||\n            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n            return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] &&\n        (view.editable || !(event.type in editHandlers)))\n        handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n        return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13)\n        return;\n    if (event.keyCode != 229)\n        view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    }\n    else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n        view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode ||\n        event.ctrlKey && !event.altKey || mac && event.metaKey)\n        return;\n    if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text)))\n            view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) { return { left: event.clientX, top: event.clientY }; }\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n            : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n            return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused)\n        view.focus();\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\")\n        tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1)\n        return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n        selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 &&\n                i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n                selectAt = $pos.before(sel.$from.depth);\n            else\n                selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleDoubleClick\", f => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n        defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n        return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent)\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else\n            continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n        if (view.input.lastClick.type == \"singleClick\")\n            type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\")\n            type = \"tripleClick\";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n        return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown)\n            view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    }\n    else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed) {\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        }\n        else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc ? targetDesc.dom : null;\n        let { selection } = view.state;\n        if (event.button == 0 &&\n            targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n            selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n            this.mightDrag = {\n                node: targetNode,\n                pos: targetPos,\n                addAttr: !!(this.target && !this.target.draggable),\n                setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n            };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.draggable = true;\n            if (this.mightDrag.setUneditable)\n                setTimeout(() => {\n                    if (this.view.input.mouseDown == this)\n                        this.target.setAttribute(\"contentEditable\", \"false\");\n                }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable)\n                this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync)\n            setTimeout(() => selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target))\n            return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc)\n            pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n        else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        }\n        else if (event.button == 0 &&\n            (this.flushed ||\n                // Safari ignores clicks on draggable elements\n                (safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n                // Chrome will sometimes treat a node selection as a\n                // cursor, but still report that the node is selected\n                // when asked through getSelection. You'll then get a\n                // situation where clicking at the point where that\n                // (hidden) cursor is doesn't change the selection, and\n                // thus doesn't get a reaction from ProseMirror. This\n                // works around that.\n                (chrome && !this.view.state.selection.visible &&\n                    Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        }\n        else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0)\n            this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n            Math.abs(this.event.y - event.clientY) > 4))\n            this.allowDefault = true;\n    }\n}\nhandlers.touchstart = view => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = view => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = view => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing)\n        return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$from;\n        if (state.selection.empty &&\n            (state.storedMarks ||\n                (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        }\n        else {\n            endComposition(view);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before)\n                        break;\n                    if (before.nodeType == 3) {\n                        view.domSelection().collapse(before, before.nodeValue.length);\n                        break;\n                    }\n                    else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        if (view.input.compositionPendingChanges)\n            Promise.resolve().then(() => view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n        view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/\nfunction endComposition(view, forceUpdate = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n        return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (forceUpdate || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view);\n        if (sel && !sel.eq(view.state.selection))\n            view.dispatch(view.state.tr.setSelection(sel));\n        else\n            view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode)\n        return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n        if (wrap.parentNode)\n            wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (ie && ie_version < 15) ||\n    (ios && webkit_version < 604);\nhandlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty)\n        return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, dom);\n    }\n    if (cut)\n        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode)\n        return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText)\n        target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(() => {\n        view.focus();\n        if (target.parentNode)\n            target.parentNode.removeChild(target);\n        if (plainText)\n            doPaste(view, target.value, null, plain, event);\n        else\n            doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)))\n        return true;\n    if (!slice)\n        return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode\n        ? view.state.tr.replaceSelectionWith(singleNode, preferPlain)\n        : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\neditHandlers.paste = (view, _event) => {\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), plain, event))\n        event.preventDefault();\n    else\n        capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move) {\n        this.slice = slice;\n        this.move = move;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nhandlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n        mouseDown.done();\n    if (!event.dataTransfer)\n        return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n    }\n    else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView)\n            view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore)));\n    }\n    let slice = view.state.selection.content(), { dom, text } = serializeForClipboard(view, slice);\n    event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI)\n        event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, !event[dragCopyModifier]);\n};\nhandlers.dragend = view => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n        if (view.dragging == dragging)\n            view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, _event) => {\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer)\n        return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n        return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", f => { slice = f(slice, view); });\n    }\n    else {\n        slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && !event[dragCopyModifier]);\n    if (view.someProp(\"handleDrop\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice)\n        return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null)\n        insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move)\n        tr.deleteSelection();\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode)\n        tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else\n        tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert))\n        return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) &&\n        $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    }\n    else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = view => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(() => {\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n                selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n            view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event) => {\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(() => {\n            if (view.input.domChangeCount != domChangeCount)\n                return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\"))))\n                return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0)\n                view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n\nfunction compareObjs(a, b) {\n    if (a == b)\n        return true;\n    for (let p in a)\n        if (a[p] !== b[p])\n            return false;\n    for (let p in b)\n        if (!(p in a))\n            return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec) {\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() { return true; }\n    eq(other) {\n        return this == other ||\n            (other instanceof WidgetType &&\n                (this.spec.key && this.spec.key == other.spec.key ||\n                    this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)));\n    }\n    destroy(node) {\n        if (this.spec.destroy)\n            this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) { return span.from < span.to; }\n    eq(other) {\n        return this == other ||\n            (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    static is(span) { return span.type instanceof InlineType; }\n    destroy() { }\n}\nclass NodeType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted)\n            return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos)\n            return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other ||\n            (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    destroy() { }\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variants—see the static members of this class for details.\n*/\nclass Decoration {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the decoration.\n    */\n    from, \n    /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */\n    to, \n    /**\n    @internal\n    */\n    type) {\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */\n    static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */\n    get spec() { return this.type.spec; }\n    /**\n    @internal\n    */\n    get inline() { return this.type instanceof InlineType; }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structure—it is not modified,\nupdates create a new value.\n*/\nclass DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document.\n    */\n    static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for (let i = 0; i < this.local.length; i++) {\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n                result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for (let i = 0; i < this.children.length; i += 3) {\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0)\n            return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for (let i = 0; i < this.local.length; i++) {\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped))\n                (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove)\n                options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length)\n            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else\n            return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Needs access to the current document to\n    create the appropriate tree structure.\n    */\n    add(doc, decorations) {\n        if (!decorations.length)\n            return this;\n        if (this == empty)\n            return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset) => {\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))\n                return;\n            if (!children)\n                children = this.children.slice();\n            while (childIndex < children.length && children[childIndex] < childOffset)\n                childIndex += 3;\n            if (children[childIndex] == childOffset)\n                children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else\n                children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for (let i = 0; i < local.length; i++)\n            if (!local[i].type.valid(doc, local[i]))\n                local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n        if (decorations.length == 0 || this == empty)\n            return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for (let i = 0; i < children.length; i += 3) {\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for (let j = 0, span; j < decorations.length; j++)\n                if (span = decorations[j]) {\n                    if (span.from > from && span.to < to) {\n                        decorations[j] = null;\n                        (found || (found = [])).push(span);\n                    }\n                }\n            if (!found)\n                continue;\n            if (children == this.children)\n                children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            }\n            else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length)\n            for (let i = 0, span; i < decorations.length; i++)\n                if (span = decorations[i]) {\n                    for (let j = 0; j < local.length; j++)\n                        if (local[j].eq(span, offset)) {\n                            if (local == this.local)\n                                local = this.local.slice();\n                            local.splice(j--, 1);\n                        }\n                }\n        if (children == this.children && local == this.local)\n            return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    /**\n    @internal\n    */\n    forChild(offset, node) {\n        if (this == empty)\n            return this;\n        if (node.isLeaf)\n            return DecorationSet.empty;\n        let child, local;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] >= offset) {\n                if (this.children[i] == offset)\n                    child = this.children[i + 2];\n                break;\n            }\n        let start = offset + 1, end = start + node.content.size;\n        for (let i = 0; i < this.local.length; i++) {\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to)\n                    (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([localSet, child]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n        if (this == other)\n            return true;\n        if (!(other instanceof DecorationSet) ||\n            this.local.length != other.local.length ||\n            this.children.length != other.children.length)\n            return false;\n        for (let i = 0; i < this.local.length; i++)\n            if (!this.local[i].eq(other.local[i]))\n                return false;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] != other.children[i] ||\n                this.children[i + 1] != other.children[i + 1] ||\n                !this.children[i + 2].eq(other.children[i + 2]))\n                return false;\n        return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n        if (this == empty)\n            return none;\n        if (node.inlineContent || !this.local.some(InlineType.is))\n            return this.local;\n        let result = [];\n        for (let i = 0; i < this.local.length; i++) {\n            if (!(this.local[i].type instanceof InlineType))\n                result.push(this.local[i]);\n        }\n        return result;\n    }\n}\n/**\nThe empty set of decorations.\n*/\nDecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/\nDecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members) {\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map(member => member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf)\n            return DecorationSet.empty;\n        let found = [];\n        for (let i = 0; i < this.members.length; i++) {\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty)\n                continue;\n            if (result instanceof DecorationGroup)\n                found = found.concat(result.members);\n            else\n                found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) ||\n            other.members.length != this.members.length)\n            return false;\n        for (let i = 0; i < this.members.length; i++)\n            if (!this.members[i].eq(other.members[i]))\n                return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for (let i = 0; i < this.members.length; i++) {\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length)\n                continue;\n            if (!result) {\n                result = locals;\n            }\n            else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for (let j = 0; j < locals.length; j++)\n                    result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch (members.length) {\n            case 0: return empty;\n            case 1: return members[0];\n            default: return new DecorationGroup(members.every(m => m instanceof DecorationSet) ? members :\n                members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n            let dSize = (newEnd - newStart) - (oldEnd - oldStart);\n            for (let i = 0; i < children.length; i += 3) {\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved)\n                    continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                }\n                else if (newStart >= offset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) { // Touched nodes\n            if (children[i + 1] == -2) {\n                mustRebuild = true;\n                children[i + 1] = -1;\n                continue;\n            }\n            let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n            if (fromLocal < 0 || fromLocal >= node.content.size) {\n                mustRebuild = true;\n                continue;\n            }\n            // Must read oldChildren because children was tagged with -1\n            let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n            let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n            let childNode = node.maybeChild(index);\n            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n                let mapped = children[i + 2]\n                    .mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n                if (mapped != empty) {\n                    children[i] = fromLocal;\n                    children[i + 1] = toLocal;\n                    children[i + 2] = mapped;\n                }\n                else {\n                    children[i + 1] = -2;\n                    mustRebuild = true;\n                }\n            }\n            else {\n                mustRebuild = true;\n            }\n        }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for (let i = 0; i < children.length; i += 3)\n            if (children[i + 1] < 0) {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        for (let i = 0, j = 0; i < built.children.length; i += 3) {\n            let from = built.children[i];\n            while (j < children.length && children[j] < from)\n                j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n        return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for (let i = 0; i < set.local.length; i++) {\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped)\n                decorations.push(mapped);\n            else if (options.onRemove)\n                options.onRemove(set.local[i].spec);\n        }\n        for (let i = 0; i < set.children.length; i += 3)\n            gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] == -1)\n            gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n        return null;\n    let end = offset + node.nodeSize, found = null;\n    for (let i = 0, span; i < spans.length; i++) {\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n        if (array[i] != null)\n            result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty)\n                children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n        if (!locals[i].type.valid(node, locals[i])) {\n            if (options.onRemove)\n                options.onRemove(locals[i].spec);\n            locals.splice(i--, 1);\n        }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n        let span = working[i];\n        if (span.from != span.to)\n            for (let j = i + 1; j < working.length; j++) {\n                let next = working[j];\n                if (next.from == span.from) {\n                    if (next.to != span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // Followed by a partially overlapping larger span. Split that\n                        // span.\n                        working[j] = next.copy(next.from, span.to);\n                        insertAhead(working, j + 1, next.copy(span.to, next.to));\n                    }\n                    continue;\n                }\n                else {\n                    if (next.from < span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // The end of this one overlaps with a subsequent span. Split\n                        // this one.\n                        working[i] = span.copy(span.from, next.from);\n                        insertAhead(working, j, span.copy(next.from, span.to));\n                    }\n                    break;\n                }\n            }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n        i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", f => {\n        let result = f(view.state);\n        if (result && result != empty)\n            found.push(result);\n    });\n    if (view.cursorWrapper)\n        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found);\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n            sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange) {\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.observer = window.MutationObserver &&\n            new window.MutationObserver(mutations => {\n                for (let i = 0; i < mutations.length; i++)\n                    this.queue.push(mutations[i]);\n                // IE11 will sometimes (on backspacing out a single character\n                // text node after a BR node) call the observer callback\n                // before actually updating the DOM, which will cause\n                // ProseMirror to miss the change (see #930)\n                if (ie && ie_version <= 11 && mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                    this.flushSoon();\n                else\n                    this.flush();\n            });\n        if (useCharData) {\n            this.onCharData = e => {\n                this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0)\n            this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData)\n            this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for (let i = 0; i < take.length; i++)\n                    this.queue.push(take[i]);\n                window.setTimeout(() => this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData)\n            this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view))\n            return;\n        if (this.suppressingSelectionUpdates)\n            return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode)\n            return true;\n        let ancestors = new Set, container;\n        for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n            ancestors.add(scan);\n        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n            if (ancestors.has(scan)) {\n                container = scan;\n                break;\n            }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer)\n            for (let mut of this.observer.takeRecords())\n                this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1)\n            return;\n        let mutations = this.pendingRecords();\n        if (mutations.length)\n            this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for (let i = 0; i < mutations.length; i++) {\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver)\n                        typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length > 1) {\n            let brs = added.filter(n => n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let a = brs[0], b = brs[1];\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n                    b.remove();\n                else\n                    a.remove();\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 &&\n            Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 &&\n            selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) &&\n            readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        }\n        else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty)\n                view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel))\n                selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1)\n            return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" &&\n            (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n                // Firefox sometimes fires spurious events for null/empty styles\n                (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n            return null;\n        if (!desc || desc.ignoreMutation(mut))\n            return null;\n        if (mut.type == \"childList\") {\n            for (let i = 0; i < mut.addedNodes.length; i++)\n                added.push(mut.addedNodes[i]);\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n                return { from: desc.posBefore, to: desc.posAfter };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for (let i = 0; i < mut.addedNodes.length; i++) {\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n                        prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n                        next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target\n                ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target\n                ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return { from, to };\n        }\n        else if (mut.type == \"attributes\") {\n            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n        }\n        else { // \"characterData\"\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view))\n        return;\n    cssChecked.set(view, null);\n    if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned)\n            return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view) {\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [{ node: anchor, offset: domSel.anchorOffset }];\n        if (!selectionCollapsed(domSel))\n            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for (let off = toOffset; off > fromOffset; off--) {\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size)\n                break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null)\n            head = anchor;\n        sel = { anchor: anchor + from, head: head + from };\n    }\n    return { doc, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    }\n    else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return { skip };\n        }\n        else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return { ignore: true };\n        }\n    }\n    else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return { ignore: true };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android &&\n                view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime &&\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\"))))\n                return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\")\n                tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\")\n                tr.scrollIntoView();\n            if (compositionID)\n                tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    }\n    else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) &&\n        addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName)) &&\n        (!change || change.endA >= change.endB) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = { start: sel.from, endA: sel.to, endB: sel.to };\n        }\n        else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID)\n                        tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Chrome sometimes leaves the cursor before the inserted text when\n    // composing after a cursor wrapper. This moves it forward.\n    if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from &&\n        parse.sel.head == parse.sel.anchor) {\n        let size = change.endB - change.start;\n        parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };\n    }\n    view.input.domChangeCount++;\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to &&\n        change.start == change.endB &&\n        view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&\n            view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        }\n        else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&\n            view.state.selection.to <= parse.to) {\n            change.endB += (view.state.selection.to - change.endA);\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 &&\n        change.endA == change.start && change.start > parse.from &&\n        parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    let nextSel;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if (((ios && view.input.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n        (!inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) &&\n            (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n            nextSel.head == $to.pos)) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start &&\n        looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome)\n            view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome Android will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && android && change.endB == change.start)\n        view.input.lastAndroidDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n        parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(() => {\n            view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let tr, storedMarks, markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) { // Deletion\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(() => selectionToDOM(view), 20);\n            }\n            tr = view.state.tr.delete(chFrom, chTo);\n            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n        }\n        else if ( // Adding or removing a mark\n        change.endA == change.endB &&\n            (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            tr = view.state.tr;\n            if (markChange.type == \"add\")\n                tr.addMark(chFrom, chTo, markChange.mark);\n            else\n                tr.removeMark(chFrom, chTo, markChange.mark);\n        }\n        else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            if (view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text)))\n                return;\n            tr = view.state.tr.insertText(text, chFrom, chTo);\n        }\n    }\n    if (!tr)\n        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n        let sel = resolveSelection(view, tr.doc, parse.sel);\n        // Chrome Android will sometimes, during composition, report the\n        // selection in the wrong place. If it looks like that is\n        // happening, don't update the selection.\n        // Edge just doesn't move the cursor forward when you start typing\n        // in an empty block or between br nodes.\n        if (sel && !(chrome && android && view.composing && sel.empty &&\n            (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) &&\n            (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n            ie && sel.empty && sel.head == chFrom))\n            tr.setSelection(sel);\n    }\n    if (storedMarks)\n        tr.ensureMarks(storedMarks);\n    if (compositionID)\n        tr.setMeta(\"composition\", compositionID);\n    view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size)\n        return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n        added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n        removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node) => node.mark(mark.addToSet(node.marks));\n    }\n    else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node) => node.mark(mark.removeFromSet(node.marks));\n    }\n    else {\n        return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n        updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur))\n        return { mark, type };\n}\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n    if (!$newStart.parent.isTextblock ||\n        // The content must have shrunk\n        end - start <= $newEnd.pos - $newStart.pos ||\n        // newEnd must point directly at or after the end of the block that newStart points into\n        skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n        return false;\n    let $start = old.resolve(start);\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n        return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end ||\n        skipClosingAndOpening($next, true, false) < end)\n        return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while (next && !next.isLeaf) {\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n        return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        endB = start + (endB - endA);\n        endA = start;\n    }\n    else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return { start, endA, endB };\n}\n\n/**\n@internal\n*/\nconst __serializeForClipboard = serializeForClipboard;\n/**\n@internal\n*/\nconst __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/\nconst __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/\nclass EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n        this._root = null;\n        /**\n        @internal\n        */\n        this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */\n        this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */\n        this.markCursor = null;\n        /**\n        @internal\n        */\n        this.cursorWrapper = null;\n        /**\n        @internal\n        */\n        this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */\n        this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */\n        this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */\n        this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = (place && place.mount) || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild)\n                place.appendChild(this.dom);\n            else if (typeof place == \"function\")\n                place(this.dom);\n            else if (place.mount)\n                this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() { return this.input.composing; }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for (let name in prev)\n                this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents)\n            ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n        let updated = {};\n        for (let name in this._props)\n            updated[name] = this._props[name];\n        updated.state = this.state;\n        for (let name in props)\n            updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\"\n            : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection))\n            updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing &&\n                !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? (this.trackWrites = this.domSelectionRange().focusNode) : null;\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco([]);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites)\n                    forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate ||\n                !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) &&\n                    anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            }\n            else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        }\n        else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        }\n        else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (this.someProp(\"handleScrollToSelection\", f => f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1)\n                scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        }\n        else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while (view = this.pluginViews.pop())\n            if (view.destroy)\n                view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for (let i = 0; i < this.directPlugins.length; i++) {\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n            for (let i = 0; i < this.state.plugins.length; i++) {\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n        }\n        else {\n            for (let i = 0; i < this.pluginViews.length; i++) {\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update)\n                    pluginView.update(this, prevState);\n            }\n        }\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop))\n            return value;\n        for (let i = 0; i < this.directPlugins.length; i++) {\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop))\n                return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins)\n            for (let i = 0; i < plugins.length; i++) {\n                let prop = plugins[i].props[propName];\n                if (prop != null && (value = f ? f(prop) : prop))\n                    return value;\n            }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom)\n                return true;\n            if (!node || !this.dom.contains(node))\n                return false;\n            while (node && this.dom != node && this.dom.contains(node)) {\n                if (node.contentEditable == 'false')\n                    return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n        this.domObserver.stop();\n        if (this.editable)\n            focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n        let cached = this._root;\n        if (cached == null)\n            for (let search = this.dom.parentNode; search; search = search.parentNode) {\n                if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n                    if (!search.getSelection)\n                        Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n                    return this._root = search;\n                }\n            }\n        return cached || document;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimes—for example when interpreting an event\n    target—you don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null)\n            throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */\n    pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n        if (!this.docView)\n            return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        }\n        else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    Dispatch a transaction. Will call\n    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)\n    when given, and otherwise defaults to applying the transaction to\n    the current state and calling\n    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.\n    This method is bound to the view instance, so that it can be\n    easily passed around.\n    */\n    dispatch(tr) {\n        let dispatchTransaction = this._props.dispatchTransaction;\n        if (dispatchTransaction)\n            dispatchTransaction.call(this, tr);\n        else\n            this.updateState(this.state.apply(tr));\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom\n            ? safariShadowSelectionRange(this) : this.domSelection();\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n        return this.root.getSelection();\n    }\n}\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", value => {\n        if (typeof value == \"function\")\n            value = value(view.state);\n        if (value)\n            for (let attr in value) {\n                if (attr == \"class\")\n                    attrs.class += \" \" + value[attr];\n                else if (attr == \"style\")\n                    attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n                else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n                    attrs[attr] = String(value[attr]);\n            }\n    });\n    if (!attrs.translate)\n        attrs.translate = \"no\";\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };\n    }\n    else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", value => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for (let prop in obj)\n            if (!Object.prototype.hasOwnProperty.call(result, prop))\n                result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n        if (a[prop] != b[prop])\n            return true;\n        nA++;\n    }\n    for (let _ in b)\n        nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n        throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRjtBQUNOO0FBQ2xDOztBQUVsRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx3Q0FBd0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0IscUJBQXFCLG9EQUFvRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9FQUFvRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsOENBQThDO0FBQzlDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RkFBOEY7QUFDckg7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0IsRUFBRSw0REFBYTtBQUNoRDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxtREFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6Qiw4Q0FBOEMsNERBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQXdEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixPQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNERBQWE7QUFDbEU7QUFDQTtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3Qiw4REFBOEQsNERBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBLHFCQUFxQix3REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDREQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFhO0FBQzdCLHVDQUF1Qyw0REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDREQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QywrQkFBK0IsNERBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQSxxQ0FBcUMsNERBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkRBQVksR0FBRyx3REFBUyxtQkFBbUIsd0RBQVM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0REFBYTtBQUN2RDtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckUsd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0REFBYTtBQUMxRTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVyxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsU0FBUyxRQUFRLEVBQUUsd0JBQXdCO0FBQ3RJO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRDQUE0QztBQUNoRztBQUNBLDhCQUE4QixvREFBSyxDQUFDLHVEQUFRLHFFQUFxRSxvREFBSztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUywyQkFBMkIsNERBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Rix3REFBUztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxnQkFBZ0Isb0RBQUs7QUFDckI7QUFDQTtBQUNBLHNEQUFzRCwwREFBMEQ7QUFDaEgscURBQXFELHNEQUFzRDtBQUMzRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLHVEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0Msb0NBQW9DLHVEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsdURBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHVEQUFRO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHVEQUFRO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFLO0FBQ3pCO0FBQ0Esb0JBQW9CLG9EQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFLO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkIsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNERBQWE7QUFDNUMsa0NBQWtDLDREQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0REFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUFhO0FBQy9DLGlCQUFpQiw0REFBYTtBQUM5QixrQ0FBa0MsNERBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBLGlDQUFpQyw0REFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3REFBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvREFBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDREQUFhO0FBQzlFO0FBQ0EsaURBQWlELDREQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDREQUFhO0FBQ2xFO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvREFBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFhO0FBQy9CO0FBQ0EsNEJBQTRCLDREQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLGdFQUFnRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0IsZUFBZTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0Esd0JBQXdCLG9EQUFvRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDREQUFhO0FBQ3BEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDREQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdDQUF3QztBQUNsRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0EsUUFBUSx1REFBUTtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDREQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrREFBK0QsbUNBQW1DO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcz81NjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIFNsaWNlLCBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBkb21JbmRleCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59O1xuY29uc3QgcGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSA/IHBhcmVudC5ob3N0IDogcGFyZW50O1xufTtcbmxldCByZXVzZWRSYW5nZSA9IG51bGw7XG4vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgcmFuZ2UsIGJlY2F1c2UgRE9NIHJhbmdlXG4vLyBvYmplY3RzIGFyZSBldmVyeSBleHBlbnNpdmUsIGFuZCBrZWVwIHNsb3dpbmcgZG93biBzdWJzZXF1ZW50IERPTVxuLy8gdXBkYXRlcywgZm9yIHNvbWUgcmVhc29uLlxuY29uc3QgdGV4dFJhbmdlID0gZnVuY3Rpb24gKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvID09IG51bGwgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSB8fCAwKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuY29uc3QgaXNFcXVpdmFsZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSAmJiAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKTtcbn07XG5jb25zdCBhdG9tRWxlbWVudHMgPSAvXihpbWd8YnJ8aW5wdXR8dGV4dGFyZWF8aHIpJC9pO1xuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBoYXNCbG9ja0Rlc2Mobm9kZSkgfHwgYXRvbUVsZW1lbnRzLnRlc3Qobm9kZS5ub2RlTmFtZSkgfHxcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBub2RlU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc09uRWRnZShub2RlLCBvZmZzZXQsIHBhcmVudCkge1xuICAgIGZvciAobGV0IGF0U3RhcnQgPSBvZmZzZXQgPT0gMCwgYXRFbmQgPSBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSk7IGF0U3RhcnQgfHwgYXRFbmQ7KSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgaW5kZXggPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhdFN0YXJ0ID0gYXRTdGFydCAmJiBpbmRleCA9PSAwO1xuICAgICAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgICBsZXQgZGVzYztcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChkZXNjID0gY3VyLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKTtcbn1cbi8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbi8vIChpc0NvbGxhcHNlZCBpbmFwcHJvcHJpYXRlbHkgcmV0dXJucyB0cnVlIGluIHNoYWRvdyBkb20pXG5jb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBmdW5jdGlvbiAoZG9tU2VsKSB7XG4gICAgcmV0dXJuIGRvbVNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59O1xuZnVuY3Rpb24ga2V5RXZlbnQoa2V5Q29kZSwga2V5KSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICAgIGV2ZW50LmtleSA9IGV2ZW50LmNvZGUgPSBrZXk7XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KGRvYywgeCwgeSkge1xuICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICB0cnkgeyAvLyBGaXJlZm94IHRocm93cyBmb3IgdGhpcyBjYWxsIGluIGhhcmQtdG8tcHJlZGljdCBjaXJjdW1zdGFuY2VzICgjOTk0KVxuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBwb3Mub2Zmc2V0Tm9kZSwgb2Zmc2V0OiBwb3Mub2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgIH1cbiAgICBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0IH07XG4gICAgfVxufVxuXG5jb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCBhZ2VudCA9IChuYXYgJiYgbmF2LnVzZXJBZ2VudCkgfHwgXCJcIjtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5jb25zdCBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgY2hyb21lID0gISFfY2hyb21lO1xuY29uc3QgY2hyb21lX3ZlcnNpb24gPSBfY2hyb21lID8gK19jaHJvbWVbMV0gOiAwO1xuY29uc3Qgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbi8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbmNvbnN0IG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xuY29uc3Qgd2luZG93cyA9IG5hdiA/IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlO1xuY29uc3QgYW5kcm9pZCA9IC9BbmRyb2lkIFxcZC8udGVzdChhZ2VudCk7XG5jb25zdCB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBBZGp1c3QgZm9yIGVsZW1lbnRzIHdpdGggc3R5bGUgXCJ0cmFuc2Zvcm06IHNjYWxlKClcIlxuICAgIGxldCBzY2FsZVggPSAocmVjdC53aWR0aCAvIG5vZGUub2Zmc2V0V2lkdGgpIHx8IDE7XG4gICAgbGV0IHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIG5vZGUuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gICAgbGV0IHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCwgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzsgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICBsZXQgYXRUb3AgPSBlbHQgPT0gZG9jLmJvZHk7XG4gICAgICAgIGxldCBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInRvcFwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgPyByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgIDogcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwibGVmdFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcbiAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcuc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFggPSBlbHQuc2Nyb2xsTGVmdCwgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVkpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICBsZXQgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdFRvcCB8fCAvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24pKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydFkgPSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgbGV0IHJlZkRPTSwgcmVmVG9wO1xuICAgIGZvciAobGV0IHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbG9jYWxSZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gICAgbGV0IHN0YWNrID0gW10sIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7IGRvbTogY3VyLCB0b3A6IGN1ci5zY3JvbGxUb3AsIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICBpZiAoZG9tID09IGRvYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG4vLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMgdG8gdGhhdCB3aGF0XG4vLyBpdCB3YXMgYmVmb3JlLCB3aGVuIHN0b3JlU2Nyb2xsUG9zIHdhcyBjYWxsZWQuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyh7IHJlZkRPTSwgcmVmVG9wLCBzdGFjayB9KSB7XG4gICAgbGV0IG5ld1JlZlRvcCA9IHJlZkRPTSA/IHJlZkRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgZFRvcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZG9tLCB0b3AsIGxlZnQgfSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKVxuICAgICAgICAgICAgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgZG9tLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgY2xvc2VzdCwgZHhDbG9zZXN0ID0gMmU4LCBjb29yZHNDbG9zZXN0LCBvZmZzZXQgPSAwO1xuICAgIGxldCByb3dCb3QgPSBjb29yZHMudG9wLCByb3dUb3AgPSBjb29yZHMudG9wO1xuICAgIGxldCBmaXJzdEJlbG93LCBjb29yZHNCZWxvdztcbiAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgbGV0IHJlY3RzO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnRvcCA+IGNvb3Jkcy50b3AgJiYgIWZpcnN0QmVsb3cgJiYgcmVjdC5sZWZ0IDw9IGNvb3Jkcy5sZWZ0ICYmIHJlY3QucmlnaHQgPj0gY29vcmRzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29vcmRzQmVsb3cgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgTWF0aC5taW4ocmVjdC5yaWdodCwgY29vcmRzLmxlZnQpKSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHxcbiAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0ICYmIGZpcnN0QmVsb3cpIHtcbiAgICAgICAgY2xvc2VzdCA9IGZpcnN0QmVsb3c7XG4gICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBjb29yZHNCZWxvdztcbiAgICAgICAgZHhDbG9zZXN0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgICBpZiAoIWNsb3Nlc3QgfHwgKGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpKVxuICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQgfTtcbiAgICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpO1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICFzYXdCbG9jayB8fCAhZGVzYy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCAmJiAhc2F3QmxvY2spIHtcbiAgICAgICAgICAgICAgICBzYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0IHx8IHJlY3QuYm90dG9tIDwgY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYy5jb250ZW50RE9NICYmIG91dHNpZGVCbG9jayA8IDAgJiYgIWRlc2Mubm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIGEgbGVhZiwgcmV0dXJuIHRoZSBzaWRlIG9mIHRoZSBsZWFmIGNsb3NlciB0byB0aGUgY29vcmRzXG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IGRlc2Mubm9kZS5pc0Jsb2NrID8gY29vcmRzLnRvcCA8IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgOiBjb29yZHMubGVmdCA8IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSA/IGRlc2MucG9zQmVmb3JlIDogZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBkZXNjLmRvbS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c2lkZUJsb2NrID4gLTEgPyBvdXRzaWRlQmxvY2sgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIC0xKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgICBsZXQgbGVuID0gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGJveC50b3AgPCBib3guYm90dG9tKSB7XG4gICAgICAgIGZvciAobGV0IHN0YXJ0SSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxlbiAtIDEsIE1hdGguZmxvb3IobGVuICogKGNvb3Jkcy50b3AgLSBib3gudG9wKSAvIChib3guYm90dG9tIC0gYm94LnRvcCkpIC0gMikpLCBpID0gc3RhcnRJOzspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50RnJvbVBvaW50KGNoaWxkLCBjb29yZHMsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IChpICsgMSkgJSBsZW4pID09IHN0YXJ0SSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbi8vIEdpdmVuIGFuIHgseSBwb3NpdGlvbiBvbiB0aGUgZWRpdG9yLCBnZXQgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3Jkcykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50LCBub2RlLCBvZmZzZXQgPSAwO1xuICAgIGxldCBjYXJldCA9IGNhcmV0RnJvbVBvaW50KGRvYywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGlmIChjYXJldClcbiAgICAgICAgKHsgbm9kZSwgb2Zmc2V0IH0gPSBjYXJldCk7XG4gICAgbGV0IGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYylcbiAgICAgICAgLmVsZW1lbnRGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGxldCBwb3M7XG4gICAgaWYgKCFlbHQgfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGVsdC5ub2RlVHlwZSAhPSAxID8gZWx0LnBhcmVudE5vZGUgOiBlbHQpKSB7XG4gICAgICAgIGxldCBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFpblJlY3QoY29vcmRzLCBib3gpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICAgICAgaWYgKCFlbHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCByZXR1cm5zIG5vbnNlbnNlIHdoZW4gb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgIGlmIChzYWZhcmkpIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IGVsdDsgbm9kZSAmJiBwOyBwID0gcGFyZW50Tm9kZShwKSlcbiAgICAgICAgICAgIGlmIChwLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHQgPSB0YXJnZXRLbHVkZ2UoZWx0LCBjb29yZHMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggd2lsbCBzb21ldGltZXMgcmV0dXJuIG9mZnNldHMgaW50byA8aW5wdXQ+IG5vZGVzLCB3aGljaFxuICAgICAgICAgICAgLy8gaGF2ZSBubyBhY3R1YWwgY2hpbGRyZW4sIGZyb20gY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAoIzk1MylcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBJdCdsbCBhbHNvIG1vdmUgdGhlIHJldHVybmVkIHBvc2l0aW9uIGJlZm9yZSBpbWFnZSBub2RlcyxcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhvc2UgYXJlIGJlaGluZCBpdC5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgYm94O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiSU1HXCIgJiYgKGJveCA9IG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLnJpZ2h0IDw9IGNvb3Jkcy5sZWZ0ICYmXG4gICAgICAgICAgICAgICAgICAgIGJveC5ib3R0b20gPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHJvb3QsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBicktsdWRnZSA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBGaXJlZm94LCB1c2luZyBTZWxlY3Rpb24uY29sbGFwc2UgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgYVxuICAgICAgICAvLyBCUiBub2RlIGZvciBzb21lIHJlYXNvbiBkb2Vzbid0IGFsd2F5cyB3b3JrICgjMTA3MykuIE9uIFNhZmFyaSxcbiAgICAgICAgLy8gdGhlIGN1cnNvciBzb21ldGltZXMgaW5leHBsaWNhYmxlIHZpc3VhbGx5IGxhZ3MgYmVoaW5kIGl0c1xuICAgICAgICAvLyByZXBvcnRlZCBwb3NpdGlvbiBpbiBzdWNoIHNpdHVhdGlvbnMgKCMxMDkyKS5cbiAgICAgICAgaWYgKChnZWNrbyB8fCBzYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9ICEhKG9mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSA9PSBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgICAgICAgICAgIGlmIChicktsdWRnZSAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET00gPSB7IG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsIG9mZnNldDogZG9tSW5kZXgoYWZ0ZXIpICsgMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveCBjYW4gYWN0IHN0cmFuZ2VseSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gZnJvbnQgb2YgYW5cbiAgICAgICAgLy8gdW5lZGl0YWJsZSBub2RlLiBTZWUgIzExNjMgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDk1MzZcbiAgICAgICAgaWYgKGdlY2tvICYmIGRvbVNlbC5mb2N1c05vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21TZWwuZm9jdXNOb2RlLmNoaWxkTm9kZXNbZG9tU2VsLmZvY3VzT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICBsZXQgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSBkdW1teSBkZXNjIHVzZWQgdG8gdGFnIHRyYWlsaW5nIEJSIG9yIElNRyBub2RlcyBjcmVhdGVkIHRvIHdvcmtcbi8vIGFyb3VuZCBjb250ZW50RWRpdGFibGUgdGVycmlibGVuZXNzLlxuY2xhc3MgVHJhaWxpbmdIYWNrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTsgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBcIklNR1wiOyB9XG59XG4vLyBBIHNlcGFyYXRlIHN1YmNsYXNzIGlzIHVzZWQgZm9yIGN1c3RvbWl6ZWQgbm9kZSB2aWV3cywgc28gdGhhdCB0aGVcbi8vIGV4dHJhIGNoZWNrcyBvbmx5IGhhdmUgdG8gYmUgbWFkZSBmb3Igbm9kZXMgdGhhdCBhcmUgYWN0dWFsbHlcbi8vIGN1c3RvbWl6ZWQuXG5jbGFzcyBDdXN0b21Ob2RlVmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gICAgLy8gdGhyb3VnaC4gSWYgaXQgZG9lcywgYW5kIHRoZXJlJ3MgYSBgY29udGVudERPTWAgbm9kZSwgb3VyIGxvZ2ljXG4gICAgLy8gdXBkYXRlcyB0aGUgY2hpbGRyZW4uXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoIXdyYXBwZXIuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBuZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgZm9yIChsZXQgY2ggb2Ygd3JhcHBlci5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gICAgbGV0IGN1ckRlc2MgPSBwYXJlbnREZXNjLCBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBmSSA9IGZyYWcuY2hpbGRDb3VudCwgbWF0Y2hlZCA9IG5ldyBNYXAsIG1hdGNoZXMgPSBbXTtcbiAgICBvdXRlcjogd2hpbGUgKGZJID4gMCkge1xuICAgICAgICBsZXQgZGVzYztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRlc2NJKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCB3aWRnZXQgPSBsb2NhbHNbZGVjb0luZGV4KytdLCB3aWRnZXRzO1xuICAgICAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ZXJEZWNvID0gY2hpbGQuaXNJbmxpbmUgJiYgIWNoaWxkLmlzTGVhZiA/IGFjdGl2ZS5maWx0ZXIoZCA9PiAhZC5pbmxpbmUpIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgIG9uTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpbmRleCk7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG59XG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICAgICAgbGV0IG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgfVxufVxuZnVuY3Rpb24gbmVhcmJ5VGV4dE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEZpbmQgYSBwaWVjZSBvZiB0ZXh0IGluIGFuIGlubGluZSBmcmFnbWVudCwgb3ZlcmxhcHBpbmcgZnJvbS10b1xuZnVuY3Rpb24gZmluZFRleHRJbkZyYWdtZW50KGZyYWcsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBmcmFnLmNoaWxkQ291bnQgJiYgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnLmNoaWxkKGkrKyksIGNoaWxkU3RhcnQgPSBwb3M7XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgICAgIHdoaWxlIChpIDwgZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWcuY2hpbGQoaSsrKTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0Lm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGFuY2hvciA8IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfVxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBiaWFzID0gb3JpZ2luID09IFwicG9pbnRlclwiIHx8ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCkgPyAxIDogLTE7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOlxuICAgICAgICBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvRE9NKHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBUaGUgZGVsYXllZCBkcmFnIHNlbGVjdGlvbiBjYXVzZXMgaXNzdWVzIHdpdGggQ2VsbCBTZWxlY3Rpb25zXG4gICAgLy8gaW4gU2FmYXJpLiBBbmQgdGhlIGRyYWcgc2VsZWN0aW9uIGRlbGF5IGlzIHRvIHdvcmthcm9uZCBpc3N1ZXNcbiAgICAvLyB3aGljaCBvbmx5IHByZXNlbnQgaW4gQ2hyb21lLlxuICAgIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgICAgIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBhbmNob3IsIGhlYWQgfSA9IHNlbCwgcmVzZXRFZGl0YWJsZUZyb20sIHJlc2V0RWRpdGFibGVUbztcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICghc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgICAvLyBpbnZpc2libGUgY3Vyc29yIHdyYXBwZXIsIHNpbmNlIHRoYXQgd291bGQgcmVzdWx0IGluIHRob3NlIHdlaXJkXG4gICAgLy8gcmVzaXplIGhhbmRsZXMgYW5kIGEgc2VsZWN0aW9uIHRoYXQgY29uc2lkZXJzIHRoZSBhYnNvbHV0ZWx5XG4gICAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgaWYgKCFpbWcgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiYgaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSkge1xuICAgICAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChzZWwuZnJvbSk7XG4gICAgICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICB9XG59XG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGYgPT4gZih2aWV3LCAkYW5jaG9yLCAkaGVhZCkpXG4gICAgICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuZWRpdGFibGUgJiYgIXZpZXcuaGFzRm9jdXMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24odmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiZcbiAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8IHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSA6IHNlbC5mb2N1c05vZGUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gICAgbGV0IGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkYW5jaG9yLCAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkc2lkZSA9IGRpciA+IDAgPyAkYW5jaG9yLm1heCgkaGVhZCkgOiAkYW5jaG9yLm1pbigkaGVhZCk7XG4gICAgbGV0ICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gICAgcmV0dXJuICRzdGFydCAmJiBTZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuZnVuY3Rpb24gYXBwbHkodmlldywgc2VsKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAoIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tKSB7XG4gICAgaWYgKGRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIik7XG59XG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcikge1xuICAgIHJldHVybiBkaXIgPCAwID8gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSA6IHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGFmdGVyIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLCB3aGljaCB3aWxsIGNvbmZ1c2UgdGhlIGJyb3dzZXIncyBjdXJzb3IgbW90aW9uIGxvZ2ljLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQsIGZvcmNlID0gZmFsc2U7XG4gICAgLy8gR2Vja28gd2lsbCBkbyBvZGQgdGhpbmdzIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBkaXJlY3RseSBpbiBmcm9udFxuICAgIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gICAgLy8gbm9kZSBpZiBwb3NzaWJsZS4gSXNzdWUgcHJvc2VtaXJyb3IvcHJvc2VtaXJyb3IjODMyLlxuICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KHByZXYpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYmVmb3JlIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlcikpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIGlzSWdub3JhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbC5leHRlbmQpIHtcbiAgICAgICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpXG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uKHZpZXcsIHBvcykge1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghKGNocm9tZSB8fCB3aW5kb3dzKSAmJiAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiAkcG9zLnN0YXJ0KCkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyAtIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChiZWZvcmUudG9wICsgYmVmb3JlLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhiZWZvcmUubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS5sZWZ0IDwgY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgJHBvcy5lbmQoKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdmlldy5jb29yZHNBdFBvcyhwb3MgKyAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYWZ0ZXIudG9wICsgYWZ0ZXIuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGFmdGVyLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlci5sZWZ0ID4gY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS5kaXJlY3Rpb247XG4gICAgcmV0dXJuIGNvbXB1dGVkID09IFwicnRsXCIgPyBcInJ0bFwiIDogXCJsdHJcIjtcbn1cbi8vIENoZWNrIHdoZXRoZXIgdmVydGljYWwgc2VsZWN0aW9uIG1vdGlvbiB3b3VsZCBpbnZvbHZlIG5vZGVcbi8vIHNlbGVjdGlvbnMuIElmIHNvLCBhcHBseSBpdCAoaWYgbm90LCB0aGUgcmVzdWx0IGlzIGxlZnQgdG8gdGhlXG4vLyBicm93c2VyKVxuZnVuY3Rpb24gc2VsZWN0VmVydGljYWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyIDwgMCA/IFwidXBcIiA6IFwiZG93blwiKSkge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBzaWRlID0gZGlyIDwgMCA/ICRmcm9tIDogJHRvO1xuICAgICAgICBsZXQgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgICAgICByZXR1cm4gYmV5b25kID8gYXBwbHkodmlldywgYmV5b25kKSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCBkaXIpIHtcbiAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciwgZW1wdHkgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBuZXh0Tm9kZSA9ICEkaGVhZC50ZXh0T2Zmc2V0ICYmIChkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcik7XG4gICAgaWYgKG5leHROb2RlICYmICFuZXh0Tm9kZS5pc1RleHQpIHtcbiAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zIC0gbmV4dE5vZGUubm9kZVNpemUsICRoZWFkLnBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBub2RlLCBzdGF0ZSkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gc3RhdGU7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xufVxuLy8gSXNzdWUgIzg2NyAvICMxMDkwIC8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTAzODIxXG4vLyBJbiB3aGljaCBTYWZhcmkgKGFuZCBhdCBzb21lIHBvaW50IGluIHRoZSBwYXN0LCBDaHJvbWUpIGRvZXMgcmVhbGx5XG4vLyB3cm9uZyB0aGluZ3Mgd2hlbiB0aGUgZG93biBhcnJvdyBpcyBwcmVzc2VkIHdoZW4gdGhlIGN1cnNvciBpc1xuLy8gZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGFuZCBoYXMgYW4gdW5lZGl0YWJsZSBub2RlXG4vLyBhZnRlciBpdFxuZnVuY3Rpb24gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHtcbiAgICBpZiAoIXNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgICBmb2N1c05vZGUuZmlyc3RDaGlsZCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJ0cnVlXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcImZhbHNlXCIpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIEEgYmFja2Ryb3Aga2V5IG1hcHBpbmcgdXNlZCB0byBtYWtlIHN1cmUgd2UgYWx3YXlzIHN1cHByZXNzIGtleXNcbi8vIHRoYXQgaGF2ZSBhIGRhbmdlcm91cyBkZWZhdWx0IGVmZmVjdCwgZXZlbiBpZiB0aGUgY29tbWFuZHMgdGhleSBhcmVcbi8vIGJvdW5kIHRvIHJldHVybiBmYWxzZSwgYW5kIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvci1tb3Rpb24ga2V5c1xuLy8gZmluZCBhIGN1cnNvciAoYXMgb3Bwb3NlZCB0byBhIG5vZGUgc2VsZWN0aW9uKSB3aGVuIHByZXNzZWQuIEZvclxuLy8gY3Vyc29yLW1vdGlvbiBrZXlzLCB0aGUgY29kZSBpbiB0aGUgaGFuZGxlcnMgYWxzbyB0YWtlcyBjYXJlIG9mXG4vLyBibG9jayBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJjXCI7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcIm1cIjtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJhXCI7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJzXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gICAgaWYgKGNvZGUgPT0gOCB8fCAobWFjICYmIGNvZGUgPT0gNzIgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gQmFja3NwYWNlLCBDdHJsLWggb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAtMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChjb2RlID09IDQ2ICYmICFldmVudC5zaGlmdEtleSkgfHwgKG1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAxMyB8fCBjb2RlID09IDI3KSB7IC8vIEVudGVyLCBFc2NcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzcgfHwgKG1hYyAmJiBjb2RlID09IDY2ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIExlZnQgYXJyb3csIEN0cmwtYiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzcgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gLTEgOiAxKSA6IC0xO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM5IHx8IChtYWMgJiYgY29kZSA9PSA3MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBSaWdodCBhcnJvdywgQ3RybC1mIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzOSA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAxIDogLTEpIDogMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOCB8fCAobWFjICYmIGNvZGUgPT0gODAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gVXAgYXJyb3csIEN0cmwtcCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDQwIHx8IChtYWMgJiYgY29kZSA9PSA3OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEb3duIGFycm93LCBDdHJsLW4gb24gTWFjXG4gICAgICAgIHJldHVybiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykgfHwgc2VsZWN0VmVydGljYWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQgfTtcbn1cbi8vIFJlYWQgYSBzbGljZSBvZiBjb250ZW50IGZyb20gdGhlIGNsaXBib2FyZCAob3IgZHJvcCBkYXRhKS5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gICAgbGV0IGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgZG9tLCBzbGljZTtcbiAgICBpZiAoIWh0bWwgJiYgIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhc1RleHQgPSB0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdGV4dCA/IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApIDogU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFBhcnNlclwiLCBmID0+IGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCwgdmlldykpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBzbGljZSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHZpZXcuc3RhdGUsIHNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZXh0LnNwbGl0KC8oPzpcXHJcXG4/fFxcbikrLykuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGYgPT4geyBodG1sID0gZihodG1sLCB2aWV3KTsgfSk7XG4gICAgICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgICAgICBpZiAod2Via2l0KVxuICAgICAgICAgICAgcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgICBsZXQgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gICAgaWYgKHNsaWNlRGF0YSAmJiBzbGljZURhdGFbM10pXG4gICAgICAgIGZvciAobGV0IGkgPSArc2xpY2VEYXRhWzNdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZG9tID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAhIShhc1RleHQgfHwgc2xpY2VEYXRhKSxcbiAgICAgICAgICAgIGNvbnRleHQ6ICRjb250ZXh0LFxuICAgICAgICAgICAgcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkb20ubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUgJiYgIWlubGluZVBhcmVudHMudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNsaWNlRGF0YSkge1xuICAgICAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBIVE1MIHdhc24ndCBjcmVhdGVkIGJ5IFByb3NlTWlycm9yLiBNYWtlIHN1cmUgdG9wLWxldmVsIHNpYmxpbmdzIGFyZSBjb2hlcmVudFxuICAgICAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNsaWNlLm9wZW5TdGFydCB8fCBzbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIG5vZGUgPSBub2RlLmxhc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gICAgbGV0IG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICAgIGlmIChtZXRhcylcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgICBsZXQgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxldCBmaXJzdFRhZyA9IC88KFthLXpdW14+XFxzXSspL2kuZXhlYyhodG1sKSwgd3JhcDtcbiAgICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pXG4gICAgICAgIGh0bWwgPSB3cmFwLm1hcChuID0+IFwiPFwiICsgbiArIFwiPlwiKS5qb2luKFwiXCIpICsgaHRtbCArIHdyYXAubWFwKG4gPT4gXCI8L1wiICsgbiArIFwiPlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBlbHQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBpZiAod3JhcClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZWx0ID0gZWx0LnF1ZXJ5U2VsZWN0b3Iod3JhcFtpXSkgfHwgZWx0O1xuICAgIHJldHVybiBlbHQ7XG59XG4vLyBXZWJraXQgYnJvd3NlcnMgZG8gc29tZSBoYXJkLXRvLXByZWRpY3QgcmVwbGFjZW1lbnQgb2YgcmVndWxhclxuLy8gc3BhY2VzIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB3aGVuIHB1dHRpbmcgY29udGVudCBvbiB0aGVcbi8vIGNsaXBib2FyZC4gVGhpcyB0cmllcyB0byBjb252ZXJ0IHN1Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyAod2hpY2hcbi8vIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHBsYWluIHNwYW4gb24gQ2hyb21lLCBhIHNwYW4gd2l0aCBjbGFzc1xuLy8gQXBwbGUtY29udmVydGVkLXNwYWNlIG9uIFNhZmFyaSkgYmFjayB0byByZWd1bGFyIHNwYWNlcy5cbmZ1bmN0aW9uIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pIHtcbiAgICBsZXQgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIGxldCBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICAgIHRyeSB7XG4gICAgICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5ub2Rlc1thcnJheVtpXV07XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIG9wZW5FbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuY29uc3QgZWRpdEhhbmRsZXJzID0ge307XG5jb25zdCBwYXNzaXZlSGFuZGxlcnMgPSB7IHRvdWNoc3RhcnQ6IHRydWUsIHRvdWNobW92ZTogdHJ1ZSB9O1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDbGljayA9IHsgdGltZTogMCwgeDogMCwgeTogMCwgdHlwZTogXCJcIiB9O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RGb2N1cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QW5kcm9pZERlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uSUQgPSAxO1xuICAgICAgICAvLyBTZXQgdG8gYSBjb21wb3NpdGlvbiBJRCB3aGVuIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMgYXQgY29tcG9zaXRpb25lbmRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaGlkZVNlbGVjdGlvbkd1YXJkID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5wdXQodmlldykge1xuICAgIGZvciAobGV0IGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH0sIHBhc3NpdmVIYW5kbGVyc1tldmVudF0gPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAgIC8vIGV2ZW50IGhhbmRsZXIgbWFrZXMgYW4gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW5cbiAgICAvLyB5b3UgcHJlc3MgZW50ZXIgZ28gYXdheS5cbiAgICBpZiAoc2FmYXJpKVxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIG9yaWdpbikge1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpXG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGN1cnJlbnRIYW5kbGVycyA9PiB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKCF2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBldmVudCA9PiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgaGFuZGxlcnMgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIodmlldywgZXZlbnQpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gU3VwcHJlc3MgZW50ZXIga2V5IGV2ZW50cyBvbiBDaHJvbWUgQW5kcm9pZCwgYmVjYXVzZSB0aG9zZSB0ZW5kXG4gICAgLy8gdG8gYmUgcGFydCBvZiBhIGNvbmZ1c2VkIHNlcXVlbmNlIG9mIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlZCxcbiAgICAvLyBhbmQgaGFuZGxpbmcgdGhlbSBlYWdlcmx5IHRlbmRzIHRvIGNvcnJ1cHQgdGhlIGlucHV0LlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAgIC8vIGtleWJvYXJkIGdldHMgY29uZnVzZWQuIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gc2V0IGEgZmxhZyB0aGF0XG4gICAgLy8gbWFrZXMgdGhlIERPTSBjaGFuZ2UgY29kZSByZWNvZ25pemUgdGhhdCB3aGF0IGp1c3QgaGFwcGVucyBzaG91bGRcbiAgICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICAgIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBldmVudCkpIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICAgIH1cbn07XG5lZGl0SGFuZGxlcnMua2V5dXAgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNilcbiAgICAgICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHx8ICFldmVudC5jaGFyQ29kZSB8fFxuICAgICAgICBldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHwgbWFjICYmIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGYgPT4gZih2aWV3LCBldmVudCkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQpKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwic2luZ2xlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwidHJpcGxlQ2xpY2tcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7IHRpbWU6IG5vdywgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdHlwZSB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjID8gdGFyZ2V0RGVzYy5kb20gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kb21TZWxlY3Rpb24oKS5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcylcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5kb21PYnNlcnZlci5mbHVzaCgpKTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKys7XG4gICAgICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCAyMCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCBkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGlmIChkZWxheSA+IC0xKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGVuZENvbXBvc2l0aW9uKHZpZXcpLCBkZWxheSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IG1vdXNlRG93biA9IHZpZXcuaW5wdXQubW91c2VEb3duO1xuICAgIGlmIChtb3VzZURvd24pXG4gICAgICAgIG1vdXNlRG93bi5kb25lKCk7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO1xuICAgIGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZXZlbnQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSkpKTtcbiAgICB9XG4gICAgbGV0IHNsaWNlID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpXG4gICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG59XG5jb25zdCBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuLyoqXG5BIGNvbGxlY3Rpb24gb2YgW2RlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKSwgb3JnYW5pemVkIGluIHN1Y2hcbmEgd2F5IHRoYXQgdGhlIGRyYXdpbmcgYWxnb3JpdGhtIGNhbiBlZmZpY2llbnRseSB1c2UgYW5kIGNvbXBhcmVcbnRoZW0uIFRoaXMgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJl4oCUaXQgaXMgbm90IG1vZGlmaWVkLFxudXBkYXRlcyBjcmVhdGUgYSBuZXcgdmFsdWUuXG4qL1xuY2xhc3MgRGVjb3JhdGlvblNldCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbCwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zLCB1c2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIE5lZWRzIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0b1xuICAgIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHJlZSBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0ID49IG9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBicnNbMF0sIGIgPSBicnNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChtdXQuYWRkZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NICYmIGRlc2MuY29udGVudERPTSAhPSBkZXNjLmRvbSAmJiAhZGVzYy5jb250ZW50RE9NLmNvbnRhaW5zKG11dC50YXJnZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQmVmb3JlLCB0bzogZGVzYy5wb3NBZnRlciB9O1xuICAgICAgICAgICAgbGV0IHByZXYgPSBtdXQucHJldmlvdXNTaWJsaW5nLCBuZXh0ID0gbXV0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSBnaXZlcyB1cyBpbmNvcnJlY3QgbmV4dC9wcmV2IHNpYmxpbmdzIGZvciBzb21lXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcgfSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbU9mZnNldCA9IHByZXYgJiYgcHJldi5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KHByZXYpICsgMSA6IDA7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIGxldCB0b09mZnNldCA9IG5leHQgJiYgbmV4dC5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KG5leHQpIDogbXV0LnRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyLCB0bzogZGVzYy5wb3NBdEVuZCArIGRlc2MuYm9yZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNCBmaXhcbmZ1bmN0aW9uIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHZpZXcpIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMikgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dSb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VycmVudEFuY2hvciA9IHZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJyZW50QW5jaG9yLm5vZGUsIGN1cnJlbnRBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSBzb21ldGltZXMgbGVhdmVzIHRoZSBjdXJzb3IgYmVmb3JlIHRoZSBpbnNlcnRlZCB0ZXh0IHdoZW5cbiAgICAvLyBjb21wb3NpbmcgYWZ0ZXIgYSBjdXJzb3Igd3JhcHBlci4gVGhpcyBtb3ZlcyBpdCBmb3J3YXJkLlxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20gJiZcbiAgICAgICAgcGFyc2Uuc2VsLmhlYWQgPT0gcGFyc2Uuc2VsLmFuY2hvcikge1xuICAgICAgICBsZXQgc2l6ZSA9IGNoYW5nZS5lbmRCIC0gY2hhbmdlLnN0YXJ0O1xuICAgICAgICBwYXJzZS5zZWwgPSB7IGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplIH07XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmICEkZnJvbS5zYW1lUGFyZW50KCR0bykgJiZcbiAgICAgICAgICAgIChuZXh0U2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKHBhcnNlLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpLCAxLCB0cnVlKSkgJiZcbiAgICAgICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlSm9pbihkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IHRyLCBzdG9yZWRNYXJrcywgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cilcbiAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2sgfHxcbiAgICAgICAgLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgICAgLy8gbmV3RW5kIG11c3QgcG9pbnQgZGlyZWN0bHkgYXQgb3IgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYmxvY2sgdGhhdCBuZXdTdGFydCBwb2ludHMgaW50b1xuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkc3RhcnQgPSBvbGQucmVzb2x2ZShzdGFydCk7XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kQSwgZW5kQiB9O1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICh0aGlzLnNvbWVQcm9wKFwiaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb25cIiwgZiA9PiBmKHRoaXMpKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgMSksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICB3aGlsZSAodmlldyA9IHRoaXMucGx1Z2luVmlld3MucG9wKCkpXG4gICAgICAgICAgICBpZiAodmlldy5kZXN0cm95KVxuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlLnBsdWdpbnMgIT0gdGhpcy5zdGF0ZS5wbHVnaW5zIHx8IHRoaXMuZGlyZWN0UGx1Z2lucyAhPSB0aGlzLnByZXZEaXJlY3RQbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXPigJRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldOKAlHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBlZGl0b3IgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95cyBhbGwgW25vZGVcbiAgICB2aWV3c10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIERpc3BhdGNoIGEgdHJhbnNhY3Rpb24uIFdpbGwgY2FsbFxuICAgIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgd2hlbiBnaXZlbiwgYW5kIG90aGVyd2lzZSBkZWZhdWx0cyB0byBhcHBseWluZyB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2FsbGluZ1xuICAgIFtgdXBkYXRlU3RhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4gICAgVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIHZpZXcgaW5zdGFuY2UsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgKi9cbiAgICBkaXNwYXRjaCh0cikge1xuICAgICAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBzYWZhcmkgJiYgdGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSAmJiBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbVxuICAgICAgICAgICAgPyBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzKSA6IHRoaXMuZG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkLCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-view/dist/index.js\n");

/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RopeSequence);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFVBQVUsb0JBQW9CLFVBQVU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLFFBQVEsOENBQThDO0FBQ3REOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsUUFBUSw4Q0FBOEM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLGdEQUFnRDs7QUFFaEQsK0NBQStDOztBQUUvQzs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGlFQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanM/MzllNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR09PRF9MRUFGX1NJWkUgPSAyMDA7XG5cbi8vIDo6IGNsYXNzPFQ+IEEgcm9wZSBzZXF1ZW5jZSBpcyBhIHBlcnNpc3RlbnQgc2VxdWVuY2UgZGF0YSBzdHJ1Y3R1cmVcbi8vIHRoYXQgc3VwcG9ydHMgYXBwZW5kaW5nLCBwcmVwZW5kaW5nLCBhbmQgc2xpY2luZyB3aXRob3V0IGRvaW5nIGFcbi8vIGZ1bGwgY29weS4gSXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBtb3N0bHktYmFsYW5jZWQgdHJlZS5cbnZhciBSb3BlU2VxdWVuY2UgPSBmdW5jdGlvbiBSb3BlU2VxdWVuY2UgKCkge307XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIG90aGVyID0gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpO1xuXG4gIHJldHVybiAoIXRoaXMubGVuZ3RoICYmIG90aGVyKSB8fFxuICAgIChvdGhlci5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiB0aGlzLmxlYWZBcHBlbmQob3RoZXIpKSB8fFxuICAgICh0aGlzLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIG90aGVyLmxlYWZQcmVwZW5kKHRoaXMpKSB8fFxuICAgIHRoaXMuYXBwZW5kSW5uZXIob3RoZXIpXG59O1xuXG4vLyA6OiAodW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBQcmVwZW5kIGFuIGFycmF5IG9yIG90aGVyIHJvcGUgdG8gdGhpcyBvbmUsIHJldHVybmluZyBhIG5ldyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpLmFwcGVuZCh0aGlzKVxufTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbn07XG5cbi8vIDo6ICg/bnVtYmVyLCA/bnVtYmVyKSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcGVzZW50aW5nIGEgc3ViLXNlcXVlbmNlIG9mIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPj0gdG8pIHsgcmV0dXJuIFJvcGVTZXF1ZW5jZS5lbXB0eSB9XG4gIHJldHVybiB0aGlzLnNsaWNlSW5uZXIoTWF0aC5tYXgoMCwgZnJvbSksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgVFxuLy8gUmV0cmlldmUgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gIHJldHVybiB0aGlzLmdldElubmVyKGkpXG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiA/Ym9vbCwgP251bWJlciwgP251bWJlcilcbi8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW5cbi8vIGluZGljZXMuIFRoaXMgdGVuZHMgdG8gYmUgbW9yZSBlZmZpY2llbnQgdGhhbiBsb29waW5nIG92ZXIgdGhlXG4vLyBpbmRpY2VzIGFuZCBjYWxsaW5nIGBnZXRgLCBiZWNhdXNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBkZXNjZW5kIHRoZVxuLy8gdHJlZSBmb3IgZXZlcnkgZWxlbWVudC5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tIDw9IHRvKVxuICAgIHsgdGhpcy5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiBVLCA/bnVtYmVyLCA/bnVtYmVyKSDihpIgW1VdXG4vLyBNYXAgdGhlIGdpdmVuIGZ1bmN0aW9ucyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgcm9wZSwgcHJvZHVjaW5nXG4vLyBhIGZsYXQgYXJyYXkuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsdCwgaSkgeyByZXR1cm4gcmVzdWx0LnB1c2goZihlbHQsIGkpKTsgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoP3VuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm4gdGhlIHJvcGVcbi8vIGl0c2VsZiBpZiBhIHJvcGUgd2FzIGdpdmVuLlxuUm9wZVNlcXVlbmNlLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJvcGVTZXF1ZW5jZSkgeyByZXR1cm4gdmFsdWVzIH1cbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID8gbmV3IExlYWYodmFsdWVzKSA6IFJvcGVTZXF1ZW5jZS5lbXB0eVxufTtcblxudmFyIExlYWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gTGVhZih2YWx1ZXMpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgTGVhZi5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIExlYWYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgTGVhZi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWFmO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkZXB0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuc2xpY2UoZnJvbSwgdG8pKVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaV1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbSAtIDE7IGkgPj0gdG87IGktLSlcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5jb25jYXQob3RoZXIuZmxhdHRlbigpKSkgfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYob3RoZXIuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnZhbHVlcykpIH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5kZXB0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExlYWYucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGVhZjtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbi8vIDo6IFJvcGVTZXF1ZW5jZVxuLy8gVGhlIGVtcHR5IHJvcGUgc2VxdWVuY2UuXG5Sb3BlU2VxdWVuY2UuZW1wdHkgPSBuZXcgTGVhZihbXSk7XG5cbnZhciBBcHBlbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gQXBwZW5kKGxlZnQsIHJpZ2h0KSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aDtcbiAgICB0aGlzLmRlcHRoID0gTWF0aC5tYXgobGVmdC5kZXB0aCwgcmlnaHQuZGVwdGgpICsgMTtcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgQXBwZW5kLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgQXBwZW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIEFwcGVuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcHBlbmQ7XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdC5mbGF0dGVuKCkuY29uY2F0KHRoaXMucmlnaHQuZmxhdHRlbigpKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiBpIDwgdGhpcy5sZWZ0Lmxlbmd0aCA/IHRoaXMubGVmdC5nZXQoaSkgOiB0aGlzLnJpZ2h0LmdldChpIC0gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaElubmVyKGYsIGZyb20sIE1hdGgubWluKHRvLCBsZWZ0TGVuKSwgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaElubmVyKGYsIE1hdGgubWF4KGZyb20gLSBsZWZ0TGVuLCAwKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20gLSBsZWZ0TGVuLCBNYXRoLm1heCh0bywgbGVmdExlbikgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBNYXRoLm1pbihmcm9tLCBsZWZ0TGVuKSwgdG8sIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKHRvIDw9IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCB0bykgfVxuICAgIGlmIChmcm9tID49IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMucmlnaHQuc2xpY2UoZnJvbSAtIGxlZnRMZW4sIHRvIC0gbGVmdExlbikgfVxuICAgIHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgbGVmdExlbikuYXBwZW5kKHRoaXMucmlnaHQuc2xpY2UoMCwgdG8gLSBsZWZ0TGVuKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMucmlnaHQubGVhZkFwcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgaW5uZXIpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5sZWZ0LmxlYWZQcmVwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQoaW5uZXIsIHRoaXMucmlnaHQpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVmdC5kZXB0aCA+PSBNYXRoLm1heCh0aGlzLnJpZ2h0LmRlcHRoLCBvdGhlci5kZXB0aCkgKyAxKVxuICAgICAgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIG5ldyBBcHBlbmQodGhpcy5yaWdodCwgb3RoZXIpKSB9XG4gICAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG4gIH07XG5cbiAgcmV0dXJuIEFwcGVuZDtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJvcGVTZXF1ZW5jZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/rope-sequence/dist/index.js\n");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   keyName: () => (/* binding */ keyName),\n/* harmony export */   shift: () => (/* binding */ shift)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxHQUFHOztBQUU3RTtBQUNBLGdCQUFnQixRQUFROztBQUV4QjtBQUNBLGdCQUFnQixTQUFTOztBQUV6QjtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzPzZjODgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.js\n");

/***/ })

}]);